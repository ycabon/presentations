// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/2d/engine/webgl/shaders/lineShaders.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\x3c!--\n  // YF TODO: (doc)\n--\x3e\n\x3csnippets\x3e\n  \x3csnippet name\x3d"thinLineParams"\x3e\n     \x3c![CDATA[\n    float thinLineHalfWidth \x3d 1.0; // meaning that a 2 pixels line width is considered a thin line\n    float thinLineWidthFactor \x3d 1.1;\n     ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"lineVVUniformsVS"\x3e\n    \x3c![CDATA[\n  #if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY)\n    attribute vec3 a_vv;\n  #endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY\n\n  #ifdef VV_COLOR\n    uniform float u_vvColorValues[8];\n    uniform vec4 u_vvColors[8];\n  #endif // VV_COLOR\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    uniform vec4 u_vvSizeMinMaxValue;\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n    uniform float u_vvSizeScaleStopsValue;\n  #endif\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    uniform float u_vvSizeFieldStopsValues[6];\n    uniform float u_vvSizeFieldStopsSizes[6];\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    uniform float u_vvSizeUnitValueWorldToPixelsRatio;\n  #endif // VV_SIZE_UNIT_VALUE\n\n  #ifdef VV_OPACITY\n    uniform float u_vvOpacityValues[8];\n    uniform float u_vvOpacities[8];\n  #endif // VV_OPACITY\n    ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"lineVVFunctions"\x3e\n    \x3c![CDATA[\n    bool isNan(float val) {\n      return !( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 );\n    }\n    \n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    float getVVMinMaxSize(float sizeValue, float fallback) {\n      if (isNan(sizeValue)) { \n        return fallback;\n      }\n\n      float f \x3d (sizeValue - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n      return clamp(mix(u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w, f), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n    }\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    const int VV_SIZE_N \x3d 6;\n    float getVVStopsSize(float sizeValue, float fallback) {\n      if (isNan(sizeValue)) { \n        return fallback;\n      }\n\n      if (sizeValue \x3c\x3d u_vvSizeFieldStopsValues[0]) {\n        return u_vvSizeFieldStopsSizes[0];\n      }\n\n      for (int i \x3d 1; i \x3c VV_SIZE_N; ++i) {\n        if (u_vvSizeFieldStopsValues[i] \x3e\x3d sizeValue) {\n          float f \x3d (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n          return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n        }\n      }\n\n      return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n    }\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    float getVVUnitValue(float sizeValue, float fallback) {\n      if (isNan(sizeValue)) { \n        return fallback;\n      }\n\n      return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n    }\n  #endif // VV_SIZE_UNIT_VALUE\n\n  #ifdef VV_OPACITY\n    const int VV_OPACITY_N \x3d 8;\n    float getVVOpacity(float opacityValue) {\n      if (isNan(opacityValue)) { \n        return 1.0;\n      }\n\n      if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\n        return u_vvOpacities[0];\n      }\n\n      for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\n        if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\n          float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n          return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n        }\n      }\n\n      return u_vvOpacities[VV_OPACITY_N - 1];\n    }\n  #endif // VV_OPACITY\n\n  #ifdef VV_COLOR\n    const int VV_COLOR_N \x3d 8;\n\n    vec4 getVVColor(float colorValue, vec4 fallback) {\n      if (isNan(colorValue)) { \n        return fallback;\n      }\n\n      if (colorValue \x3c\x3d u_vvColorValues[0]) {\n        return u_vvColors[0];\n      }\n\n      for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\n        if (u_vvColorValues[i] \x3e\x3d colorValue) {\n          float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n          return mix(u_vvColors[i-1], u_vvColors[i], f);\n        }\n      }\n\n      return u_vvColors[VV_COLOR_N - 1];\n    }\n  #endif // VV_COLOR\n    ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"lineVS"\x3e\n    \x3c![CDATA[\n     precision mediump float;\n\n     attribute vec2 a_pos;\n     attribute vec4 a_id;\n     attribute vec4 a_color;\n     attribute vec4 a_offsetAndNormal;\n     attribute vec2 a_accumulatedDistanceAndHalfWidth;\n     attribute vec4 a_tlbr;\n     attribute vec4 a_segmentDirection;\n\n     // the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n     // relative to the tile\'s upper left corner\n     // the extrusion vector.\n     uniform highp mat4 u_transformMatrix;\n     // the extrude matrix which is responsible for the \'anti-zoom\' as well as the rotation\n     uniform highp mat4 u_extrudeMatrix;\n     // u_normalized_origin is the tile\'s upper left corner given in normalized coordinates\n     uniform highp vec2 u_normalized_origin;\n     uniform lowp float u_opacity; // the layer\'s opacity\n     uniform mediump float u_zoomFactor;\n     uniform mediump float u_antialiasing;\n\n     // the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\n     varying mediump vec2 v_normal;\n     varying mediump float v_lineHalfWidth;\n     varying lowp vec4 v_color;\n     varying lowp float v_transparency;\n\n     const float scale \x3d 1.0 / 31.0;\n#ifdef SDF\n     const float widthFactor \x3d 2.0;\n#else\n     const float widthFactor \x3d 1.0;\n#endif\n\n\n#ifdef PATTERN\n     uniform mediump vec2 u_mosaicSize;\n\n     varying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\n     varying mediump vec2 v_patternSize;\n#endif // PATTERN\n\n// we need to accumulated distance only if it is a pattern or an SDF line\n#if defined(PATTERN) || defined(SDF)\n     varying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef ID\n     varying highp vec4 v_id;\n#endif // ID\n\n     // import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n     $lineVVUniformsVS\n     $lineVVFunctions\n\n     void main()\n     {\n     // size VV block\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n       mediump float lineHalfWidth \x3d 0.5 * getVVMinMaxSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n       mediump float lineHalfWidth \x3d 0.5 * u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n       mediump float lineHalfWidth \x3d 0.5 * getVVStopsSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n       mediump float lineHalfWidth \x3d 0.5 * getVVUnitValue(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_UNIT_VALUE\n\n#else // no VV\n       mediump float lineHalfWidth \x3d a_accumulatedDistanceAndHalfWidth.y * scale;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_OPACITY\n      v_transparency \x3d u_opacity * getVVOpacity(a_vv.z);\n#else\n      v_transparency \x3d u_opacity;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n      v_color \x3d getVVColor(a_vv.y, a_color);\n#else\n      v_color \x3d a_color;\n#endif // VV_COLOR\n\n       // make sure to clip the vertices in case that the width of the line is 0 (or negative)\n       float z \x3d 2.0 * step(lineHalfWidth, 0.0);\n\n       // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n       // also limit the total line width to 1.3 pixels. Below this value lines don\'t look good compared to the SVG renderer\n       lineHalfWidth \x3d max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n       // include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n       $thinLineParams\n       // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n       // in practice, a thin line is a line who\'s half width vary from 0.45px to the value of thinLineHalfWidth, as the value\n       // is claped in line 221 above\n       mediump float thinLineFactor \x3d max(thinLineWidthFactor * step(lineHalfWidth, thinLineHalfWidth), 1.0);\n\n       v_lineHalfWidth \x3d lineHalfWidth;\n\n       // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n       // sake of using less attribute memory, we need to scale it back to the original range of ~ [0, 1])\n       // in a case of a thin line we move each vertex twice as far\n       mediump vec2 dist \x3d thinLineFactor * widthFactor * lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n       // transform the vertex\n       gl_Position \x3d vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(a_pos, z, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\n       v_normal \x3d a_offsetAndNormal.zw * scale;\n\n#if defined(PATTERN) || defined(SDF)\n       v_accumulatedDistance \x3d a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif // PATTERN || SDF\n\n#ifdef PATTERN\n      v_tlbr \x3d vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\n      v_patternSize \x3d vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif // PATTERN\n\n#ifdef ID\n      v_id \x3d a_id;\n#endif // ID\n     }\n    ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"lineFS"\x3e\n    \x3c![CDATA[\n       precision lowp float;\n\n       uniform lowp float u_blur;\n       uniform mediump float u_antialiasing;\n\n       varying mediump vec2 v_normal;\n       varying mediump float v_lineHalfWidth;\n       varying lowp vec4 v_color;\n       varying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\n      uniform sampler2D u_texture;\n      uniform mediump float u_zoomFactor;\n\n      varying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\n      varying mediump vec2 v_patternSize;\n      varying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\n      const float sdfPatternHalfWidth \x3d 15.5; // YF: assumed that the width will be set to 31\n     const float widthFactor \x3d 2.0;\n\n    // Factors to convert rgba back to float\n    const vec4 rgba2float_factors \x3d vec4(\n        255.0 / (256.0),\n        255.0 / (256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n      );\n\n    float rgba2float(vec4 rgba) {\n      // Convert components from 0-\x3e1 back to 0-\x3e255 and then\n      // add the components together with their corresponding\n      // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n      return dot(rgba, rgba2float_factors);\n    }\n#endif // SDF\n\n#ifdef ID\n     varying highp vec4 v_id;\n#endif // ID\n\n       void main()\n       {\n         // include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n         $thinLineParams\n\n         // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n         mediump float thinLineFactor \x3d max(thinLineWidthFactor * step(v_lineHalfWidth, thinLineHalfWidth), 1.0);\n\n         // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n         // and any value in between will be inside the line (the sign represent the direction - right or left).\n         // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n         mediump float fragDist \x3d length(v_normal) * v_lineHalfWidth;\n\n         // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n         // when it is a thin line then use a slightly shallower slope in order to add more feathering\n         lowp float alpha \x3d clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF)\n         mediump float lineHalfWidth \x3d widthFactor * v_lineHalfWidth;\n         mediump float lineWidthRatio \x3d lineHalfWidth / sdfPatternHalfWidth;\n         mediump float relativeTexX \x3d mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n         mediump float relativeTexY \x3d 0.5 + 0.5 * v_normal.y;\n\n          // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n         mediump vec2 texCoord \x3d mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n         // calculate the distance from the edge [-0.5, 0.5]\n         mediump float d \x3d rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n         // the distance is a proportional to the line width\n         float dist \x3d d * lineHalfWidth;\n\n         lowp vec4 fillPixelColor \x3d v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n        gl_FragColor \x3d fillPixelColor;\n#elif defined(PATTERN)\n         // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n         // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n         mediump float relativeTexX \x3d mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n         // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n         // which range from -1.0 to 1.0. On the line\'s centerline, the value of the interpolated normal is 0.0, however the relative\n         // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n         // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n         //              | -\x3e line-width / 2\n         //      - - - - - - - - - - - - - -\n         //              | -\x3e line-width / 2\n         //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n         mediump float relativeTexY \x3d 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n         // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n         mediump vec2 texCoord \x3d mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n         // get the color from the texture\n         lowp vec4 color \x3d texture2D(u_texture, texCoord);\n\n         gl_FragColor \x3d v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n         // output the fragment color\n         gl_FragColor \x3d v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n         gl_FragColor.a \x3d step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n #ifdef ID\n         if (gl_FragColor.a \x3c 1.0 / 255.0) {\n           discard;\n         }\n         gl_FragColor \x3d v_id;\n #endif // ID\n       }\n    ]]\x3e\n  \x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define(["require","exports","dojo/text!./lineShaders.xml","../../../../webgl/ShaderSnippets"],function(a,d,c,b){a=new b;b.parse(c,a);return a});