// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/2d/engine/webgl/shaders/textShaders.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\x3c!--\n  Add your GLSL snippets to this file. You should start from\n  importing your old GLSL files. For instance, if you have a\n  file such as myShader.vs.glsl you should create a new \x3csnippet name\x3d"myShaderVS"\x3e\n  and then copy and paste the GLSL source as the content. You will then convert your\n  code to use the {@link esri/views/2d/engine/webgl/glShaderSnippets glShaderSnippets}\n  instance to access the GLSL code, instead of importing it directly with require("dojo/text!...").\n--\x3e\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"textVVUniformsVS"\x3e\n    \x3c![CDATA[\n  #if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n    attribute vec4 a_vv;\n  #endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n  #ifdef VV_COLOR\n    uniform float u_vvColorValues[8];\n    uniform vec4 u_vvColors[8];\n  #endif // VV_COLOR\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    uniform vec4 u_vvSizeMinMaxValue;\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n    uniform float u_vvSizeScaleStopsValue;\n  #endif // VV_SIZE_SCALE_STOPS\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    uniform float u_vvSizeFieldStopsValues[6];\n    uniform float u_vvSizeFieldStopsSizes[6];\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    uniform float u_vvSizeUnitValueWorldToPixelsRatio;\n  #endif // VV_SIZE_UNIT_VALUE\n\n  #ifdef VV_OPACITY\n    uniform float u_vvOpacityValues[8];\n    uniform float u_vvOpacities[8];\n  #endif // VV_OPACITY\n\n  #ifdef VV_ROTATION\n    uniform lowp float u_vvRotationType;\n  #endif // VV_ROTATION\n    ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"textVVFunctions"\x3e\n    \x3c![CDATA[\n    bool isNan(float val) {\n      return !( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 );\n    }\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    float getVVMinMaxSize(float sizeValue, float fallback) {\n      if (isNan(sizeValue)) { \n        return fallback;\n      }\n\n      // we need to multiply by 8 in order to translate to tile coordinates\n      float interpolationRatio \x3d (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n      return clamp(u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n    }\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    const int VV_SIZE_N \x3d 6;\n    float getVVStopsSize(float sizeValue, float fallback) {\n      if (isNan(sizeValue)) { \n        return fallback;\n      }\n\n      if (sizeValue \x3c\x3d u_vvSizeFieldStopsValues[0]) {\n        return u_vvSizeFieldStopsSizes[0];\n      }\n\n      for (int i \x3d 1; i \x3c VV_SIZE_N; ++i) {\n        if (u_vvSizeFieldStopsValues[i] \x3e\x3d sizeValue) {\n          float f \x3d (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n          return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n        }\n      }\n\n      return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n    }\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    float getVVUnitValue(float sizeValue, float fallback) {\n      if (isNan(sizeValue)) { \n        return fallback;\n      }\n\n      return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n    }\n  #endif // VV_SIZE_UNIT_VALUE\n\n  #ifdef VV_OPACITY\n    const int VV_OPACITY_N \x3d 8;\n    float getVVOpacity(float opacityValue) {\n      if (isNan(opacityValue)) { \n        return 1.0;\n      }\n\n      if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\n        return u_vvOpacities[0];\n      }\n\n      for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\n        if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\n          float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n          return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n        }\n      }\n\n      return u_vvOpacities[VV_OPACITY_N - 1];\n    }\n  #endif // VV_OPACITY\n\n  #ifdef VV_ROTATION\n    mat4 getVVRotation(float rotationValue) {\n      // YF TODO: if the symbol has rotation we need to combine the symbo\'s rotation with the VV one\n      if (isNan(rotationValue)) { \n        return mat4(1, 0, 0, 0,\n                    0, 1, 0, 0,\n                    0, 0, 1, 0,\n                    0, 0, 0, 1);\n      }\n      \n      float rotation \x3d rotationValue;\n      if (u_vvRotationType \x3d\x3d 1.0) {\n        rotation \x3d 90.0 - rotation;\n      }\n\n      float angle \x3d C_DEG_TO_RAD * rotation;\n\n      float sinA \x3d sin(angle);\n      float cosA \x3d cos(angle);\n\n      return mat4(cosA, sinA, 0, 0,\n                  -sinA,  cosA, 0, 0,\n                  0,     0, 1, 0,\n                  0,     0, 0, 1);\n    }\n  #endif // VV_ROTATION\n\n  #ifdef VV_COLOR\n    const int VV_COLOR_N \x3d 8;\n\n    vec4 getVVColor(float colorValue, vec4 fallback) {\n      if (isNan(colorValue)) { \n        return fallback;\n      }\n      \n      if (colorValue \x3c\x3d u_vvColorValues[0]) {\n        return u_vvColors[0];\n      }\n\n      for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\n        if (u_vvColorValues[i] \x3e\x3d colorValue) {\n          float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n          return mix(u_vvColors[i-1], u_vvColors[i], f);\n        }\n      }\n\n      return u_vvColors[VV_COLOR_N - 1];\n    }\n  #endif // VV_COLOR\n    ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"textVS"\x3e\n    \x3c![CDATA[\n      precision mediump float;\n\n      const float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\n\n      attribute vec2 a_pos;           // 2 * 2 (2 x signed 16)\n      attribute vec4 a_id;            // 4 (4 x unsigned byte)\n      attribute vec4 a_color;         // 4 (4 x unsigned byte)\n      attribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\n      attribute vec4 a_texFontSize; // 4 (4 x unsigned byte) texture coordinatesm and font size\n\n      attribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n      // the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n      // relative to the tile\'s upper left corner\n      // the extrusion vector.\n      uniform highp mat4 u_transformMatrix;\n      // the extrude matrix which is responsible for the \'anti-zoom\' as well as the rotation\n      uniform highp mat4 u_extrudeMatrix;\n      // u_normalized_origin is the tile\'s upper left corner given in normalized coordinates\n      uniform highp vec2 u_normalized_origin;\n      // the size of the mosaic given in pixels\n      uniform vec2 u_mosaicSize;\n      uniform float u_pixelRatio;\n\n      // the opacity of the layer\n      uniform mediump float u_opacity;\n\n      varying mediump vec4 v_color;\n      varying mediump float v_antialiasingWidth;\n      varying mediump float v_edgeDistanceOffset;\n\n      // the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\n      varying mediump vec2 v_tex;\n      // the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n      // opacity of the layer given by the painter\n      varying lowp float v_transparency;\n\n      // the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n      // by 16 and then at the shader devide by the same number\n      const float offsetPrecision \x3d 1.0 / 32.0;\n      const float outlineScale \x3d 1.0 / 10.0;\n      const float sdfFontSize \x3d 24.0;\n\n      // maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n      // 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\n      const float maxSdfDistance \x3d 8.0;\n\n  #ifdef ID\n    varying highp vec4 v_id;\n  #endif // ID\n\n      // import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n      $textVVUniformsVS\n      $textVVFunctions\n\n      void main()\n      {\n        // make sure to clip the vertices in case that given record is marked as invisible\n        float z \x3d 2.0 * (1.0 - a_visible);\n\n        // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\n        mediump float halo \x3d mod(a_pos, 2.0).x;\n\n  #if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n        // vv size override the original symbol\'s size\n        vec2 size \x3d vec2(getVVMinMaxSize(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n        vec2 size \x3d vec2(u_vvSizeScaleStopsValue);\n  #endif // VV_SIZE_SCALE_STOPS\n\n  #ifdef VV_SIZE_FIELD_STOPS\n        vec2 size \x3d vec2(getVVStopsSize(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n        vec2 size \x3d vec2(getVVUnitValue(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_UNIT_VALUE\n\n        float fontSize \x3d size.x;\n  #else // this generic case, no VV\n        float fontSize \x3d a_texFontSize.z;\n  #endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n        float fontScale \x3d fontSize / sdfFontSize;\n        // we need to scale the extrude matrix by the font-scale in order to get the right text size\n        mat4 extrudeMatrix \x3d fontScale * u_extrudeMatrix;\n\n        // If the label rotates with the map, and if the rotated label is upside down, hide it\n        //gl_Position \x3d vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) + extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n\n    #ifdef VV_ROTATION\n        gl_Position \x3d vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) + extrudeMatrix * getVVRotation(a_vv.w) * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n    #else\n        gl_Position \x3d vec4(u_normalized_origin, 0.0, 0.0) + u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) + extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n    #endif // VV_ROTATION\n\n        v_tex \x3d a_texFontSize.xy / u_mosaicSize;\n        v_antialiasingWidth \x3d 0.105 * sdfFontSize / fontSize / u_pixelRatio;\n        // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n        v_edgeDistanceOffset \x3d halo * outlineScale * a_texFontSize.w / fontScale / maxSdfDistance;\n\n    #ifdef VV_OPACITY\n        v_transparency \x3d getVVOpacity(a_vv.z);\n    #else\n        v_transparency \x3d u_opacity;\n    #endif // VV_OPACITY\n\n    #ifdef VV_COLOR\n       // we don\'t want to override the halo color\n       v_color \x3d halo * a_color + (1.0 - halo) * getVVColor(a_vv.y, a_color);\n    #else\n        v_color \x3d a_color;\n    #endif // VV_COLOR\n\n  #ifdef ID\n        v_id \x3d a_id;\n  #endif // ID\n      }\n    ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"textFS"\x3e\n    \x3c![CDATA[\n      precision lowp float;\n\n      uniform lowp sampler2D u_texture;\n\n      varying mediump vec4 v_color;\n      varying mediump float v_antialiasingWidth;\n      varying mediump float v_edgeDistanceOffset;\n      varying mediump vec2 v_tex;\n      varying lowp float v_transparency;\n\n  #ifdef ID\n      varying highp vec4 v_id;\n  #endif // ID\n\n      void main()\n      {\n        // read the distance from the SDF texture\n        lowp float dist \x3d texture2D(u_texture, v_tex).a;\n\n        // the edge distance if a factor of the outline width\n        float glyphEdgeDistance \x3d 0.75 - v_edgeDistanceOffset;\n\n        // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n        lowp float alpha \x3d smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n        gl_FragColor \x3d alpha * v_color;\n\n  #ifdef ID\n        if (gl_FragColor.a \x3c 1.0 / 255.0) {\n          discard;\n        }\n        gl_FragColor \x3d v_id;\n  #endif // ID\n      }\n    ]]\x3e\n  \x3c/snippet\x3e\n\x3c/snippets\x3e\n'}});
define(["require","exports","dojo/text!./textShaders.xml","../../../../webgl/ShaderSnippets"],function(a,d,c,b){a=new b;b.parse(c,a);return a});