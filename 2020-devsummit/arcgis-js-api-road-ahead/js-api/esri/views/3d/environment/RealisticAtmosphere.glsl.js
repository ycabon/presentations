// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define("require exports ../../../core/tsSupport/makeTemplateObjectHelper ../../../core/tsSupport/generatorHelper ../../../core/tsSupport/awaiterHelper ../webgl-engine/core/shaderLibrary/util/ColorConversion.glsl ../webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl ../webgl-engine/core/shaderModules/interfaces ../webgl-engine/core/shaderModules/ShaderBuilder".split(" "),function(G,e,b,H,I,D,E,c,F){Object.defineProperty(e,"__esModule",{value:!0});e.build=function(d){var a=new F.ShaderBuilder;
a.attributes.add("position","vec3");a.attributes.add("uv0","vec2");a.varyings.add("worldRay","vec3");a.varyings.add("vtc","vec2");d.haze&&a.varyings.add("eyeDir","vec3");a.vertex.uniforms.add("halfSizeNearPlane","vec2").add("cameraUp","vec3").add("cameraRight","vec3").add("cameraDir","vec3").add("cameraCenterOffset","vec2");a.vertex.code.add(c.glsl(f||(f=b(["\n    void main(void) {\n      vec3 v3Pos \x3d position;\n      vtc \x3d uv0;\n      vec2 rayvtc \x3d uv0 - cameraCenterOffset;\n      ","\n      worldRay \x3d eyeDir.z * cameraDir + eyeDir.y * cameraUp + eyeDir.x * cameraRight;\n      gl_Position \x3d vec4(v3Pos, 1.0);\n    }\n  "],
["\n    void main(void) {\n      vec3 v3Pos \x3d position;\n      vtc \x3d uv0;\n      vec2 rayvtc \x3d uv0 - cameraCenterOffset;\n      ","\n      worldRay \x3d eyeDir.z * cameraDir + eyeDir.y * cameraUp + eyeDir.x * cameraRight;\n      gl_Position \x3d vec4(v3Pos, 1.0);\n    }\n  "])),d.haze?"eyeDir \x3d vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);":"vec3 eyeDir \x3d vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);"));a.fragment.uniforms.add("lightingMainDirection",
"vec3").add("invWavelength","vec3").add("invWavelengthScaled","vec3").add("radii","vec2").add("atmosphereParameters1","vec4").add("atmosphereParameters2","vec4").add("cameraPosition","vec3").add("nearFar","vec2").add("heightParameters","vec4");d.haze?a.fragment.uniforms.add("depthTex","sampler2D"):a.fragment.uniforms.add("atmosphereParameters3","vec3").add("innerFadeDistance","float").add("altitudeFade","float");a.include(E.RgbaFloatEncoding);a.include(D.ColorConversion,{stages:1});a.fragment.code.add(c.glsl(g||
(g=b(["\n  // Atmosphere\n  const float krESun \x3d 0.075;        // Kr * ESun \x3d 0.005 * 15.0\n  const float kmESun \x3d 0.015;        // Km * ESun \x3d 0.005 * 15\n\n  // The inner (planetary) radius\n  #define innerRadius radii[0]\n  // The outer (atmosphere) radius\n  #define outerRadius radii[1]\n\n  // Atmosphere parameters:\n\n  // shellScale:               1.0 / (outerRadius - innerRadius)\n  #define shellScale atmosphereParameters1.x\n\n  // shellDepth:               The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n  // scaleDepthBlue:           The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n  #define shellDepth vec2(atmosphereParameters1.y, atmosphereParameters2.y)\n\n  // scaleOverScaleDepth:      scale / shellDepth\n  // scaleOverScaleDepthBlue:  scale / scaleDepthBlue\n  #define scaleOverScaleDepth vec2(atmosphereParameters1.z, atmosphereParameters2.z)\n\n  // oneOverScaleDepth:        1.0 / shellDepth\n  // oneOverScaleDepthBlue;    1.0 / scaleDepthBlue\n  #define oneOverScaleDepth vec2(atmosphereParameters1.w, atmosphereParameters2.w)\n  "],
["\n  // Atmosphere\n  const float krESun \x3d 0.075;        // Kr * ESun \x3d 0.005 * 15.0\n  const float kmESun \x3d 0.015;        // Km * ESun \x3d 0.005 * 15\n\n  // The inner (planetary) radius\n  #define innerRadius radii[0]\n  // The outer (atmosphere) radius\n  #define outerRadius radii[1]\n\n  // Atmosphere parameters:\n\n  // shellScale:               1.0 / (outerRadius - innerRadius)\n  #define shellScale atmosphereParameters1.x\n\n  // shellDepth:               The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n  // scaleDepthBlue:           The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n  #define shellDepth vec2(atmosphereParameters1.y, atmosphereParameters2.y)\n\n  // scaleOverScaleDepth:      scale / shellDepth\n  // scaleOverScaleDepthBlue:  scale / scaleDepthBlue\n  #define scaleOverScaleDepth vec2(atmosphereParameters1.z, atmosphereParameters2.z)\n\n  // oneOverScaleDepth:        1.0 / shellDepth\n  // oneOverScaleDepthBlue;    1.0 / scaleDepthBlue\n  #define oneOverScaleDepth vec2(atmosphereParameters1.w, atmosphereParameters2.w)\n  "]))));
d.haze||a.fragment.code.add(c.glsl(h||(h=b(["\n      #define g atmosphereParameters2.x\n      #define gSq atmosphereParameters3.x\n      #define miePhaseCoefficients atmosphereParameters3.y\n      #define lowerAlphaBlendBound atmosphereParameters3.z\n    "],["\n      #define g atmosphereParameters2.x\n      #define gSq atmosphereParameters3.x\n      #define miePhaseCoefficients atmosphereParameters3.y\n      #define lowerAlphaBlendBound atmosphereParameters3.z\n    "]))));a.fragment.code.add(c.glsl(k||
(k=b(["\n  // The camera's current height\n  #define cameraHeight heightParameters[0]\n  // cameraHeight^2\n  #define cameraHeightSq heightParameters[1]\n  // cameraHeightSq - outerRadiusSq; // C \x3d ||o-c||^2 - r^2\n  #define C heightParameters[2]\n  // cameraHeightSq - (innerRadiusSq - 63756370000.0); // C \x3d ||o-c||^2 - r^2\n  #define CSur heightParameters[3]\n\n  ","\n    // Loop constants for integral approximation\n    const float samples \x3d 5.0;\n    const int maxSamples \x3d 5;\n\n    // ToneMapping operators\n    vec3 expTM(vec3 inputColor,float _exposure) {\n        return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n    }\n\n    // Approximation for inner integral based on a radii ratio of 10.25:10\n    float scale(float _cos) {\n      float x \x3d 1.0 - _cos;\n      return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n    }\n\n    void main() {\n      // Obtain ray from Camera\n      vec3 worldSpaceRay \x3d normalize(worldRay);\n\n      // Compute Atmosphere intersection; i.e. ray/sphere intersection\n      float B \x3d 2.0 * dot(cameraPosition, worldSpaceRay); // B \x3d 2(l * (o-c))\n      float det \x3d B * B - 4.0 * C; // det \x3d B^2 - 4.0* C\n\n      // idealized sphere intersection to discard early some pixels\n      float detSur \x3d B * B - 4.0 * CSur; // det \x3d B^2 - 4.0* C\n\n      // the minimal sample start position:\n      // at the camera by default, on the earth radius surface if the camera is underground.\n      float minRayStart \x3d 0.0;\n  "],
["\n  // The camera's current height\n  #define cameraHeight heightParameters[0]\n  // cameraHeight^2\n  #define cameraHeightSq heightParameters[1]\n  // cameraHeightSq - outerRadiusSq; // C \x3d ||o-c||^2 - r^2\n  #define C heightParameters[2]\n  // cameraHeightSq - (innerRadiusSq - 63756370000.0); // C \x3d ||o-c||^2 - r^2\n  #define CSur heightParameters[3]\n\n  ","\n    // Loop constants for integral approximation\n    const float samples \x3d 5.0;\n    const int maxSamples \x3d 5;\n\n    // ToneMapping operators\n    vec3 expTM(vec3 inputColor,float _exposure) {\n        return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n    }\n\n    // Approximation for inner integral based on a radii ratio of 10.25:10\n    float scale(float _cos) {\n      float x \x3d 1.0 - _cos;\n      return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n    }\n\n    void main() {\n      // Obtain ray from Camera\n      vec3 worldSpaceRay \x3d normalize(worldRay);\n\n      // Compute Atmosphere intersection; i.e. ray/sphere intersection\n      float B \x3d 2.0 * dot(cameraPosition, worldSpaceRay); // B \x3d 2(l * (o-c))\n      float det \x3d B * B - 4.0 * C; // det \x3d B^2 - 4.0* C\n\n      // idealized sphere intersection to discard early some pixels\n      float detSur \x3d B * B - 4.0 * CSur; // det \x3d B^2 - 4.0* C\n\n      // the minimal sample start position:\n      // at the camera by default, on the earth radius surface if the camera is underground.\n      float minRayStart \x3d 0.0;\n  "])),
d.haze?"// Camera HDR\n        const float exposure \x3d 1.5;\n        const vec3 oneOverGamma \x3d vec3(1.0); //Gamma \x3d 1.0":"const float exposure \x3d 2.0;\n        const vec3 oneOverGamma \x3d vec3(0.454545); // Gamma \x3d 2.2\n        vec3 reinhardTM(vec3 inputColor, float _exposure) {\n          vec3 intermediate \x3d inputColor * _exposure;\n          intermediate /\x3d ( 1.0 + intermediate );\n          return pow(intermediate, oneOverGamma);\n        }\n        "));d.haze||a.fragment.code.add(c.glsl(l||
(l=b(["\n      float surfaceBlend \x3d 0.0;\n      vec4 surfaceColor \x3d vec4(0.0);\n      if (detSur \x3e\x3d 0.0) {\n        float nearSurface \x3d max(0.0, 0.5 *(-B - sqrt(detSur)));\n        float farSurface \x3d max(0.0, 0.5 *(-B + sqrt(detSur)));\n\n        if (nearSurface \x3d\x3d 0.0) {\n          minRayStart \x3d farSurface;\n        }\n\n        // Compute lighting at the point where the ray enters the earth surface\n        // Lighting computation is copied from the terrain shader.\n        vec3 vPos \x3d cameraPosition + worldSpaceRay * nearSurface;\n        float lightAngle \x3d dot(-lightingMainDirection, normalize(vPos));\n        float brightness \x3d max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\n\n        // Make the surface transparent based on altitude\n        surfaceColor \x3d vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\n\n        // Fade based on the distance the ray travels below the earth surface\n        float relDist \x3d (farSurface - nearSurface) / innerFadeDistance;\n\n        // early exit\n        if (relDist \x3e 1.0) {\n          gl_FragColor \x3d surfaceColor;\n          return;\n        }\n\n        surfaceBlend \x3d smoothstep(0.0, 1.0, relDist * relDist);\n      }\n    "],
["\n      float surfaceBlend \x3d 0.0;\n      vec4 surfaceColor \x3d vec4(0.0);\n      if (detSur \x3e\x3d 0.0) {\n        float nearSurface \x3d max(0.0, 0.5 *(-B - sqrt(detSur)));\n        float farSurface \x3d max(0.0, 0.5 *(-B + sqrt(detSur)));\n\n        if (nearSurface \x3d\x3d 0.0) {\n          minRayStart \x3d farSurface;\n        }\n\n        // Compute lighting at the point where the ray enters the earth surface\n        // Lighting computation is copied from the terrain shader.\n        vec3 vPos \x3d cameraPosition + worldSpaceRay * nearSurface;\n        float lightAngle \x3d dot(-lightingMainDirection, normalize(vPos));\n        float brightness \x3d max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\n\n        // Make the surface transparent based on altitude\n        surfaceColor \x3d vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\n\n        // Fade based on the distance the ray travels below the earth surface\n        float relDist \x3d (farSurface - nearSurface) / innerFadeDistance;\n\n        // early exit\n        if (relDist \x3e 1.0) {\n          gl_FragColor \x3d surfaceColor;\n          return;\n        }\n\n        surfaceBlend \x3d smoothstep(0.0, 1.0, relDist * relDist);\n      }\n    "]))));
a.fragment.code.add(c.glsl(m||(m=b(["\n    if (det \x3e\x3d 0.0) {\n    ","\n    float rayStart \x3d 0.5 *(-B - sqrt(det)); //near intersection with atmosphere\n    ","\n\n    float scatterDistance; // calculate its scattering offset\n    // Calculate the ray's starting position\n    if (rayStart \x3c minRayStart)\n    { // ray starts from camera or inner radius sphere to far\n      rayStart \x3d minRayStart;\n      ","\n    }\n    ","\n    // Initialize the scattering loop variables\n    vec3 start \x3d cameraPosition + worldSpaceRay * rayStart;\n  "],
["\n    if (det \x3e\x3d 0.0) {\n    ","\n    float rayStart \x3d 0.5 *(-B - sqrt(det)); //near intersection with atmosphere\n    ","\n\n    float scatterDistance; // calculate its scattering offset\n    // Calculate the ray's starting position\n    if (rayStart \x3c minRayStart)\n    { // ray starts from camera or inner radius sphere to far\n      rayStart \x3d minRayStart;\n      ","\n    }\n    ","\n    // Initialize the scattering loop variables\n    vec3 start \x3d cameraPosition + worldSpaceRay * rayStart;\n  "])),
d.haze?"\n          float depthSample \x3d texture2D(depthTex, vtc).r;\n\n          float zNear \x3d nearFar[0];\n          float zFar \x3d nearFar[1];\n\n          // http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\n          float zNorm \x3d 2.0 * depthSample - 1.0;\n          float linDepth \x3d 2.0 * zNear * zFar /\n            (zFar + zNear - zNorm * (zFar - zNear));\n\n          float rayEnd;\n          float altitudeAlpha \x3d 1.0;\n\n          // find intersections with ground, but only between the near and far\n          // clipping planes.\n          if (depthSample \x3c 1.0 \x26\x26 depthSample \x3e 0.0) {\n            vec3 cameraSpaceRay \x3d normalize(eyeDir);\n            cameraSpaceRay /\x3d cameraSpaceRay.z;\n            cameraSpaceRay *\x3d linDepth;\n\n            float cameraSpaceRayLength \x3d length(cameraSpaceRay);\n\n            vec3 world \x3d cameraPosition + worldSpaceRay * cameraSpaceRayLength;\n            float worldRadiusSq \x3d dot(world, world);\n\n            // Handle tall structures:\n            // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/5450\n            float transitionStart \x3d innerRadius + 20000.0;\n            float transitionHeight \x3d 25000.0;\n            float transitionEnd \x3d transitionStart + transitionHeight;\n\n            float edge0 \x3d transitionStart * transitionStart;\n            float edge1 \x3d transitionEnd * transitionEnd;\n\n            altitudeAlpha \x3d 1.0 - clamp((worldRadiusSq - edge0) / (edge1 - edge0), 0.0, 1.0);\n            rayEnd \x3d cameraSpaceRayLength;\n\n            if (altitudeAlpha \x3e 0.0 \x26\x26 detSur \x3e 0.0) {\n              float nearSurface \x3d 0.5 * ( -B - sqrt(detSur) );\n              float interp \x3d clamp(((cameraHeight - innerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\n              rayEnd \x3d mix(cameraSpaceRayLength, nearSurface, interp);\n            }\n          }":
"",d.haze?"float near \x3d abs(rayStart);\n        float far \x3d abs(rayEnd);":"float rayEnd \x3d 0.5 *(-B + sqrt(det)); //far intersection with atmosphere",d.haze?"":"// clamp to value at inner radius altitude\n          scatterDistance \x3d shellScale * min(0.0, innerRadius - cameraHeight);",d.haze?"":"else { // outside atmosphere\n          scatterDistance \x3d -1.0;\n        }"));d.haze&&a.fragment.code.add(c.glsl(n||(n=b(["\n      vec3 end \x3d cameraPosition + worldSpaceRay * rayEnd;\n\n      float endLength \x3d length(end);\n      //altitudeStart, altitudeEnd\n      vec2 altitudeInterval \x3d vec2(length(start) - innerRadius, endLength - innerRadius);\n\n      // for camera positions below altitude 0, invert the altitudes, to achieve\n      // a similar haze as above ground. Note that there is a small but visible change\n      // when the camera passes altitude 0.\n      if (altitudeInterval.x \x3c 0.0) {\n        altitudeInterval \x3d -altitudeInterval;\n      }\n\n      // computed for the original end point to get consistent light angles after possible inversions\n      float lightAngle \x3d dot(-lightingMainDirection, end) / endLength;\n\n      if (near \x3e far)\n      {\n        if (altitudeInterval.x \x3c altitudeInterval.y)\n        {\n          // Switch positive slopes for flipped rays\n          end \x3d cameraPosition + worldSpaceRay * rayStart;\n          start \x3d cameraPosition + worldSpaceRay * rayEnd;\n          worldSpaceRay *\x3d -1.0;\n          float tmp \x3d altitudeInterval.x;\n          altitudeInterval.x \x3d altitudeInterval.y;\n          altitudeInterval.y \x3d tmp;\n        }\n        else if (altitudeInterval.x \x3d\x3d altitudeInterval.y)\n        { // create minuscule fake slope for integration if the slope is zero\n          altitudeInterval.x +\x3d 1.0; //BUGFIX, if the height of camera and ground is equal the equation breaks, add fake meter to camera height to get\n          // slope for the camera function\n        }\n      }\n\n      // Calculate its scattering offset\n      // Assumes camera constrains of WSV 3.8\n      if (altitudeInterval.x \x3e outerRadius - innerRadius)\n      { // outside atmosphere\n        scatterDistance \x3d innerRadius - outerRadius;\n      } else\n      {\n        scatterDistance \x3d altitudeInterval.y - altitudeInterval.x;\n      }\n    "],
["\n      vec3 end \x3d cameraPosition + worldSpaceRay * rayEnd;\n\n      float endLength \x3d length(end);\n      //altitudeStart, altitudeEnd\n      vec2 altitudeInterval \x3d vec2(length(start) - innerRadius, endLength - innerRadius);\n\n      // for camera positions below altitude 0, invert the altitudes, to achieve\n      // a similar haze as above ground. Note that there is a small but visible change\n      // when the camera passes altitude 0.\n      if (altitudeInterval.x \x3c 0.0) {\n        altitudeInterval \x3d -altitudeInterval;\n      }\n\n      // computed for the original end point to get consistent light angles after possible inversions\n      float lightAngle \x3d dot(-lightingMainDirection, end) / endLength;\n\n      if (near \x3e far)\n      {\n        if (altitudeInterval.x \x3c altitudeInterval.y)\n        {\n          // Switch positive slopes for flipped rays\n          end \x3d cameraPosition + worldSpaceRay * rayStart;\n          start \x3d cameraPosition + worldSpaceRay * rayEnd;\n          worldSpaceRay *\x3d -1.0;\n          float tmp \x3d altitudeInterval.x;\n          altitudeInterval.x \x3d altitudeInterval.y;\n          altitudeInterval.y \x3d tmp;\n        }\n        else if (altitudeInterval.x \x3d\x3d altitudeInterval.y)\n        { // create minuscule fake slope for integration if the slope is zero\n          altitudeInterval.x +\x3d 1.0; //BUGFIX, if the height of camera and ground is equal the equation breaks, add fake meter to camera height to get\n          // slope for the camera function\n        }\n      }\n\n      // Calculate its scattering offset\n      // Assumes camera constrains of WSV 3.8\n      if (altitudeInterval.x \x3e outerRadius - innerRadius)\n      { // outside atmosphere\n        scatterDistance \x3d innerRadius - outerRadius;\n      } else\n      {\n        scatterDistance \x3d altitudeInterval.y - altitudeInterval.x;\n      }\n    "]))));
a.fragment.code.add(c.glsl(p||(p=b(["\n    vec2 opticalStartDepth \x3d exp(scatterDistance * oneOverScaleDepth);\n\n    float rayLength \x3d rayEnd - rayStart;\n    float sampleLength \x3d rayLength / samples;\n    float scaledLength \x3d sampleLength * shellScale;\n    vec3 sampleRay \x3d worldSpaceRay * sampleLength;\n    vec3 samplePoint \x3d start + sampleRay * 0.5;\n  "],["\n    vec2 opticalStartDepth \x3d exp(scatterDistance * oneOverScaleDepth);\n\n    float rayLength \x3d rayEnd - rayStart;\n    float sampleLength \x3d rayLength / samples;\n    float scaledLength \x3d sampleLength * shellScale;\n    vec3 sampleRay \x3d worldSpaceRay * sampleLength;\n    vec3 samplePoint \x3d start + sampleRay * 0.5;\n  "]))));
d.haze?a.fragment.code.add(c.glsl(q||(q=b(["\n      float cameraAngle \x3d dot(-worldSpaceRay, end) / length(end);\n      float scaleCameraAngle \x3d scale(cameraAngle);\n      vec2 cameraOffset \x3d scaleCameraAngle * opticalStartDepth;\n\n      float scaledValues \x3d scale(lightAngle) + scaleCameraAngle;\n      vec2 scaledValuesDepth \x3d scaledValues * shellDepth;\n    "],["\n      float cameraAngle \x3d dot(-worldSpaceRay, end) / length(end);\n      float scaleCameraAngle \x3d scale(cameraAngle);\n      vec2 cameraOffset \x3d scaleCameraAngle * opticalStartDepth;\n\n      float scaledValues \x3d scale(lightAngle) + scaleCameraAngle;\n      vec2 scaledValuesDepth \x3d scaledValues * shellDepth;\n    "])))):
a.fragment.code.add(c.glsl(r||(r=b(["\n      float cameraAngle \x3d dot(worldSpaceRay, start / length(start));\n      float angleMultiplier \x3d cameraAngle \x3e 0.0 ? cameraAngle : 0.0;\n\n      float scaleCameraAngle \x3d scale(cameraAngle);\n      vec2 cameraOffset \x3d scaleCameraAngle * opticalStartDepth * shellDepth;\n    "],["\n      float cameraAngle \x3d dot(worldSpaceRay, start / length(start));\n      float angleMultiplier \x3d cameraAngle \x3e 0.0 ? cameraAngle : 0.0;\n\n      float scaleCameraAngle \x3d scale(cameraAngle);\n      vec2 cameraOffset \x3d scaleCameraAngle * opticalStartDepth * shellDepth;\n    "]))));
a.fragment.code.add(c.glsl(t||(t=b(["\n    // Loop variables\n    vec3 frontColor \x3d vec3(0.0);\n    vec3 frontColorBlue \x3d vec3(0.0);\n    vec3 attenuate \x3d vec3(0.0);\n    vec3 attenuateBlue \x3d vec3(0.0);\n\n    // Now loop through the sample rays\n    for(int i\x3d0; i\x3cmaxSamples; i++) {\n      float height \x3d length(samplePoint);\n      float altitude \x3d abs(height - innerRadius);\n\n      vec2 depth \x3d exp(-altitude * scaleOverScaleDepth);\n  "],["\n    // Loop variables\n    vec3 frontColor \x3d vec3(0.0);\n    vec3 frontColorBlue \x3d vec3(0.0);\n    vec3 attenuate \x3d vec3(0.0);\n    vec3 attenuateBlue \x3d vec3(0.0);\n\n    // Now loop through the sample rays\n    for(int i\x3d0; i\x3cmaxSamples; i++) {\n      float height \x3d length(samplePoint);\n      float altitude \x3d abs(height - innerRadius);\n\n      vec2 depth \x3d exp(-altitude * scaleOverScaleDepth);\n  "]))));
d.haze?a.fragment.code.add(c.glsl(u||(u=b(["\n      vec2 scatter \x3d depth * scaledValuesDepth - cameraOffset;\n    "],["\n      vec2 scatter \x3d depth * scaledValuesDepth - cameraOffset;\n    "])))):a.fragment.code.add(c.glsl(v||(v=b(["\n      float lightAngle \x3d dot(-lightingMainDirection, samplePoint) / height;\n      float cameraAngle \x3d dot(worldSpaceRay, samplePoint) / height;\n      float tmpScaledValues \x3d scale(lightAngle) - scale(cameraAngle);\n      vec2 scatter \x3d cameraOffset + tmpScaledValues * depth * shellDepth;\n    "],
["\n      float lightAngle \x3d dot(-lightingMainDirection, samplePoint) / height;\n      float cameraAngle \x3d dot(worldSpaceRay, samplePoint) / height;\n      float tmpScaledValues \x3d scale(lightAngle) - scale(cameraAngle);\n      vec2 scatter \x3d cameraOffset + tmpScaledValues * depth * shellDepth;\n    "]))));a.fragment.code.add(c.glsl(w||(w=b(["\n      attenuate \x3d exp(-scatter.x * invWavelengthScaled);\n      attenuateBlue \x3d exp(-scatter.y * invWavelengthScaled);\n\n      frontColor +\x3d attenuate * depth.x;\n      frontColorBlue +\x3d attenuateBlue * depth.y;\n\n      samplePoint +\x3d sampleRay;\n    }\n\n    // Phase computation\n    // clamp to avoid numerical instability at fCos \x3d\x3d -1.0 (and close values) to display fake sun\n    float LdotR \x3d clamp(dot(-lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\n    float LdotRSq \x3d LdotR * LdotR + 1.0;\n  "],
["\n      attenuate \x3d exp(-scatter.x * invWavelengthScaled);\n      attenuateBlue \x3d exp(-scatter.y * invWavelengthScaled);\n\n      frontColor +\x3d attenuate * depth.x;\n      frontColorBlue +\x3d attenuateBlue * depth.y;\n\n      samplePoint +\x3d sampleRay;\n    }\n\n    // Phase computation\n    // clamp to avoid numerical instability at fCos \x3d\x3d -1.0 (and close values) to display fake sun\n    float LdotR \x3d clamp(dot(-lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\n    float LdotRSq \x3d LdotR * LdotR + 1.0;\n  "]))));
d.haze?a.fragment.code.add(c.glsl(x||(x=b(["\n      // Finally, scale the Rayleigh colors and set up the varying variables for the pixel shader\n      vec3 colorCoefficients \x3d (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\n\n      // Scaled Length is only applied afterwards to save multiplications\n      vec3 color \x3d colorCoefficients * frontColor;\n      vec3 colorBlue \x3d colorCoefficients * frontColorBlue;\n    "],["\n      // Finally, scale the Rayleigh colors and set up the varying variables for the pixel shader\n      vec3 colorCoefficients \x3d (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\n\n      // Scaled Length is only applied afterwards to save multiplications\n      vec3 color \x3d colorCoefficients * frontColor;\n      vec3 colorBlue \x3d colorCoefficients * frontColorBlue;\n    "])))):
a.fragment.code.add(c.glsl(y||(y=b(["\n      vec3 rayleighCoefficients \x3d (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\n      float mieCoefficients \x3d scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\n\n      // Calculate the attenuation factor for the ground\n      vec3 color \x3d rayleighCoefficients * frontColor + mieCoefficients * frontColor;\n      vec3 colorBlue \x3d rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;\n    "],
["\n      vec3 rayleighCoefficients \x3d (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\n      float mieCoefficients \x3d scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\n\n      // Calculate the attenuation factor for the ground\n      vec3 color \x3d rayleighCoefficients * frontColor + mieCoefficients * frontColor;\n      vec3 colorBlue \x3d rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;\n    "]))));a.fragment.code.add(c.glsl(z||
(z=b(["\n    // HDR to LDR conversion\n    vec3 ldrBlue \x3d expTM(colorBlue, 2.0 * exposure);\n    vec3 ldrRed \x3d expTM(color, exposure);\n\n    // mix reddish and blueish atmosphere\n    vec3 LDR \x3d mix(ldrBlue, ldrRed, 0.2);\n  "],["\n    // HDR to LDR conversion\n    vec3 ldrBlue \x3d expTM(colorBlue, 2.0 * exposure);\n    vec3 ldrRed \x3d expTM(color, exposure);\n\n    // mix reddish and blueish atmosphere\n    vec3 LDR \x3d mix(ldrBlue, ldrRed, 0.2);\n  "]))));d.haze?a.fragment.code.add(c.glsl(A||
(A=b(["\n      LDR *\x3d (1.0 - cameraAngle);\n      vec3 hsv \x3d rgb2hsv(LDR);\n      hsv.y \x3d clamp(hsv.y * 1.5, 0.0, 1.0); // boost haze saturation by 50%\n      LDR \x3d hsv2rgb(hsv);\n      vec3 finalColor \x3d LDR;\n      // when rendering we specify the blend functions such that\n      // newDestColor \x3d oldDestColor*(1.0-finalColor) + finalColor\n    "],["\n      LDR *\x3d (1.0 - cameraAngle);\n      vec3 hsv \x3d rgb2hsv(LDR);\n      hsv.y \x3d clamp(hsv.y * 1.5, 0.0, 1.0); // boost haze saturation by 50%\n      LDR \x3d hsv2rgb(hsv);\n      vec3 finalColor \x3d LDR;\n      // when rendering we specify the blend functions such that\n      // newDestColor \x3d oldDestColor*(1.0-finalColor) + finalColor\n    "])))):
a.fragment.code.add(c.glsl(B||(B=b(["\n      // reinhard tonemapper for looking upwards\n      vec3 ldrReinhard \x3d reinhardTM(color, exposure);\n      LDR +\x3d angleMultiplier * ldrReinhard;\n\n      // height dependent parameter to smooth out reddish atmosphere\n      float side \x3d (rayEnd + rayStart) * 0.5;\n      float atmoHeight \x3d sqrt(cameraHeightSq - side * side);\n      float h2 \x3d clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\n\n      vec3 finalColor \x3d LDR * h2;\n      vec3 hsv \x3d rgb2hsv(finalColor);\n      hsv.y \x3d clamp(hsv.y * 1.5, 0.0, 1.0); // boost sky saturation by 50%\n      finalColor \x3d hsv2rgb(hsv);\n    "],
["\n      // reinhard tonemapper for looking upwards\n      vec3 ldrReinhard \x3d reinhardTM(color, exposure);\n      LDR +\x3d angleMultiplier * ldrReinhard;\n\n      // height dependent parameter to smooth out reddish atmosphere\n      float side \x3d (rayEnd + rayStart) * 0.5;\n      float atmoHeight \x3d sqrt(cameraHeightSq - side * side);\n      float h2 \x3d clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\n\n      vec3 finalColor \x3d LDR * h2;\n      vec3 hsv \x3d rgb2hsv(finalColor);\n      hsv.y \x3d clamp(hsv.y * 1.5, 0.0, 1.0); // boost sky saturation by 50%\n      finalColor \x3d hsv2rgb(hsv);\n    "]))));
a.fragment.code.add(c.glsl(C||(C=b(["\n    ","\n      } else { // Outside Atmosphere\n        gl_FragColor \x3d vec4(0.0);\n      }\n    }\n  "],["\n    ","\n      } else { // Outside Atmosphere\n        gl_FragColor \x3d vec4(0.0);\n      }\n    }\n  "])),d.haze?"gl_FragColor \x3d vec4(finalColor, 1.0) * altitudeAlpha;":"float atmosStrength \x3d clamp((length(ldrRed) - 0.05) * 1.05, 0.0, 1.0);\n          gl_FragColor \x3d vec4(finalColor, atmosStrength * clamp(1.0 - ( atmoHeight - innerRadius ) / (outerRadius - innerRadius), 0.0, 1.0));\n          if (surfaceBlend \x3e 0.0) {\n            gl_FragColor \x3d mix(gl_FragColor, surfaceColor, surfaceBlend);\n          }"));
return a};var f,g,h,k,l,m,n,p,q,r,t,u,v,w,x,y,z,A,B,C});