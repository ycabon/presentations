// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define("require exports ../../../../../../../core/tsSupport/makeTemplateObjectHelper ../../../../../support/earthUtils ./ComponentData.glsl ./VertexDiscardByOpacity.glsl ../../../../core/shaderLibrary/ForwardLinearDepth.glsl ../../../../core/shaderLibrary/Slice.glsl ../../../../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../../../../core/shaderLibrary/attributes/VertexColor.glsl ../../../../core/shaderLibrary/attributes/VertexNormal.glsl ../../../../core/shaderLibrary/attributes/VertexPosition.glsl ../../../../core/shaderLibrary/output/OutputDepth.glsl ../../../../core/shaderLibrary/output/OutputHighlight.glsl ../../../../core/shaderLibrary/shading/ComputeMaterialColor.glsl ../../../../core/shaderLibrary/shading/ComputeNormalTexture.glsl ../../../../core/shaderLibrary/shading/ComputeShadingNormal.glsl ../../../../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../../../../core/shaderLibrary/shading/ReadBaseColorTexture.glsl ../../../../core/shaderLibrary/shading/ReadShadowMap.glsl ../../../../core/shaderLibrary/util/AlphaDiscard.glsl ../../../../core/shaderModules/interfaces ../../../../core/shaderModules/ShaderBuilder ../../../../shaders/Overlay.glsl".split(" "),
function(ea,e,d,L,M,N,O,P,Q,R,S,T,U,V,W,X,f,Y,Z,aa,ba,g,c,ca,da){Object.defineProperty(e,"__esModule",{value:!0});e.attributeLocations={position:0,normal:1,normalCompressed:1,color:2,uv0:3,uvRegion:4,componentIndex:5};e.build=function(a){var b=new ca.ShaderBuilder;b.include(T.VertexPosition,a);b.include(S.VertexNormal,a);b.include(R.VertexColor,a);b.include(Q.TextureCoordinateAttribute,a);b.include(O.ForwardLinearDepth,a);b.include(M.ComponentData,a);b.include(g.DiscardOrAdjustAlpha,a);b.include(P.Slice,
a);b.include(aa.ReadBaseColorTexture,a);b.include(N.VertexDiscardByOpacity,a);if(1===a.pbrMode||2===a.pbrMode)b.include(Z.PhysicallyBasedRenderingParameters,a),b.include(X.ComputeNormalTexture,a);3===a.output&&1===a.componentData?b.vertex.code.add(c.glsl(h||(h=d(["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "],["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "])))):
b.vertex.code.add(c.glsl(k||(k=d(["\n      #define discardShadows(castShadows) {}\n    "],["\n      #define discardShadows(castShadows) {}\n    "]))));a.overlayEnabled&&(b.include(da.Overlay,a),0===a.viewingMode?b.vertex.code.add(c.glsl(l||(l=d(["\n      const float invEarthRadius \x3d ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "],["\n      const float invEarthRadius \x3d ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "])),
c.glsl.float(1/L.earthRadius))):b.vertex.code.add(c.glsl(m||(m=d(["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "],["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "])))));b.vertex.code.add(c.glsl(n||(n=d(["\n    void main() {\n      bool castShadows;\n      vec4 externalColor \x3d forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a \x3c ",") {\n        // Discard this vertex\n        gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      ",
"\n      forwardPosition();\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "],["\n    void main() {\n      bool castShadows;\n      vec4 externalColor \x3d forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a \x3c ",") {\n        // Discard this vertex\n        gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      ",
"\n      forwardPosition();\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "])),c.glsl.float(g.symbolAlphaCutoff),a.overlayEnabled?"setOverlayVTC(projectOverlay(position));":""));0===a.output&&(b.include(W.ComputeMaterialColor,a),b.include(f.ComputeShadingNormal,a),b.include(Y.EvaluateSceneLighting,a),a.receiveShadows?(b.include(ba.ReadShadowMap,a),b.fragment.code.add(c.glsl(p||(p=d(["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "],
["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "]))))):b.fragment.code.add(c.glsl(q||(q=d(["\n        float evaluateShadow() { return 0.0; }\n      "],["\n        float evaluateShadow() { return 0.0; }\n      "])))),b.fragment.code.add(c.glsl(r||(r=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor \x3d computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ",
"\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor \x3d computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ","\n    "])),a.overlayEnabled?
c.glsl(t||(t=d(["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n        materialColor \x3d materialColor * (1.0 - overlayColor.a) + overlayColor;"],["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n        materialColor \x3d materialColor * (1.0 - overlayColor.a) + overlayColor;"]))):"")),1===a.pbrMode||2===a.pbrMode?(b.fragment.code.add(c.glsl(u||(u=d(["\n        ","\n        vec3 normalVertex \x3d shadingNormalWorld();\n        float additionalIrradiance \x3d 0.02 * lightingMainIntensity[2];\n      "],
["\n        ","\n        vec3 normalVertex \x3d shadingNormalWorld();\n        float additionalIrradiance \x3d 0.02 * lightingMainIntensity[2];\n      "])),1===a.pbrMode?c.glsl(v||(v=d(["\n        applyPBRFactors();\n        if (int(externalColorMixMode) \x3d\x3d 3) {\n          mrr \x3d vec3(0.0, 0.6, 0.2);\n        }"],["\n        applyPBRFactors();\n        if (int(externalColorMixMode) \x3d\x3d 3) {\n          mrr \x3d vec3(0.0, 0.6, 0.2);\n        }"]))):"")),a.hasNormalTexture?b.fragment.code.add(c.glsl(w||
(w=d(["\n        mat3 tangentSpace \x3d computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n        "],["\n        mat3 tangentSpace \x3d computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n        "])))):b.fragment.code.add(c.glsl(x||(x=d(["\n        vec3 shadingNormal \x3d normalVertex;\n        "],["\n        vec3 shadingNormal \x3d normalVertex;\n        "])))),
b.fragment.code.add(c.glsl(y||(y=d(["","\n      "],["","\n      "])),0===a.viewingMode?c.glsl(z||(z=d(["vec3 normalGround \x3d normalize(positionWorld());"],["vec3 normalGround \x3d normalize(positionWorld());"]))):c.glsl(A||(A=d(["vec3 normalGround \x3d vec3(0.0, 0.0, 1.0);"],["vec3 normalGround \x3d vec3(0.0, 0.0, 1.0);"]))))),b.fragment.code.add(c.glsl(B||(B=d(["\n        vec3 viewDir \x3d normalize(vPositionWorldCameraRelative);\n        float ssao \x3d 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight \x3d evaluateAdditionalLighting(ssao, positionWorld());\n        vec3 shadedColor \x3d evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance);\n        "],
["\n        vec3 viewDir \x3d normalize(vPositionWorldCameraRelative);\n        float ssao \x3d 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight \x3d evaluateAdditionalLighting(ssao, positionWorld());\n        vec3 shadedColor \x3d evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance);\n        "]))))):(a.receiveShadows?b.fragment.code.add(c.glsl(C||(C=d(["\n      float shadow \x3d evaluateShadow();\n        "],
["\n      float shadow \x3d evaluateShadow();\n        "])))):0===a.viewingMode?b.fragment.code.add(c.glsl(D||(D=d(["\n      float additionalAmbientScale \x3d _oldHeuristicLighting(positionWorld());\n      float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "],["\n      float additionalAmbientScale \x3d _oldHeuristicLighting(positionWorld());\n      float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "])))):b.fragment.code.add(c.glsl(E||
(E=d(["\n      float shadow \x3d 0.0;\n      "],["\n      float shadow \x3d 0.0;\n      "])))),b.fragment.code.add(c.glsl(F||(F=d(["\n      float ambientOcclusion \x3d evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight \x3d evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec3 shadedColor \x3d evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight);\n      "],
["\n      float ambientOcclusion \x3d evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight \x3d evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec3 shadedColor \x3d evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight);\n      "]))))),b.fragment.code.add(c.glsl(G||(G=d(["\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, materialColor.a), vPositionWorldCameraRelative);\n      }\n    "],
["\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, materialColor.a), vPositionWorldCameraRelative);\n      }\n    "])))));if(1===a.output||3===a.output)b.include(U.OutputDepth,a),b.fragment.code.add(c.glsl(H||(H=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "]))));
2===a.output&&(b.include(f.ComputeShadingNormal,a),b.fragment.code.add(c.glsl(I||(I=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha \x3d ",";\n        gl_FragColor \x3d vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "],
["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha \x3d ",";\n        gl_FragColor \x3d vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "])),2===a.normalType?"0.0":"1.0")));4===
a.output&&(b.include(V.OutputHighlight),b.fragment.code.add(c.glsl(J||(J=d(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ","\n\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ",
"\n\n        outputHighlight();\n      }\n    "])),a.overlayEnabled?c.glsl(K||(K=d(["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n\n        if (overlayColor.a \x3d\x3d 0.0) {\n          gl_FragColor \x3d vec4(0.0);\n          return;\n        }"],["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n\n        if (overlayColor.a \x3d\x3d 0.0) {\n          gl_FragColor \x3d vec4(0.0);\n          return;\n        }"]))):"")));return b};var h,k,l,m,n,p,q,t,r,v,u,w,x,z,A,y,B,C,
D,E,F,G,H,I,K,J});