// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define("require exports ../../../../../core/tsSupport/makeTemplateObjectHelper ../../../../../core/maybe ../../../../../core/libs/gl-matrix-2/vec3 ../../../../../core/libs/gl-matrix-2/vec3f64 ../shaderModules/interfaces".split(" "),function(v,g,d,t,u,h,f){function k(a,e){if(e.slicePlaneEnabled){a.extensions.add("GL_OES_standard_derivatives");e.sliceEnabledForVertexPrograms&&(a.vertex.uniforms.add("slicePlaneOrigin","vec3"),a.vertex.uniforms.add("slicePlaneBasis1","vec3"),a.vertex.uniforms.add("slicePlaneBasis2",
"vec3"));a.fragment.uniforms.add("slicePlaneOrigin","vec3");a.fragment.uniforms.add("slicePlaneBasis1","vec3");a.fragment.uniforms.add("slicePlaneBasis2","vec3");var c=f.glsl(l||(l=d(["\n      struct SliceFactors {\n        float front;\n        float side0;\n        float side1;\n        float side2;\n        float side3;\n      };\n\n      SliceFactors calculateSliceFactors(vec3 pos) {\n        vec3 rel \x3d pos - slicePlaneOrigin;\n\n        vec3 slicePlaneNormal \x3d -cross(slicePlaneBasis1, slicePlaneBasis2);\n        float slicePlaneW \x3d -dot(slicePlaneNormal, slicePlaneOrigin);\n\n        float basis1Len2 \x3d dot(slicePlaneBasis1, slicePlaneBasis1);\n        float basis2Len2 \x3d dot(slicePlaneBasis2, slicePlaneBasis2);\n\n        float basis1Dot \x3d dot(slicePlaneBasis1, rel);\n        float basis2Dot \x3d dot(slicePlaneBasis2, rel);\n\n        return SliceFactors(\n          dot(slicePlaneNormal, pos) + slicePlaneW,\n          -basis1Dot - basis1Len2,\n          basis1Dot - basis1Len2,\n          -basis2Dot - basis2Len2,\n          basis2Dot - basis2Len2\n        );\n      }\n\n      bool sliceByFactors(SliceFactors factors) {\n        return factors.front \x3c 0.0\n          \x26\x26 factors.side0 \x3c 0.0\n          \x26\x26 factors.side1 \x3c 0.0\n          \x26\x26 factors.side2 \x3c 0.0\n          \x26\x26 factors.side3 \x3c 0.0;\n      }\n      \n      bool sliceEnabled() {\n        // a slicePlaneBasis1 vector of zero length is used to disable slicing in the shader during draped rendering.\n        return dot(slicePlaneBasis1, slicePlaneBasis1) !\x3d 0.0;\n      }\n\n      bool sliceByPlane(vec3 pos) {\n        return sliceEnabled() \x26\x26 sliceByFactors(calculateSliceFactors(pos));\n      }\n\n      #define rejectBySlice(_pos_) sliceByPlane(_pos_)\n      #define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n    "],
["\n      struct SliceFactors {\n        float front;\n        float side0;\n        float side1;\n        float side2;\n        float side3;\n      };\n\n      SliceFactors calculateSliceFactors(vec3 pos) {\n        vec3 rel \x3d pos - slicePlaneOrigin;\n\n        vec3 slicePlaneNormal \x3d -cross(slicePlaneBasis1, slicePlaneBasis2);\n        float slicePlaneW \x3d -dot(slicePlaneNormal, slicePlaneOrigin);\n\n        float basis1Len2 \x3d dot(slicePlaneBasis1, slicePlaneBasis1);\n        float basis2Len2 \x3d dot(slicePlaneBasis2, slicePlaneBasis2);\n\n        float basis1Dot \x3d dot(slicePlaneBasis1, rel);\n        float basis2Dot \x3d dot(slicePlaneBasis2, rel);\n\n        return SliceFactors(\n          dot(slicePlaneNormal, pos) + slicePlaneW,\n          -basis1Dot - basis1Len2,\n          basis1Dot - basis1Len2,\n          -basis2Dot - basis2Len2,\n          basis2Dot - basis2Len2\n        );\n      }\n\n      bool sliceByFactors(SliceFactors factors) {\n        return factors.front \x3c 0.0\n          \x26\x26 factors.side0 \x3c 0.0\n          \x26\x26 factors.side1 \x3c 0.0\n          \x26\x26 factors.side2 \x3c 0.0\n          \x26\x26 factors.side3 \x3c 0.0;\n      }\n      \n      bool sliceEnabled() {\n        // a slicePlaneBasis1 vector of zero length is used to disable slicing in the shader during draped rendering.\n        return dot(slicePlaneBasis1, slicePlaneBasis1) !\x3d 0.0;\n      }\n\n      bool sliceByPlane(vec3 pos) {\n        return sliceEnabled() \x26\x26 sliceByFactors(calculateSliceFactors(pos));\n      }\n\n      #define rejectBySlice(_pos_) sliceByPlane(_pos_)\n      #define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n    "]))),
b=f.glsl(m||(m=d(["\n      vec4 applySliceHighlight(vec4 color, vec3 pos) {\n        SliceFactors factors \x3d calculateSliceFactors(pos);\n\n        if (sliceByFactors(factors)) {\n          return color;\n        }\n\n        const float HIGHLIGHT_WIDTH \x3d 1.0;\n        const vec4 HIGHLIGHT_COLOR \x3d vec4(0.0, 0.0, 0.0, 0.3);\n\n        factors.front /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n        factors.side0 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n        factors.side1 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n        factors.side2 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n        factors.side3 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n\n        float highlightFactor \x3d (1.0 - step(0.5, factors.front))\n          * (1.0 - step(0.5, factors.side0))\n          * (1.0 - step(0.5, factors.side1))\n          * (1.0 - step(0.5, factors.side2))\n          * (1.0 - step(0.5, factors.side3));\n\n        return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n      }\n    "],
["\n      vec4 applySliceHighlight(vec4 color, vec3 pos) {\n        SliceFactors factors \x3d calculateSliceFactors(pos);\n\n        if (sliceByFactors(factors)) {\n          return color;\n        }\n\n        const float HIGHLIGHT_WIDTH \x3d 1.0;\n        const vec4 HIGHLIGHT_COLOR \x3d vec4(0.0, 0.0, 0.0, 0.3);\n\n        factors.front /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n        factors.side0 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n        factors.side1 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n        factors.side2 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n        factors.side3 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n\n        float highlightFactor \x3d (1.0 - step(0.5, factors.front))\n          * (1.0 - step(0.5, factors.side0))\n          * (1.0 - step(0.5, factors.side1))\n          * (1.0 - step(0.5, factors.side2))\n          * (1.0 - step(0.5, factors.side3));\n\n        return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n      }\n    "]))),
b=e.sliceHighlightDisabled?f.glsl(n||(n=d(["#define highlightSlice(_color_, _pos_) (_color_)"],["#define highlightSlice(_color_, _pos_) (_color_)"]))):f.glsl(p||(p=d(["\n        "," \n        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))\n      "],["\n        "," \n        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))\n      "])),b);e.sliceEnabledForVertexPrograms&&a.vertex.code.add(c);
a.fragment.code.add(c);a.fragment.code.add(b)}else c=f.glsl(q||(q=d(["\n      #define rejectBySlice(_pos_) false\n      #define discardBySlice(_pos_) {}\n      #define highlightSlice(_color_, _pos_) (_color_)\n    "],["\n      #define rejectBySlice(_pos_) false\n      #define discardBySlice(_pos_) {}\n      #define highlightSlice(_color_, _pos_) (_color_)\n    "]))),e.sliceEnabledForVertexPrograms&&a.vertex.code.add(c),a.fragment.code.add(c)}Object.defineProperty(g,"__esModule",{value:!0});g.Slice=
k;(function(a){a.bindUniformsWithOrigin=function(e,c,b){a.bindUniforms(e,c,b.slicePlane,b.origin)};a.bindUniforms=function(a,c,b,d){c.slicePlaneEnabled&&(t.isSome(b)?(d?(u.vec3.subtract(r,b.origin,d),a.setUniform3fv("slicePlaneOrigin",r)):a.setUniform3fv("slicePlaneOrigin",b.origin),a.setUniform3fv("slicePlaneBasis1",b.basis1),a.setUniform3fv("slicePlaneBasis2",b.basis2)):(a.setUniform3fv("slicePlaneBasis1",h.vec3f64.ZEROS),a.setUniform3fv("slicePlaneBasis2",h.vec3f64.ZEROS),a.setUniform3fv("slicePlaneOrigin",
h.vec3f64.ZEROS)))}})(k=g.Slice||(g.Slice={}));var r=h.vec3f64.create(),l,m,n,p,q});