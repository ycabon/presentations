// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../../../core/tsSupport/makeTemplateObjectHelper","../../shaderModules/interfaces"],function(f,b,d,e){Object.defineProperty(b,"__esModule",{value:!0});b.TextureAtlasLookup=function(a){a.extensions.add("GL_EXT_shader_texture_lod");a.extensions.add("GL_OES_standard_derivatives");a.fragment.code.add(e.glsl(c||(c=d(["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale \x3d atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas \x3d fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx \x3d dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy \x3d dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto \x3d dFdx(uvAtlas);\n        vec2 dUVdyAuto \x3d dFdy(uvAtlas);\n        float mipMapLevel \x3d calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "],
["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale \x3d atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas \x3d fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx \x3d dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy \x3d dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto \x3d dFdx(uvAtlas);\n        vec2 dUVdyAuto \x3d dFdy(uvAtlas);\n        float mipMapLevel \x3d calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "]))))};
var c});