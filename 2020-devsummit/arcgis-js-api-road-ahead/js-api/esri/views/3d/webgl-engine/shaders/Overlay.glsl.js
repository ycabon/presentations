// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/shading/Water.glsl","../core/shaderModules/interfaces"],function(m,e,b,l,c){Object.defineProperty(e,"__esModule",{value:!0});e.Overlay=function(a,d){3===d.pbrMode&&a.include(l.Water,d);a.vertex.uniforms.add("overlayTexOffset","vec4");a.vertex.uniforms.add("overlayTexScale","vec4");a.varyings.add("vtcOverlay","vec4");a.vertex.code.add(c.glsl(f||(f=b(["\n    void setOverlayVTC(in vec2 uv) {\n      vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n    }\n  "],
["\n    void setOverlayVTC(in vec2 uv) {\n      vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n    }\n  "]))));a.fragment.uniforms.add("ovInnerColorTex","sampler2D");a.fragment.uniforms.add("ovOuterColorTex","sampler2D");a.fragment.uniforms.add("overlayOpacity","float");a.fragment.code.add(c.glsl(g||(g=b(["\n    vec4 getOverlayColor(sampler2D ov0Tex, sampler2D ov1Tex, vec4 texCoords) {\n      vec4 color \x3d vec4(0.0);\n\n      // read textures outside of conditions, to avoid artifacts likely related to non-uniform flow control:\n      // - https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Non-uniform_flow_control\n      // - https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13657\n      vec4 color0 \x3d texture2D(ov0Tex, texCoords.xy);\n      vec4 color1 \x3d texture2D(ov1Tex, texCoords.zw);\n\n      if ((texCoords.x \x3e\x3d 0.0) \x26\x26 (texCoords.x \x3c\x3d 1.0) \x26\x26 (texCoords.y \x3e\x3d 0.0) \x26\x26 (texCoords.y \x3c\x3d 1.0)) {\n        color \x3d color0;\n      } else if ((texCoords.z \x3e\x3d 0.0) \x26\x26 (texCoords.z \x3c\x3d 1.0) \x26\x26 (texCoords.w \x3e\x3d 0.0) \x26\x26 (texCoords.w \x3c\x3d 1.0)) {\n        color \x3d color1;\n      }\n\n      return color;\n    }\n  "],
["\n    vec4 getOverlayColor(sampler2D ov0Tex, sampler2D ov1Tex, vec4 texCoords) {\n      vec4 color \x3d vec4(0.0);\n\n      // read textures outside of conditions, to avoid artifacts likely related to non-uniform flow control:\n      // - https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Non-uniform_flow_control\n      // - https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13657\n      vec4 color0 \x3d texture2D(ov0Tex, texCoords.xy);\n      vec4 color1 \x3d texture2D(ov1Tex, texCoords.zw);\n\n      if ((texCoords.x \x3e\x3d 0.0) \x26\x26 (texCoords.x \x3c\x3d 1.0) \x26\x26 (texCoords.y \x3e\x3d 0.0) \x26\x26 (texCoords.y \x3c\x3d 1.0)) {\n        color \x3d color0;\n      } else if ((texCoords.z \x3e\x3d 0.0) \x26\x26 (texCoords.z \x3c\x3d 1.0) \x26\x26 (texCoords.w \x3e\x3d 0.0) \x26\x26 (texCoords.w \x3c\x3d 1.0)) {\n        color \x3d color1;\n      }\n\n      return color;\n    }\n  "]))));
a.fragment.code.add(c.glsl(h||(h=b(["\n    vec4 getCombinedOverlayColor() {\n      return overlayOpacity * getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n    }\n  "],["\n    vec4 getCombinedOverlayColor() {\n      return overlayOpacity * getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n    }\n  "]))));3===d.pbrMode&&a.fragment.code.add(c.glsl(k||(k=b(["\n    vec4 getOverlayWaterColor( in vec4 tileColor, vec4 maskInput, vec4 colorInput,\n                        vec3 vpos, float shadow, vec3 localUp, vec3 eye, mat3 tbn) {\n\n      // reproject normal from 0...1 \x3d\x3e -1...1\n      // and project it to worldspace.\n      vec3 n \x3d normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));\n      vec3 v \x3d -normalize(vpos - eye);\n      vec3 l \x3d normalize(-lightingMainDirection);\n      vec3 final \x3d getSeaColor(n, v, l, colorInput.rgb, lightingMainIntensity, localUp, 1.0 - shadow);\n\n      // the terrain renderer assumes a premultiplied color output without gamma.\n      return vec4(final * colorInput.w, colorInput.w);\n    }\n    "],
["\n    vec4 getOverlayWaterColor( in vec4 tileColor, vec4 maskInput, vec4 colorInput,\n                        vec3 vpos, float shadow, vec3 localUp, vec3 eye, mat3 tbn) {\n\n      // reproject normal from 0...1 \x3d\x3e -1...1\n      // and project it to worldspace.\n      vec3 n \x3d normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));\n      vec3 v \x3d -normalize(vpos - eye);\n      vec3 l \x3d normalize(-lightingMainDirection);\n      vec3 final \x3d getSeaColor(n, v, l, colorInput.rgb, lightingMainIntensity, localUp, 1.0 - shadow);\n\n      // the terrain renderer assumes a premultiplied color output without gamma.\n      return vec4(final * colorInput.w, colorInput.w);\n    }\n    "]))))};
var f,g,h,k});