// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define("require exports ../../../../core/tsSupport/makeTemplateObjectHelper ../core/shaderLibrary/ScreenSpacePass ../core/shaderLibrary/output/ReadLinearDepth.glsl ../core/shaderLibrary/util/CameraSpace.glsl ../core/shaderModules/interfaces ../core/shaderModules/ShaderBuilder".split(" "),function(t,e,b,p,f,q,c,r){Object.defineProperty(e,"__esModule",{value:!0});e.build=function(d){var a=new r.ShaderBuilder;a.include(p.ScreenSpacePass);1===d.output&&(a.include(f.ReadLinearDepth),a.fragment.code.add(c.glsl(g||
(g=b([" \n      #ifndef RADIUS\n        #define RADIUS "],[" \n      #ifndef RADIUS\n        #define RADIUS "])))+d.radius+"\n      #endif\n    "),a.fragment.uniforms.add("normalMap","sampler2D").add("depthMap","sampler2D").add("tex","sampler2D").add("blurSize","vec2").add("g_BlurFalloff","float").add("projScale","float").add("nearFar","vec2").add("zScale","vec2"),a.fragment.code.add(c.glsl(h||(h=b(["\n      float blurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\n        float c \x3d texture2D(tex, uv).r;\n        float d \x3d linearDepth(depthMap, uv, nearFar);\n\n        float ddiff \x3d d - center_d;\n\n        float w \x3d exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n\n        w_total +\x3d w;\n\n        return w*c;\n      }\n\n      void main(void) {\n        float b \x3d 0.0;\n        float w_total \x3d 0.0;\n\n        float center_d \x3d linearDepth(depthMap, uv, nearFar);\n\n        float sharpness \x3d -0.05 * projScale/(center_d*zScale.x+zScale.y);\n        for (int r \x3d -RADIUS; r \x3c\x3d RADIUS; ++r) {\n          float rf \x3d float(r);\n          vec2 uvOffset \x3d uv + rf*blurSize;\n          b +\x3d blurFunction(uvOffset, rf, center_d, w_total, sharpness);\n        }\n\n        gl_FragColor \x3d vec4(b/w_total);\n      }\n    "],
["\n      float blurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\n        float c \x3d texture2D(tex, uv).r;\n        float d \x3d linearDepth(depthMap, uv, nearFar);\n\n        float ddiff \x3d d - center_d;\n\n        float w \x3d exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n\n        w_total +\x3d w;\n\n        return w*c;\n      }\n\n      void main(void) {\n        float b \x3d 0.0;\n        float w_total \x3d 0.0;\n\n        float center_d \x3d linearDepth(depthMap, uv, nearFar);\n\n        float sharpness \x3d -0.05 * projScale/(center_d*zScale.x+zScale.y);\n        for (int r \x3d -RADIUS; r \x3c\x3d RADIUS; ++r) {\n          float rf \x3d float(r);\n          vec2 uvOffset \x3d uv + rf*blurSize;\n          b +\x3d blurFunction(uvOffset, rf, center_d, w_total, sharpness);\n        }\n\n        gl_FragColor \x3d vec4(b/w_total);\n      }\n    "])))));
0===d.output&&(a.include(f.ReadLinearDepth),a.include(q.CameraSpace),a.fragment.uniforms.add("projMatrixInv","mat4").add("normalMap","sampler2D").add("depthMap","sampler2D").add("intensity","float").add("projScale","float").add("radius","float").add("nearFar","vec2").add("screenDimensions","vec2").add("rnmScale","vec2").add("rnm","sampler2D"),a.fragment.code.add(c.glsl(k||(k=b([" \n      #ifndef SAMPLES\n        #define SAMPLES "],[" \n      #ifndef SAMPLES\n        #define SAMPLES "])))+d.samples+
"\n      #endif\n      uniform vec3 pSphere[SAMPLES]; //tap position\n    "),a.fragment.code.add(c.glsl(l||(l=b(["\n      float fallOffFunction(float vv, float vn, float bias) {\n        float radius2 \x3d radius * radius;\n\n        // A: From the HPG12 paper\n        // Note large epsilon to avoid overdarkening within cracks\n        // return float(vv \x3c radius2) * max((vn - bias) / (epsilon + vv), 0.0) * radius2 * 0.6;\n\n        // B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]\n        float f \x3d max(radius2 - vv, 0.0); return f * f * f * max(vn-bias, 0.0);\n\n        // C: Medium contrast (which looks better at high radii), no division.  Note that the\n        // contribution still falls off with radius^2, but we've adjusted the rate in a way that is\n        // more computationally efficient and happens to be aesthetically pleasing.\n        // return 4.0 * max(1.0 - vv * invRadius2, 0.0) * max(vn - bias, 0.0);\n\n        // D: Low contrast, no division operation\n        // return 2.0 * float(vv \x3c radius * radius) * max(vn - bias, 0.0);\n      }\n    "],
["\n      float fallOffFunction(float vv, float vn, float bias) {\n        float radius2 \x3d radius * radius;\n\n        // A: From the HPG12 paper\n        // Note large epsilon to avoid overdarkening within cracks\n        // return float(vv \x3c radius2) * max((vn - bias) / (epsilon + vv), 0.0) * radius2 * 0.6;\n\n        // B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]\n        float f \x3d max(radius2 - vv, 0.0); return f * f * f * max(vn-bias, 0.0);\n\n        // C: Medium contrast (which looks better at high radii), no division.  Note that the\n        // contribution still falls off with radius^2, but we've adjusted the rate in a way that is\n        // more computationally efficient and happens to be aesthetically pleasing.\n        // return 4.0 * max(1.0 - vv * invRadius2, 0.0) * max(vn - bias, 0.0);\n\n        // D: Low contrast, no division operation\n        // return 2.0 * float(vv \x3c radius * radius) * max(vn - bias, 0.0);\n      }\n    "])))),
a.fragment.code.add(c.glsl(m||(m=b(["\n      float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\n        vec3 v \x3d Q - C;\n        float vv \x3d dot(v, v);\n        float vn \x3d dot(normalize(v), n_C);\n        return fallOffFunction(vv, vn, 0.1);\n      }\n    "],["\n      float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\n        vec3 v \x3d Q - C;\n        float vv \x3d dot(v, v);\n        float vn \x3d dot(normalize(v), n_C);\n        return fallOffFunction(vv, vn, 0.1);\n      }\n    "])))),
a.fragment.code.add(c.glsl(n||(n=b(["\n      void main(void) {\n        //Hash function used in the HPG12 AlchemyAO paper\n        //Not supported in WebGL -\x3e using texture lookup as in old SSAO shader instead\n        //ivec2 ssC \x3d ivec2(gl_FragCoord.xy);\n        //float randomPatternRotationAngle \x3d float((3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10);\n        vec3 fres \x3d normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n\n        float currentPixelDepth \x3d linearDepth(depthMap, uv, nearFar);\n\n        if (-currentPixelDepth\x3enearFar.y || -currentPixelDepth\x3cnearFar.x) {\n          gl_FragColor \x3d vec4(0.0);\n          return;\n        }\n\n        vec3 currentPixelPos \x3d reconstructPosition(gl_FragCoord.xy,currentPixelDepth);\n\n        // get the normal of current fragment\n        vec4 norm4 \x3d texture2D(normalMap, uv);\n        vec3 norm \x3d vec3(-1.0) + 2.0 * norm4.xyz;\n        bool isTerrain \x3d norm4.w\x3c0.5;\n\n        float sum \x3d .0;\n\n        vec4 occluderFragment;\n        vec3 ray;\n\n        vec3 tapPixelPos;\n\n        // note: the factor 2.0 should not be necessary, but makes ssao much nicer.\n        // bug or deviation from CE somewhere else?\n        float ps \x3d projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n\n        for(int i \x3d 0; i \x3c SAMPLES; ++i) {\n          // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it\n          //float ssR;\n          //vec2 unitOffset \x3d tapLocation(i, randomPatternRotationAngle, ssR);\n          // get the depth of the occluder fragment\n          //vec2 offset \x3d vec2(-unitOffset*radius*ssR*ps);\n\n          vec2 unitOffset \x3d reflect(pSphere[i], fres).xy;\n          vec2 offset \x3d vec2(-unitOffset*radius*ps);\n\n          //don't use current or very nearby samples\n          if ( abs(offset.x)\x3c2.0 || abs(offset.y)\x3c2.0) continue;\n\n          vec2 tc \x3d vec2(gl_FragCoord.xy + offset);\n          if (tc.x \x3c 0.0 || tc.y \x3c 0.0 || tc.x \x3e screenDimensions.x || tc.y \x3e screenDimensions.y) continue;\n          vec2 tcTap \x3d tc/screenDimensions;\n          float occluderFragmentDepth \x3d linearDepth(depthMap, tcTap, nearFar);\n\n          if (isTerrain) {\n            bool isTerrainTap \x3d texture2D(normalMap, tcTap).w\x3c0.5;\n            if (isTerrainTap) {\n              continue;\n            }\n          }\n\n          tapPixelPos \x3d reconstructPosition(tc, occluderFragmentDepth);\n\n          sum+\x3d aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n        }\n\n        // output the result\n\n        float A \x3d max(1.0-sum*intensity/float(SAMPLES),0.0);\n\n        // Anti-tone map to reduce contrast and drag dark region farther\n        // (x^0.2 + 1.2 * x^4)/2.2\n        A \x3d (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n\n        //gl_FragColor \x3d vec4(norm/2.0+0.5, 1.0);\n        //gl_FragColor \x3d vec4(-currentPixelDepth/1000.0);\n        //gl_FragColor \x3d vec4(tapPixelPos.x/100.0);\n        gl_FragColor \x3d vec4(A);\n      }\n    "],
["\n      void main(void) {\n        //Hash function used in the HPG12 AlchemyAO paper\n        //Not supported in WebGL -\x3e using texture lookup as in old SSAO shader instead\n        //ivec2 ssC \x3d ivec2(gl_FragCoord.xy);\n        //float randomPatternRotationAngle \x3d float((3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10);\n        vec3 fres \x3d normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n\n        float currentPixelDepth \x3d linearDepth(depthMap, uv, nearFar);\n\n        if (-currentPixelDepth\x3enearFar.y || -currentPixelDepth\x3cnearFar.x) {\n          gl_FragColor \x3d vec4(0.0);\n          return;\n        }\n\n        vec3 currentPixelPos \x3d reconstructPosition(gl_FragCoord.xy,currentPixelDepth);\n\n        // get the normal of current fragment\n        vec4 norm4 \x3d texture2D(normalMap, uv);\n        vec3 norm \x3d vec3(-1.0) + 2.0 * norm4.xyz;\n        bool isTerrain \x3d norm4.w\x3c0.5;\n\n        float sum \x3d .0;\n\n        vec4 occluderFragment;\n        vec3 ray;\n\n        vec3 tapPixelPos;\n\n        // note: the factor 2.0 should not be necessary, but makes ssao much nicer.\n        // bug or deviation from CE somewhere else?\n        float ps \x3d projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n\n        for(int i \x3d 0; i \x3c SAMPLES; ++i) {\n          // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it\n          //float ssR;\n          //vec2 unitOffset \x3d tapLocation(i, randomPatternRotationAngle, ssR);\n          // get the depth of the occluder fragment\n          //vec2 offset \x3d vec2(-unitOffset*radius*ssR*ps);\n\n          vec2 unitOffset \x3d reflect(pSphere[i], fres).xy;\n          vec2 offset \x3d vec2(-unitOffset*radius*ps);\n\n          //don't use current or very nearby samples\n          if ( abs(offset.x)\x3c2.0 || abs(offset.y)\x3c2.0) continue;\n\n          vec2 tc \x3d vec2(gl_FragCoord.xy + offset);\n          if (tc.x \x3c 0.0 || tc.y \x3c 0.0 || tc.x \x3e screenDimensions.x || tc.y \x3e screenDimensions.y) continue;\n          vec2 tcTap \x3d tc/screenDimensions;\n          float occluderFragmentDepth \x3d linearDepth(depthMap, tcTap, nearFar);\n\n          if (isTerrain) {\n            bool isTerrainTap \x3d texture2D(normalMap, tcTap).w\x3c0.5;\n            if (isTerrainTap) {\n              continue;\n            }\n          }\n\n          tapPixelPos \x3d reconstructPosition(tc, occluderFragmentDepth);\n\n          sum+\x3d aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n        }\n\n        // output the result\n\n        float A \x3d max(1.0-sum*intensity/float(SAMPLES),0.0);\n\n        // Anti-tone map to reduce contrast and drag dark region farther\n        // (x^0.2 + 1.2 * x^4)/2.2\n        A \x3d (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n\n        //gl_FragColor \x3d vec4(norm/2.0+0.5, 1.0);\n        //gl_FragColor \x3d vec4(-currentPixelDepth/1000.0);\n        //gl_FragColor \x3d vec4(tapPixelPos.x/100.0);\n        gl_FragColor \x3d vec4(A);\n      }\n    "])))));
return a};var g,h,k,l,m,n});