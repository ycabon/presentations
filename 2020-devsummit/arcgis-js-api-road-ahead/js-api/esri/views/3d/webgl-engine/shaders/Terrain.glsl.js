// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define("require exports ../../../../core/tsSupport/makeTemplateObjectHelper ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/Transform.glsl ../core/shaderLibrary/output/OutputDepth.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../core/shaderLibrary/shading/NormalUtils.glsl ../core/shaderLibrary/util/RgbaFloatEncoding.glsl ../core/shaderModules/interfaces ../core/shaderModules/ShaderBuilder ./Overlay.glsl ./Skirts.glsl".split(" "),
function(U,g,c,N,e,O,P,Q,f,R,d,S,h,T){Object.defineProperty(g,"__esModule",{value:!0});g.build=function(b){var a=new S.ShaderBuilder;a.include(T.Skirts);a.attributes.add("position","vec3");a.attributes.add("uv0","vec2");a.vertex.uniforms.add("proj","mat4").add("view","mat4").add("origin","vec3").add("skirtScale","float");0===b.output&&(a.include(e.Transform,{linearDepth:!1}),a.include(f.NormalUtils,b),b.overlayEnabled&&a.include(h.Overlay,{pbrMode:3,useCustomDTRExponentForWater:!1}),a.varyings.add("vnormal",
"vec3"),a.varyings.add("vpos","vec3"),a.varyings.add("vtc","vec2"),a.vertex.uniforms.add("viewNormal","mat4"),a.vertex.uniforms.add("texOffsetAndScale","vec4"),a.vertex.uniforms.add("oldTexOffsetAndScale","vec4"),b.receiveShadows&&a.varyings.add("linearDepth","float"),b.tileBorders&&a.varyings.add("vuv","vec2"),b.atmosphere&&(a.vertex.uniforms.add("lightingMainDirection","vec3"),a.varyings.add("wnormal","vec3"),a.varyings.add("wlight","vec3")),b.overlayEnabled&&(a.varyings.add("tbnTangent","vec3"),
a.varyings.add("tbnBiTangent","vec3")),b.textureFadingEnabled&&a.varyings.add("ovtc","vec2"),b.screenSizePerspective&&(a.vertex.uniforms.add("screenSizePerspective","vec4"),a.varyings.add("screenSizeDistanceToCamera","float"),a.varyings.add("screenSizeCosAngle","float")),a.vertex.code.add(d.glsl(k||(k=c(["\n      void main(void) {\n        vpos \x3d position;\n        vnormal \x3d getLocalUp(vpos, origin);\n\n        vec2 uv \x3d uv0;\n        vpos \x3d applySkirts(uv, vpos, vnormal, skirtScale);\n        ",
"\n        ","\n        ","\n        gl_Position \x3d transformPosition(proj, view, vpos);\n        ","\n        vtc \x3d uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n        ","\n        ","\n      }\n    "],["\n      void main(void) {\n        vpos \x3d position;\n        vnormal \x3d getLocalUp(vpos, origin);\n\n        vec2 uv \x3d uv0;\n        vpos \x3d applySkirts(uv, vpos, vnormal, skirtScale);\n        ","\n        ","\n        ","\n        gl_Position \x3d transformPosition(proj, view, vpos);\n        ",
"\n        vtc \x3d uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n        ","\n        ","\n      }\n    "])),b.atmosphere?d.glsl(l||(l=c(["\n        wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight \x3d (view  * vec4(-lightingMainDirection, 1.0)).xyz;"],["\n        wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight \x3d (view  * vec4(-lightingMainDirection, 1.0)).xyz;"]))):"",b.tileBorders?d.glsl(m||(m=c(["vuv \x3d uv;"],["vuv \x3d uv;"]))):
"",b.screenSizePerspective?d.glsl(n||(n=c(["\n        vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera \x3d length(viewPos);\n        vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle \x3d abs(viewSpaceNormal.z);"],["\n        vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera \x3d length(viewPos);\n        vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle \x3d abs(viewSpaceNormal.z);"]))):
"",b.receiveShadows?d.glsl(p||(p=c(["linearDepth \x3d gl_Position.w;"],["linearDepth \x3d gl_Position.w;"]))):"",b.overlayEnabled?d.glsl(q||(q=c(["\n        setOverlayVTC(uv);\n        ","\n        "],["\n        setOverlayVTC(uv);\n        ","\n        "])),0===b.viewingMode?d.glsl(r||(r=c(["\n        tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n        tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));"],["\n        tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n        tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));"]))):
d.glsl(t||(t=c(["\n        tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n        tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));"],["\n        tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n        tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));"])))):"",b.textureFadingEnabled?d.glsl(u||(u=c(["\n        ovtc \x3d uv * oldTexOffsetAndScale.zw + oldTexOffsetAndScale.xy;"],["\n        ovtc \x3d uv * oldTexOffsetAndScale.zw + oldTexOffsetAndScale.xy;"]))):"")),a.extensions.add("GL_OES_standard_derivatives"),
a.extensions.add("GL_EXT_shader_texture_lod"),a.include(N.Slice,b),a.include(Q.EvaluateSceneLighting,b),a.fragment.uniforms.add("camPos","vec3").add("viewDirection","vec3").add("ssaoTex","sampler2D").add("viewportPixelSz","vec4").add("tex","sampler2D").add("opacity","float"),b.screenSizePerspective&&a.fragment.uniforms.add("screenSizePerspective","vec4"),b.overlayEnabled&&(a.fragment.uniforms.add("ovInnerWaterTex","sampler2D"),a.fragment.uniforms.add("ovOuterWaterTex","sampler2D")),b.textureFadingEnabled&&
a.fragment.uniforms.add("texOld","sampler2D").add("textureFadeFactor","float"),a.fragment.code.add(d.glsl(v||(v=c(["\n      const vec3 ambient \x3d vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse \x3d vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness \x3d 2.5;\n      const float sliceOpacity \x3d 0.2;\n\n      float lum(vec3 c) {\n        float max \x3d max(max(c.r, c.g), c.b);\n        float min \x3d min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "],["\n      const vec3 ambient \x3d vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse \x3d vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness \x3d 2.5;\n      const float sliceOpacity \x3d 0.2;\n\n      float lum(vec3 c) {\n        float max \x3d max(max(c.r, c.g), c.b);\n        float min \x3d min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "])))),
b.atmosphere&&a.fragment.code.add(d.glsl(w||(w=c(["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   \x3d vec3(0.0);\n        vec3 fuzzySpecColor \x3d vec3(1.0);\n        vec3 subColor       \x3d vec3(0.0);\n        float rollOff       \x3d 1.0;\n\n        vec3 Ln \x3d normalize(lightPos);\n        vec3 Nn \x3d normalize(normal);\n        vec3 Hn \x3d normalize(view + Ln);\n\n        float ldn \x3d dot(Ln, Nn);\n        float diffComp \x3d max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn \x3d clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv \x3d dot(view, Ln);\n\n        vec3 diffContrib \x3d surfaceColor * diffComp;\n        float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib \x3d subLamb * subColor;\n        vec3 vecColor \x3d vec3(vdn);\n\n        vec3 diffuseContrib \x3d (subContrib + diffContrib);\n        vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "],
["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   \x3d vec3(0.0);\n        vec3 fuzzySpecColor \x3d vec3(1.0);\n        vec3 subColor       \x3d vec3(0.0);\n        float rollOff       \x3d 1.0;\n\n        vec3 Ln \x3d normalize(lightPos);\n        vec3 Nn \x3d normalize(normal);\n        vec3 Hn \x3d normalize(view + Ln);\n\n        float ldn \x3d dot(Ln, Nn);\n        float diffComp \x3d max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn \x3d clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv \x3d dot(view, Ln);\n\n        vec3 diffContrib \x3d surfaceColor * diffComp;\n        float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib \x3d subLamb * subColor;\n        vec3 vecColor \x3d vec3(vdn);\n\n        vec3 diffuseContrib \x3d (subContrib + diffContrib);\n        vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "])))),
a.fragment.code.add(d.glsl(x||(x=c(["\n      void main() {\n        ","\n        float vndl \x3d dot(normalize(vnormal), -lightingMainDirection);\n        float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        ","\n        ","\n        if (rejectBySlice(vpos)) {\n          tileColor *\x3d sliceOpacity;\n        }\n        vec3 atm \x3d vec3(0.0);\n        ",
"\n        vec3 albedo \x3d atm + tileColor.rgb;\n        vec3 normal \x3d normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor \x3d vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ",
"\n        ","\n        ","\n        gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n      void main() {\n        ","\n        float vndl \x3d dot(normalize(vnormal), -lightingMainDirection);\n        float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        ",
"\n        ","\n        if (rejectBySlice(vpos)) {\n          tileColor *\x3d sliceOpacity;\n        }\n        vec3 atm \x3d vec3(0.0);\n        ","\n        vec3 albedo \x3d atm + tileColor.rgb;\n        vec3 normal \x3d normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor \x3d vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ",
"\n        ","\n        ","\n        gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n      }\n    "])),b.receiveShadows?d.glsl(y||(y=c(["float shadow \x3d readShadowMap(vpos, linearDepth);"],["float shadow \x3d readShadowMap(vpos, linearDepth);"]))):d.glsl(z||(z=c(["float shadow \x3d 0.0;"],["float shadow \x3d 0.0;"]))),b.textureFadingEnabled?d.glsl(A||(A=c(["vec4 tileColor \x3d (textureFadeFactor \x3c 1.0 ? mix(texture2D(texOld, ovtc), texture2D(tex, vtc), textureFadeFactor) : texture2D(tex, vtc)) * opacity;"],
["vec4 tileColor \x3d (textureFadeFactor \x3c 1.0 ? mix(texture2D(texOld, ovtc), texture2D(tex, vtc), textureFadeFactor) : texture2D(tex, vtc)) * opacity;"]))):d.glsl(B||(B=c(["vec4 tileColor \x3d texture2D(tex, vtc) * opacity;"],["vec4 tileColor \x3d texture2D(tex, vtc) * opacity;"]))),b.overlayEnabled?d.glsl(C||(C=c(["vec4 overlayColor \x3d getCombinedOverlayColor();\n            tileColor \x3d tileColor * (1.0 - overlayColor.a) + overlayColor;"],["vec4 overlayColor \x3d getCombinedOverlayColor();\n            tileColor \x3d tileColor * (1.0 - overlayColor.a) + overlayColor;"]))):
"",b.atmosphere?d.glsl(D||(D=c(["\n            float ndotl \x3d max(0.0, min(1.0, vndl));\n            atm \x3d atmosphere(wlight, wnormal, -viewDirection);\n            atm *\x3d max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *\x3d max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *\x3d tileColor.a; // premultiply with tile alpha"],["\n            float ndotl \x3d max(0.0, min(1.0, vndl));\n            atm \x3d atmosphere(wlight, wnormal, -viewDirection);\n            atm *\x3d max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *\x3d max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *\x3d tileColor.a; // premultiply with tile alpha"]))):
"",b.overlayEnabled?d.glsl(E||(E=c(["\n            vec4 overlayWaterMask \x3d getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n            float waterNormalLength \x3d length(overlayWaterMask);\n            if (waterNormalLength \x3e 0.95) {\n              mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterColor \x3d overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n              // un-gamma the ground color to mix in linear space\n              vec4 groundColor \x3d vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n              waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n              gl_FragColor \x3d delinearizeGamma(waterColor);\n            }"],
["\n            vec4 overlayWaterMask \x3d getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n            float waterNormalLength \x3d length(overlayWaterMask);\n            if (waterNormalLength \x3e 0.95) {\n              mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterColor \x3d overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n              // un-gamma the ground color to mix in linear space\n              vec4 groundColor \x3d vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n              waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n              gl_FragColor \x3d delinearizeGamma(waterColor);\n            }"]))):
"",b.screenSizePerspective?d.glsl(F||(F=c(["\n          float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale \x3c\x3d 0.25) {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale \x3c\x3d 0.5) {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale \x3e\x3d 0.99) {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }"],
["\n          float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale \x3c\x3d 0.25) {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale \x3c\x3d 0.5) {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale \x3e\x3d 0.99) {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }"]))):
"",b.tileBorders?d.glsl(G||(G=c(["\n            vec2 dVuv \x3d fwidth(vuv);\n            vec2 edgeFactors \x3d smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);"],["\n            vec2 dVuv \x3d fwidth(vuv);\n            vec2 edgeFactors \x3d smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);"]))):
"")));if(1===b.output||3===b.output)a.include(e.Transform,{linearDepth:!0}),a.include(R.RgbaFloatEncoding),a.include(O.OutputDepth,{output:b.output}),a.include(f.NormalUtils,b),a.varyings.add("linearDepth","float"),a.vertex.uniforms.add("nearFar","vec2"),a.vertex.code.add(d.glsl(H||(H=c(["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vec3 vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position \x3d transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "],
["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vec3 vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position \x3d transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "])))),a.fragment.code.add(d.glsl(I||(I=c(["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "],["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "]))));
2===b.output&&(a.include(e.Transform,{linearDepth:!1}),a.include(f.NormalUtils,b),a.varyings.add("vnormal","vec3"),a.varyings.add("vpos","vec3"),a.vertex.uniforms.add("viewNormal","mat4"),a.vertex.code.add(d.glsl(J||(J=c(["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vpos \x3d applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          vnormal \x3d normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "],
["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vpos \x3d applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          vnormal \x3d normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "])))),a.fragment.code.add(d.glsl(K||(K=c(["\n        void main() {\n          vec3 normal \x3d normalize(vnormal);\n          if (gl_FrontFacing \x3d\x3d false) {\n            normal \x3d -normal;\n          }\n          gl_FragColor \x3d vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "],
["\n        void main() {\n          vec3 normal \x3d normalize(vnormal);\n          if (gl_FrontFacing \x3d\x3d false) {\n            normal \x3d -normal;\n          }\n          gl_FragColor \x3d vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "])))));4===b.output&&(a.include(e.Transform,{linearDepth:!1}),a.include(f.NormalUtils,b),a.include(h.Overlay,{pbrMode:0}),a.vertex.code.add(d.glsl(L||(L=c(["\n          void main() {\n            vec3 vnormal \x3d getLocalUp(position, origin);\n            vec2 uv \x3d uv0;\n            vec3 vpos \x3d applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position \x3d transformPosition(proj, view, vpos);\n          }\n      "],
["\n          void main() {\n            vec3 vnormal \x3d getLocalUp(position, origin);\n            vec2 uv \x3d uv0;\n            vec3 vpos \x3d applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position \x3d transformPosition(proj, view, vpos);\n          }\n      "])))),a.include(P.OutputHighlight),a.fragment.code.add(d.glsl(M||(M=c(["\n        void main() {\n          vec4 overlayColor \x3d getCombinedOverlayColor();\n\n          if (overlayColor.a \x3d\x3d 0.0) {\n            gl_FragColor \x3d vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "],
["\n        void main() {\n          vec4 overlayColor \x3d getCombinedOverlayColor();\n\n          if (overlayColor.a \x3d\x3d 0.0) {\n            gl_FragColor \x3d vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "])))));return a};var l,m,n,p,r,t,q,u,k,v,w,y,z,A,B,C,D,E,F,G,x,H,I,J,K,L,M});