// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.16/esri/copyright.txt for details.
//>>built
define("require exports ../../../../../../core/tsSupport/makeTemplateObjectHelper ../../../core/shaderLibrary/Slice.glsl ../../../core/shaderModules/interfaces ../../../core/shaderModules/ShaderBuilder ./AdjustProjectedPosition.glsl ./DiscardByCoverage.glsl ./DiscardNonSilhouetteEdges.glsl ./DiscardShortEdges.glsl ./EdgeUtil.glsl ./LineAmplitude.glsl ./LineOffset.glsl ./UnpackAttributes.glsl".split(" "),function(y,d,e,m,f,n,p,q,r,t,u,v,w,x){Object.defineProperty(d,"__esModule",{value:!0});d.attributeLocations=
{position0:0,position1:1,componentIndex:2,packedAttributes:3,variantOffset:4,variantStroke:5,variantExtension:6,normal:7,normalA:7,normalB:8,sideness:9};d.build=function(b){var a=new n.ShaderBuilder,c=a.vertex,d=a.fragment;b.legacy&&c.uniforms.add("uModel","mat4");b.antialiasing&&(c.code.add(f.glsl(g||(g=e(["\n      #define ANTIALIASING 1\n    "],["\n      #define ANTIALIASING 1\n    "])))),d.code.add(f.glsl(h||(h=e(["\n      #define ANTIALIASING 1\n    "],["\n      #define ANTIALIASING 1\n    "])))));
a.include(p.AdjustProjectedPosition,b);a.include(v.LineAmplitude,b);a.include(u.EdgeUtil,b);a.include(x.UnpackAttributes,b);a.include(w.LineOffset,b);a.include(m.Slice,b);a.include(r.DiscardNonSilhouetteEdges,b);a.include(q.DiscardByCoverage,b);a.include(t.DiscardShortEdges,b);a.varyings.add("vColor","vec4");a.varyings.add("vRadius","float");a.varyings.add("vPosition","vec3");a.varyings.add("vWorldPosition","vec3");a.varyings.add("vLineLengthPixels","float");a.varyings.add("vSizeFalloffFactor","float");
c.uniforms.add("uPixelToNDC","vec2");c.uniforms.add("uNDCToPixel","vec2");c.uniforms.add("uPixelRatio","float");a.attributes.add("position0","vec3");a.attributes.add("position1","vec3");a.attributes.add("variantOffset","float");a.attributes.add("variantStroke","float");a.attributes.add("variantExtension","float");c.code.add(f.glsl(k||(k=e(["\n    const float opaqueCutoff \x3d 1.0 / 255.0;\n\n    void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n      vec2 sideness \x3d unpackedAttributes.sideness;\n      vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\n\n      vWorldPosition \x3d mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\n\n      vec3 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\n\n      vec4 projPosV0 \x3d projFromViewPosition(viewPosV0);\n      vec4 projPosV1 \x3d projFromViewPosition(viewPosV1);\n      vec4 projPos \x3d projFromViewPosition(viewPos);\n\n      vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n      vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\n      float lineLengthPixels \x3d length(screenSpaceLinePixels);\n\n      float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\n      vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\n      vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n\n      float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\n      float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\n\n      float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n      float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\n\n      vSizeFalloffFactor \x3d falloffFactor;\n\n      float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n      float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n\n    #ifdef ANTIALIASING\n      const float aaPaddingPixels \x3d 1.0;\n\n      // Line size with padding\n      float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n      float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\n    #else /* ANTIALIASING */\n\n      // Even if there is no AA, we still want to do proper \x3c1px rendering,\n      // so we effectively clamp the pixel sizes to minimum of 1px and compute\n      // coverage in the fragment shader\n      float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n      float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\n    #endif /* ANTIALIASING */\n\n      // Half line width in NDC including padding for anti aliasing\n      vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\n      vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\n      vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\n\n      // Compute screen space position of vertex, offsetting for line size and end caps\n      vec2 ndcOffset \x3d (\n          screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n        + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n      );\n\n      projPos.xy +\x3d ndcOffset * projPos.w;\n      projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n\n      projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n\n      // Line length with end caps\n      float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n\n      float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n\n      // Position in pixels with origin at first vertex of line segment\n      vPosition \x3d vec3(\n        halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n        pixelPositionAlongLine,\n        pixelPositionAlongLine / extendedLineLengthPixels\n      );\n\n      // The line width radius in pixels\n      vRadius \x3d lineWidthPixels * 0.5;\n      vLineLengthPixels \x3d extendedLineLengthPixels;\n\n      // discard edges below a certain length threshold\n      discardShortEdges(unpackedAttributes, lineLengthPixels);\n\n      gl_Position \x3d projPos;\n    }\n\n    void main() {\n      ComponentData component \x3d readComponentData();\n      UnpackedAttributes unpackedAttributes \x3d unpackAttributes(component);\n\n      vec3 worldPosV0 \x3d worldFromModelPosition(position0);\n      vec3 worldPosV1 \x3d worldFromModelPosition(position1);\n      vec3 viewPosV0 \x3d viewFromModelPosition(position0);\n      vec3 viewPosV1 \x3d viewFromModelPosition(position1);\n\n      // Component color\n      vColor \x3d component.color;\n\n      // Discard fully transparent edges\n      if (vColor.a \x3c opaqueCutoff) {\n        gl_Position \x3d vec4(10.0, 10.0, 10.0, 1.0);\n        return;\n      }\n\n      if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {\n        return;\n      }\n\n      // General geometric computation for all types of edges\n      calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);\n\n      // Specific computation for different edge styles\n      calculateStyleOutputs(unpackedAttributes);\n    }\n  "],
["\n    const float opaqueCutoff \x3d 1.0 / 255.0;\n\n    void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n      vec2 sideness \x3d unpackedAttributes.sideness;\n      vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\n\n      vWorldPosition \x3d mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\n\n      vec3 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\n\n      vec4 projPosV0 \x3d projFromViewPosition(viewPosV0);\n      vec4 projPosV1 \x3d projFromViewPosition(viewPosV1);\n      vec4 projPos \x3d projFromViewPosition(viewPos);\n\n      vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n      vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\n      float lineLengthPixels \x3d length(screenSpaceLinePixels);\n\n      float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\n      vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\n      vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n\n      float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\n      float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\n\n      float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n      float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\n\n      vSizeFalloffFactor \x3d falloffFactor;\n\n      float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n      float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n\n    #ifdef ANTIALIASING\n      const float aaPaddingPixels \x3d 1.0;\n\n      // Line size with padding\n      float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n      float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\n    #else /* ANTIALIASING */\n\n      // Even if there is no AA, we still want to do proper \x3c1px rendering,\n      // so we effectively clamp the pixel sizes to minimum of 1px and compute\n      // coverage in the fragment shader\n      float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n      float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\n    #endif /* ANTIALIASING */\n\n      // Half line width in NDC including padding for anti aliasing\n      vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\n      vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\n      vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\n\n      // Compute screen space position of vertex, offsetting for line size and end caps\n      vec2 ndcOffset \x3d (\n          screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n        + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n      );\n\n      projPos.xy +\x3d ndcOffset * projPos.w;\n      projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n\n      projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n\n      // Line length with end caps\n      float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n\n      float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n\n      // Position in pixels with origin at first vertex of line segment\n      vPosition \x3d vec3(\n        halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n        pixelPositionAlongLine,\n        pixelPositionAlongLine / extendedLineLengthPixels\n      );\n\n      // The line width radius in pixels\n      vRadius \x3d lineWidthPixels * 0.5;\n      vLineLengthPixels \x3d extendedLineLengthPixels;\n\n      // discard edges below a certain length threshold\n      discardShortEdges(unpackedAttributes, lineLengthPixels);\n\n      gl_Position \x3d projPos;\n    }\n\n    void main() {\n      ComponentData component \x3d readComponentData();\n      UnpackedAttributes unpackedAttributes \x3d unpackAttributes(component);\n\n      vec3 worldPosV0 \x3d worldFromModelPosition(position0);\n      vec3 worldPosV1 \x3d worldFromModelPosition(position1);\n      vec3 viewPosV0 \x3d viewFromModelPosition(position0);\n      vec3 viewPosV1 \x3d viewFromModelPosition(position1);\n\n      // Component color\n      vColor \x3d component.color;\n\n      // Discard fully transparent edges\n      if (vColor.a \x3c opaqueCutoff) {\n        gl_Position \x3d vec4(10.0, 10.0, 10.0, 1.0);\n        return;\n      }\n\n      if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {\n        return;\n      }\n\n      // General geometric computation for all types of edges\n      calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);\n\n      // Specific computation for different edge styles\n      calculateStyleOutputs(unpackedAttributes);\n    }\n  "]))));
a.fragment.code.add(f.glsl(l||(l=e(["\n    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n      float lineOffset \x3d calculateLineOffset();\n      float positionX \x3d position.x - lineOffset;\n\n      if (radius \x3c 1.0) {\n        // Handle this specifically for subpixel sizes:\n        // 1. Compute correct coverage (note coverage is computed by\n        //    0.5 - dist, so we make sure that that will lead to correct\n        //    subpixel coverage\n        // 2. Ignore rounded caps\n        float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n        float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n\n        float coverage \x3d min(coverageX, coverageY);\n\n        return vec2(0.5 - coverage, 0.0);\n      }\n      else {\n        // Between -radius -\x3e 0 for start cap, 0 for line, 0 -\x3e radius\n        float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\n\n        vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\n        return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n      }\n    }\n\n    void main() {\n      float radius \x3d vRadius * calculateLinePressure();\n\n      vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n      float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\n\n      discardByCoverage(radius, coverage);\n      discardBySlice(vWorldPosition);\n\n      float alpha \x3d vColor.a * coverage;\n\n      gl_FragColor \x3d vec4(vColor.rgb, alpha);\n\n    }\n  "],
["\n    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n      float lineOffset \x3d calculateLineOffset();\n      float positionX \x3d position.x - lineOffset;\n\n      if (radius \x3c 1.0) {\n        // Handle this specifically for subpixel sizes:\n        // 1. Compute correct coverage (note coverage is computed by\n        //    0.5 - dist, so we make sure that that will lead to correct\n        //    subpixel coverage\n        // 2. Ignore rounded caps\n        float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n        float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n\n        float coverage \x3d min(coverageX, coverageY);\n\n        return vec2(0.5 - coverage, 0.0);\n      }\n      else {\n        // Between -radius -\x3e 0 for start cap, 0 for line, 0 -\x3e radius\n        float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\n\n        vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\n        return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n      }\n    }\n\n    void main() {\n      float radius \x3d vRadius * calculateLinePressure();\n\n      vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n      float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\n\n      discardByCoverage(radius, coverage);\n      discardBySlice(vWorldPosition);\n\n      float alpha \x3d vColor.a * coverage;\n\n      gl_FragColor \x3d vec4(vColor.rgb, alpha);\n\n    }\n  "]))));
return a};var g,h,k,l});