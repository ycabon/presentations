import { aF as t$1, h as e, y as e$1, z as y$1, A as i, B as p, eo as F, b2 as S$1, U, c6 as z, ev as x$1, dY as o$1, E as f$1 } from './_virtual:index-3cfe80ed.js';
import { c } from './Bitmap-ce9d1e89.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const t=Math.PI/180;function o(n,o){const r=o.rotation*t;const s=Math.abs(Math.cos(r)),u=Math.abs(Math.sin(r)),[a,c]=o.size;return n[0]=Math.round(c*u+a*s),n[1]=Math.round(c*s+a*u),n}function r(t,n,o,r){const[s,u]=n,[a,c]=r,h=.5*o;return t[0]=s-h*a,t[1]=u-h*c,t[2]=s+h*a,t[3]=u+h*c,t}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const f=t$1(),x=[0,0],y=new e(0,0,0,0),j=2048,v=2048,_=!1,S=!1,R=!1;let M=class extends p{constructor(t){super(t),this._imagePromise=null,this.hidpi=R,this.imageMaxWidth=j,this.imageMaxHeight=v,this.imageRotationSupported=_,this.imageNormalizationSupported=S,this.update=F((async(t,e)=>{const o$1=t.state,i=S$1(o$1.spatialReference),r=this.hidpi?t.pixelRatio:1;if(!t.stationary||this.destroyed)return;this.imageRotationSupported?(x[0]=o$1.size[0],x[1]=o$1.size[1]):o(x,o$1);const s=Math.floor(x[0]*r)>this.imageMaxWidth||Math.floor(x[1]*r)>this.imageMaxHeight,a=i&&(o$1.extent.xmin<i.valid[0]||o$1.extent.xmax>i.valid[1]),n=!this.imageNormalizationSupported&&a,m=!s&&!n,l=this.imageRotationSupported?o$1.rotation:0;if(m)this._imagePromise=this._singleExport(o$1,x,l,r,e);else {let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);n&&(t=Math.min(o$1.worldScreenWidth,t)),this._imagePromise=this._tiledExport(o$1,t,l,r,e);}return this._imagePromise.then((async t=>{this._imagePromise=null,await Promise.all(t.map((t=>(this.container.addChild(t),t.fadeIn()))));for(const e of this.container.children)t.includes(e)||e.fadeOut().then((()=>{this.container.removeChild(e);}));})).catch((t=>{throw this._imagePromise=null,t}))}),5e3);}destroy(){}get updating(){return null!==this._imagePromise}updateExports(t){for(const e of this.container.children){if(!e.visible||!e.stage)return;t(e)?console.error("ExportStrategy.updateExports doesn't support promise yet"):(e.invalidateTexture(),e.requestRender());}}_export(t,e,o,i,s,a){return U().then((()=>this.fetchSource(t,Math.floor(e*s),Math.floor(o*s),{rotation:i,pixelRatio:s,signal:a}))).then((o=>{const r=new c(o);return r.x=t.xmin,r.y=t.ymax,r.resolution=t.width/e,r.rotation=i,r.pixelRatio=s,r}))}_singleExport(t,e,o,i,r$1){r(f,t.center,t.resolution,e);const s=new z(f[0],f[1],f[2],f[3],t.spatialReference);return this._export(s,e[0],e[1],o,i,r$1).then((t=>[t]))}_tiledExport(t,e,o,i,r){const a=x$1.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),p=new o$1(a),m=p.getTileCoverage(t);if(!m)return null;const h=[];return m.forEach(((s,a,m,l)=>{y.set(s,a,m,l),p.getTileBounds(f,y);const c=new z(f[0],f[1],f[2],f[3],t.spatialReference);h.push(this._export(c,e,e,o,i,r));})),f$1(h)}};e$1([y$1()],M.prototype,"_imagePromise",void 0),e$1([y$1()],M.prototype,"container",void 0),e$1([y$1()],M.prototype,"fetchSource",void 0),e$1([y$1()],M.prototype,"hidpi",void 0),e$1([y$1()],M.prototype,"imageMaxWidth",void 0),e$1([y$1()],M.prototype,"imageMaxHeight",void 0),e$1([y$1()],M.prototype,"imageRotationSupported",void 0),e$1([y$1()],M.prototype,"imageNormalizationSupported",void 0),e$1([y$1()],M.prototype,"requestUpdate",void 0),e$1([y$1({dependsOn:["_imagePromise"]})],M.prototype,"updating",null),M=e$1([i("esri.views.2d.layers.support.ExportStrategy")],M);var w=M;

export { w };
