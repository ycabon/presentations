import { k as i$3, i as i$4, q as o$1, bE as n$2, D as D$2, aa as n$3, ab as h$1, bF as u$2, C as u$3, u as p$2, V as n$4, f as t$1, bZ as h$2, bM as d$1, b_ as K$1, bQ as f$2, p as s$3, bV as G, Y as A, Z as B, b$ as C$1, c0 as D$3, c1 as y$1, c2 as a, a as i$5, bB as c$2, r as r$6, G as t$2, aX as r$7, n as t$3, c3 as K$2, m as m$3, c4 as r$8, bs as o$2, c5 as s$4, aF as t$4, E as f$3 } from './_virtual:index-3cfe80ed.js';
import { b as O, I, E, R, q, K, C, D as D$1, H, G as G$1, N, P } from './Utils-7b430d1d.js';
import { a as e$2, b as r$3, e as e$3, f as f$1, r as r$4, s as s$2 } from './VertexBuffer-e387e241.js';
import { e as e$4, n as n$5, l as l$2 } from './CircularArray-11b719a7.js';
import { r as r$5, d as d$2 } from './TileContainer-657d3bf9.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
class i{constructor(){this._byGeometryType=null;}get satisfied(){return !this._byGeometryType}reset(){this._byGeometryType=null;}verticesFor(e){return this._byGeometryType?this._byGeometryType[e].vertices:0}indicesFor(e){return this._byGeometryType?this._byGeometryType[e].indices:0}needMore(e,t,i){if(!t&&!i)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const r=this._byGeometryType[e];r.vertices+=t,r.indices+=i;}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
class r{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}];}clone(){const e=new r;for(let r=0;r<this.geometries.length;r++){const f=this.geometries[r],t=e.geometries[r];t.indexBuffer=f.indexBuffer.slice(),t.vertexBuffer={};for(const e in f.vertexBuffer){const{data:r,stride:i}=f.vertexBuffer[e];t.vertexBuffer[e]={data:r.slice(),stride:i};}}return e}static deserialize(f){const t=new r;for(let r=0;r<5;++r){t.geometries[r].indexBuffer=new Uint32Array(f.geometries[r].indexBuffer),t.geometries[r].vertexBuffer={};for(const i in f.geometries[r].vertexBuffer)t.geometries[r].vertexBuffer[i]={data:O(f.geometries[r].vertexBuffer[i].data,f.geometries[r].vertexBuffer[i].stride),stride:f.geometries[r].vertexBuffer[i].stride};}return t}serialize(){const e={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let r=0;r<5;++r)for(const f in this.geometries[r].vertexBuffer)e.geometries[r].vertexBuffer[f]={data:this.geometries[r].vertexBuffer[f].data.buffer,stride:this.geometries[r].vertexBuffer[f].stride};return e}getBuffers(){const e=[];for(let r=0;r<5;++r){e.push(this.geometries[r].indexBuffer.buffer);for(const f in this.geometries[r].vertexBuffer)e.push(this.geometries[r].vertexBuffer[f].data.buffer);}return e}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const n=i$3.getLogger("esri.views.2d.engine.webgl.WGLDisplayList");function i$1(e,t,o,...n){t<e.length?e.splice(t,o,...n):e.push(...n);}const r$1=new Map;r$1.set(I.MAP,[E.FILL,E.LINE,E.MARKER,E.TEXT]),r$1.set(I.LABEL,[E.LABEL]),r$1.set(I.LABEL_ALPHA,[E.LABEL]);class s{constructor(e=!1){this.symbolLevels=[],this.unified=e;}replay(e,t,o){if(this.unified)for(const n of this.symbolLevels)for(const i of n.zLevels){const n=i.geometryDPInfo.unified;if(n)for(const i of n){const n=e.painter.getGeometryBrush(i.geometryType),r=t.getGeometry(i.geometryType);n.prepareState(e,t),n.drawGeometry(e,t,i,r,o);}}}get empty(){return !this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0;}addToList(e,t){if(Array.isArray(e))for(const o of e)this._addToList(o,t);else this._addToList(e,t);}removeFromList(e){Array.isArray(e)||(e=[e]);let t=null;for(const o of e)t=this._removeFromList(o);return t}byType(e,t){for(const o of this.symbolLevels)for(const n of o.zLevels){const o=n.geometryDPInfo,i=this.getDPInfoType(e);if(o[i])for(const e of o[i])t(e);}}clone(){const e=new s(this.unified);for(const t of this.symbolLevels)e.symbolLevels.push(t.clone());return e}splitAfter(e){const t=this._getDisplayList(e.symbolLevel,e.zOrder,e.geometryType),o=t.length,n=e.indexFrom+e.indexCount;for(let i=0;i<o;++i){const o=t[i];if(o.geometryType===e.geometryType&&n>o.indexFrom&&n<=o.indexFrom+o.indexCount){if(n<o.indexFrom+o.indexCount){const e=new l;e.geometryType=o.geometryType,e.materialKey=o.materialKey,e.indexFrom=n,e.indexCount=o.indexFrom+o.indexCount-n,t.splice(i+1,0,e),o.indexCount=n-o.indexFrom;}return i}}}_addToList(e,t){const o=e.symbolLevel,n=e.zOrder,r=this._getDisplayList(o,n,e.geometryType),s=null!=t?t:r.length-1,m=s>=0&&s<r.length?r[s]:null;if(null===m||m.materialKey!==e.materialKey||m.indexFrom+m.indexCount!==e.indexFrom||this.unified&&m.geometryType!==e.geometryType){const t=new l;t.indexFrom=e.indexFrom,t.indexCount=e.indexCount,t.materialKey=e.materialKey,t.geometryType=e.geometryType,i$1(r,s+1,0,t);}else m.indexCount+=e.indexCount;}_removeFromList(e){const t=e.symbolLevel,o=e.zOrder,n=this._getDisplayList(t,o,e.geometryType),r=n.length;let s;for(let t=0;t<r;++t){const o=n[t];if(e.indexFrom+e.indexCount>o.indexFrom&&e.indexFrom<o.indexFrom+o.indexCount&&(!this.unified||o.geometryType===e.geometryType)){s=t;break}}if(void 0!==s){const t=n[s];if(e.indexFrom===t.indexFrom)return t.indexCount-=e.indexCount,t.indexFrom+=e.indexCount,0===t.indexCount&&i$1(n,s,1),s-1;if(e.indexFrom+e.indexCount===t.indexFrom+t.indexCount)return t.indexCount-=e.indexCount,0===t.indexCount?(i$1(n,s,1),s-1):s;{const o=t.indexFrom,r=e.indexFrom-t.indexFrom,m=e.indexCount,y=t.indexFrom+t.indexCount-(e.indexFrom+e.indexCount);t.indexCount=r;const d=new l;return d.geometryType=t.geometryType,d.materialKey=t.materialKey,d.indexFrom=o+r+m,d.indexCount=y,i$1(n,s+1,0,d),s}}return null}_getDisplayList(e,t,n){let i;const r=this.symbolLevels.length;for(let t=0;t<r;t++)if(this.symbolLevels[t].symbolLevel===e){i=this.symbolLevels[t];break}let s;i||(i=new d,i.symbolLevel=e,this.symbolLevels.push(i));const l=i.zLevels.length;for(let e=0;e<l;e++)if(i.zLevels[e].zLevel===t){s=i.zLevels[e];break}let f;if(s||(s=new y,s.geometryDPInfo=new m,s.zLevel=t,i.zLevels.push(s)),this.unified)s.geometryDPInfo.unified||(s.geometryDPInfo.unified=[]),f=s.geometryDPInfo.unified;else switch(n){case E.FILL:s.geometryDPInfo.fill||(s.geometryDPInfo.fill=[]),f=s.geometryDPInfo.fill;break;case E.LINE:s.geometryDPInfo.line||(s.geometryDPInfo.line=[]),f=s.geometryDPInfo.line;break;case E.MARKER:s.geometryDPInfo.marker||(s.geometryDPInfo.marker=[]),f=s.geometryDPInfo.marker;break;case E.TEXT:s.geometryDPInfo.text||(s.geometryDPInfo.text=[]),f=s.geometryDPInfo.text;break;case E.LABEL:s.geometryDPInfo.label||(s.geometryDPInfo.label=[]),f=s.geometryDPInfo.label;break;default:console.error("Trying to add a record with geometry type '"+n+"'.");}return f}getDPInfoType(e){if(this.unified)return "unified";switch(e){case E.FILL:return "fill";case E.LINE:return "line";case E.MARKER:return "marker";case E.TEXT:return "text";case E.LABEL:return "label";default:return void n.error(`DisplayList: Tried to convert unknown geometryType: ${e}`)}}}class l{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0;}clone(){const e=new l;return e.geometryType=this.geometryType,e.materialKey=this.materialKey,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e}}class m{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null;}clone(){const e=new m;return e.fill=this.fill&&this.fill.map((e=>e.clone())),e.line=this.line&&this.line.map((e=>e.clone())),e.marker=this.marker&&this.marker.map((e=>e.clone())),e.text=this.text&&this.text.map((e=>e.clone())),e.label=this.label&&this.label.map((e=>e.clone())),e.unified=this.unified&&this.unified.map((e=>e.clone())),e}}class y{constructor(){this.geometryDPInfo=new m;}clone(){const e=new y;return e.zLevel=this.zLevel,e.geometryDPInfo=this.geometryDPInfo.clone(),e}}class d{constructor(){this.zLevels=[];}clone(){const e=new d;e.symbolLevel=this.symbolLevel;for(const t of this.zLevels)e.zLevels.push(t.clone());return e}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
function e(s){const t=[[],[],[],[],[]],i=s;for(const s of i)for(const i of s.displayRecords)t[i.geometryType].push(i);return t}class r$2{constructor(){}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const s of this.displayObjects)this._displayObjectRegistry.set(s.id,s);}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(t){if(this._displayList=new s(t),t)for(const s of this.displayObjects)for(const t of s.displayRecords)this._displayList.addToList(t);else {const s=e(this.displayObjects),t=s.length;for(let i=0;i<t;++i){const t=s[i];this._displayList.addToList(t);}}}clone(){const s=new r$2;return this.displayObjects&&(s.displayObjects=this.displayObjects.map((s=>s.clone()))),s}serialize(s){return e$2(s,this.displayObjects),s}_deserializeObjects(s){const t=s.readInt32(),e=new Array(t),r=new Map;for(let t=0;t<e.length;++t){const l=r$3.deserialize(s);e[t]=l,r.set(l.id,l);}this.displayObjects=e,this._displayList=null,this._displayObjectRegistry=r;}static deserialize(s){const t=new r$2;return t._deserializeObjects(s),t}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const u=new i,c=new i;function p(e,r){const i={};for(const s in e){const a={data:R(r,e[s]),stride:e[s]};i[s]=a;}return i}class m$1{constructor(){this.tileDisplayData=null,this.tileBufferData=null;}reshuffle(){u.reset();const e$1=e(this.tileDisplayData.displayObjects);for(const t of e$1)for(const e of t)e&&u.needMore(e.geometryType,e.meshData?e.meshData.vertexCount:e.vertexCount,e.meshData?e.meshData.indexData.length:e.indexCount);const i=e$1.length,a=new r;for(let e=0;e<i;++e){a.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*u.indicesFor(e)));const r=[];for(const t in this.tileBufferData.geometries[e].vertexBuffer)r.push(this.tileBufferData.geometries[e].vertexBuffer[t].stride);const i=m$1._computeVertexAlignment(r),s=Math.round(1.5*u.verticesFor(e)),o=m$1._align(s,i);for(const r in this.tileBufferData.geometries[e].vertexBuffer){const i=this.tileBufferData.geometries[e].vertexBuffer[r].stride;a.geometries[e].vertexBuffer[r]={stride:i,data:R(o,i)};}}c.reset(),this.tileDisplayData.displayList.clear();for(let t=0;t<i;++t){const i=e$1[t];for(const e of i){if(e.meshData)e.writeMeshDataToBuffers(c.verticesFor(t),a.geometries[t].vertexBuffer,c.indicesFor(t),a.geometries[t].indexBuffer),e.meshData=null;else {const i=this.tileBufferData.geometries[t].vertexBuffer,s=this.tileBufferData.geometries[t].indexBuffer,o=a.geometries[t].vertexBuffer,n=a.geometries[t].indexBuffer,f=c.verticesFor(t),l=c.indicesFor(t);q(f,l,o,n,e,i,s),e.vertexFrom=f,e.indexFrom=l;}c.needMore(t,e.vertexCount,e.indexCount);}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(i);}if(this.tileDisplayData.displayList.unified)for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=a;}reshuffleBulkAdd(i,a,o){const n=i.addOrUpdate.tileDisplayData.displayObjects,f=this.tileDisplayData.displayObjects;u.reset();for(let e=0;e<f.length;e++){const t=f[e];for(let e=0;e<t.displayRecords.length;e++){const r=t.displayRecords[e];u.needMore(r.geometryType,r.vertexCount,r.indexCount);}}for(let e=a;e<n.length;e++){const t=n[e];for(let r=e===a?o:0;r<t.displayRecords.length;r++){const e=t.displayRecords[r];u.needMore(e.geometryType,e.vertexCount,e.indexCount);}}const l=new r;for(let e=0;e<5;e++){l.geometries[e].indexBuffer=new Uint32Array(Math.round(1.5*u.indicesFor(e)));const r=[],i=this.tileBufferData.geometries[e].vertexBuffer;for(const e in i)r.push(i[e].stride);const s=m$1._computeVertexAlignment(r),a=Math.round(1.5*u.verticesFor(e)),o=m$1._align(a,s);for(const r in i){const s=i[r].stride,a=R(o,s);l.geometries[e].vertexBuffer[r]={stride:s,data:a};}}c.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<f.length;e++){const t=f[e];for(let e=0;e<t.displayRecords.length;e++){const i=t.displayRecords[e],s=i.geometryType,a=this.tileBufferData.geometries[s].vertexBuffer,o=this.tileBufferData.geometries[s].indexBuffer,n=l.geometries[s].vertexBuffer,f=l.geometries[s].indexBuffer,d=c.verticesFor(s),u=c.indicesFor(s);q(d,u,n,f,i,a,o),i.vertexFrom=d,i.indexFrom=u,c.needMore(s,i.vertexCount,i.indexCount),this.tileDisplayData.displayList.addToList(i);}}const d=this.tileDisplayData.displayObjectRegistry;if(0!==o){const t=n[a];for(let i=0;i<o;i++){const s=t.displayRecords[i];if(d.get(t.id)){if(s.geometryType!==E.FILL&&s.geometryType!==E.LINE)continue}const a=s.geometryType,o=this.tileBufferData.geometries[a].vertexBuffer,n=this.tileBufferData.geometries[a].indexBuffer,f=l.geometries[a].vertexBuffer,u=l.geometries[a].indexBuffer,p=c.verticesFor(a),m=c.indicesFor(a);q(p,m,f,u,s,o,n),s.vertexFrom=p,s.indexFrom=m,c.needMore(a,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s);}}for(let t=a;t<n.length;t++){const s=n[t],f=t===a?o:0,u=d.get(s.id);for(let t=f;t<s.displayRecords.length;t++){const a=s.displayRecords[t];if(u){if(a.geometryType!==E.FILL&&a.geometryType!==E.LINE)continue;u.displayRecords.push(a);}const o=a.geometryType,n=i.addOrUpdate.tileBufferData.geometries[o],f=n.vertexBuffer,d=n.indexBuffer,p=l.geometries[o].vertexBuffer,m=l.geometries[o].indexBuffer,D=c.verticesFor(o),y=c.indicesFor(o);q(D,y,p,m,a,f,d),a.vertexFrom=D,a.indexFrom=y,c.needMore(o,a.vertexCount,a.indexCount),this.tileDisplayData.displayList.addToList(a);}u||(d.set(s.id,s),this.tileDisplayData.displayObjects.push(s));}this.tileBufferData=l;}getStrides(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const r=this.tileBufferData.geometries[t];e[t]={};for(const i in r.vertexBuffer)e[t][i]=r.vertexBuffer[i].stride;}return e}clone(){const e=new m$1;return e.tileBufferData=this.tileBufferData.clone(),e.tileDisplayData=this.tileDisplayData.clone(),e}_guessSize(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4);let r=0;for(let i=0;i<t;i++)r=Math.max(r,e[i].displayRecords.length);return 2*(12*e.length+e.length*r*40)}serialize(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new e$3(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}}static decode(e){const t=f$1.deserializeDisplayObjects(e),r={};for(const t in e.vertexBuffersMap)r[t]=r$4.decode(e.vertexBuffersMap[t]);return m$1.fromMeshData({displayObjects:t,vertexBuffersMap:r})}static fromMeshData(e){const t=new m$1,r$1=new r$2,i=new r;r$1.displayObjects=e.displayObjects;for(const t in e.vertexBuffersMap){const r=e.vertexBuffersMap[t];i.geometries[t].indexBuffer=r.indexBuffer,i.geometries[t].vertexBuffer=r.namedBuffers;}return t.tileDisplayData=r$1,t.tileBufferData=i,t}static bind(e,t){const r=new m$1;return r.tileDisplayData=e,r.tileBufferData=t,r}static create(e,t){const r$1=new m$1;r$1.tileDisplayData=new r$2,r$1.tileDisplayData.displayObjects=e;const i=[0,0,0,0,0],n=[0,0,0,0,0],f=[[],[],[],[],[]];for(const t of e)for(const e of t.displayRecords)f[e.geometryType].push(e),i[e.geometryType]+=e.meshData.vertexCount,n[e.geometryType]+=e.meshData.indexData.length;const l=new r,d=function(e){return [e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}(t);for(let e=0;e<5;e++){const t=new Uint32Array(n[e]),r=p(d[e],i[e]);s$2.writeAllMeshDataToBuffers(f[e],r,t),l.geometries[e]={indexBuffer:t,vertexBuffer:r};}return r$1.tileBufferData=l,r$1}static _align(e,t){const r=e%t;return 0===r?e:e+(t-r)}static _computeVertexAlignment(e){let t=!1,r=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(r=!0);return r?4:t?2:1}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
function i$2(t,i,r){if(!t.allDirty)if(null!=t.from&&null!=t.count){const s=Math.min(t.from,i),l=Math.max(t.from+t.count,i+r)-s;t.from=s,t.count=l;}else t.from=i,t.count=r;}class n$1{constructor(){this._dirties=K((()=>({indices:{from:null,count:null,allDirty:!1}})),(()=>({vertices:{from:null,count:null,allDirty:!1}})));}hasDirty(){for(const t of this._dirties)if(null!==t.data.indices.count||t.data.indices.allDirty)return !0;return !1}markAllClean(){for(const t of this._dirties){t.data.indices.from=null,t.data.indices.count=null,t.data.indices.allDirty=!1;for(const i in t.buffers)t.buffers[i].data.vertices.from=null,t.buffers[i].data.vertices.count=null,t.buffers[i].data.vertices.allDirty=!1;}}markAllDirty(){for(const t of this._dirties){t.data.indices.allDirty=!0;for(const i in t.buffers)t.buffers[i].data.vertices.allDirty=!0;}}forEach(t){for(let i=0;i<this._dirties.length;++i){const r=this._dirties[i],s={};for(const t in r.buffers){const i=r.buffers[t].data.vertices;(i.allDirty||null!=i.from&&null!=i.count&&i.count>0)&&(s[t]=i);}const l=r.data.indices;let n;n=l.allDirty||null!=l.from&&null!=l.count&&l.count>0?{indices:l,vertices:s}:{indices:null,vertices:s},(n.indices||Object.keys(n).length>0)&&t(n,i);}}markDirtyIndices(t,r,s){i$2(this._dirties[t].data.indices,r,s);}markDirtyVertices(t,r,s,l){i$2(this._dirties[t].buffers[r].data.vertices,s,l);}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
class e$1{constructor(e){this._largestRange=null,this._parent=e,this._updateLargestRange();}get largestRange(){return this._largestRange}rangeCreated(e){(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e);}rangeResized(e,t){e===this._largestRange?e.count<t&&this._updateLargestRange():(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e);}findBestRange(e){let t=this._parent._freeHead,n=null;for(;null!==t;)t.count>=e&&(!n||t.count-e<n.count-e)&&(n=t),t=t.next;return n}findAdjacentRanges(e,t){let n=!0,r=!1,s=null,o=this._parent._freeHead;for(;n&&!r;){const a=null!==s?s.from+s.count:0,l=null!==o?o.from:this._parent._size;e>=a&&e+t<=l?(n=!1,r=!0):null!==o?(s=o,o=o.next):n=!1;}return [s,o]}_updateLargestRange(){let e=null,t=this._parent._freeHead;for(;null!==t;)(!e||t.count>e.count)&&(e=t),t=t.next;this._largestRange=e;}}class t{constructor(t,n){this._allocated=0,this._size=t,this._freeHead=t>0?{from:0,count:t,prev:null,next:null}:null,this._bookKeeper=n||new e$1(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead);}allocate(e){const n=this._bookKeeper.findBestRange(e);if(null===n)return -1;const r=n.from,s=n.count;if(n.from+=e,n.count-=e,this._bookKeeper.rangeResized(n,r,s),this._allocated+=e,0===n.count){const e=null!==n.prev?this._freeHead:n.next;t._removeRange(n),this._freeHead=e;}return r}free(e,n){const[r,s]=this._bookKeeper.findAdjacentRanges(e,n),o={from:e,count:n,prev:r,next:s};if(null!==r&&(r.next=o),null!==s&&(s.prev=o),this._bookKeeper.rangeCreated(o),this._allocated-=n,null!==s&&o.from+o.count===s.from){const e=o.from,n=o.count;t._fuse(o,s),t._removeRange(s),this._bookKeeper.rangeResized(o,e,n),this._bookKeeper.rangeResized(s,void 0,0);}if(null!==r&&r.from+r.count===o.from){const e=r.from,n=r.count;t._fuse(r,o),t._removeRange(o),this._bookKeeper.rangeResized(r,e,n),this._bookKeeper.rangeResized(o,void 0,0);}this._freeHead=null!==o.prev?this._freeHead:o;}get fragmentation(){const e=this._size-this._allocated;if(0===e)return 0;return 1-this._bookKeeper.largestRange.count/e}static _removeRange(e){null!==e.prev?null!==e.next?(e.prev.next=e.next,e.next.prev=e.prev):e.prev.next=null:null!==e.next&&(e.next.prev=null);}static _fuse(e,t){e.count+=t.count,e.next=t.next,t.from+=t.count,t.count=0,null!==t.next&&(t.next.prev=e);}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const s$1=["FILL","LINE","MARKER","TEXT","LABEL"];class o{constructor(t$1,r,s,o){this._strides=t$1,this._displayList=r,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=s;for(const r in t$1){this._freeListsAndStorage[r]={vtxFreeList:o?new t(o):null,idxFreeList:o?new t(o):null,vertexBuffers:{},indexBuffer:o?new Uint32Array(o):null};for(const i in t$1[r])this._freeListsAndStorage[r].vertexBuffers[i]={data:o?R(o,t$1[r][i]):null,stride:t$1[r][i]};}}static fromTileData(e,r){const n=function(e){const t=e.getStrides(),r={};for(let e=0;e<t.length;e++)r[s$1[e]]=t[e];return r}(e),d=[0,0,0,0,0],a=[0,0,0,0,0],x=e.tileDisplayData.displayObjects;for(const e of x)for(const t of e.displayRecords)d[t.geometryType]=Math.max(d[t.geometryType],t.vertexFrom+t.vertexCount),a[t.geometryType]=Math.max(a[t.geometryType],t.indexFrom+t.indexCount);const u=new o(n,e.tileDisplayData.displayList,r,null);for(let r=0;r<e.tileBufferData.geometries.length;++r){const o=d[r],n=a[r],x=e.tileBufferData.geometries[r],f=s$1[r],l=u._storageFor(f),c=e.tileBufferData.geometries[r].indexBuffer;let m;l.indexBuffer=c,l.idxFreeList=new t(c.length),l.idxFreeList.allocate(n);for(const i in x.vertexBuffer){const s=e.tileBufferData.geometries[r].vertexBuffer[i];l.vertexBuffers[i].data=s.data,l.vertexBuffers[i].stride=s.stride;const o=C(s.stride),n=s.data.length*o/s.stride;m||(m=n);}l.vtxFreeList=new t(m),l.vtxFreeList.allocate(o);}return u}delete(e){const t=s$1[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0;}setMeshData(e,t,i,o,n){const d=s$1[e.geometryType];let a,x;e.meshData=null,void 0===e.vertexFrom?(x=t.vertexCount,a=this._allocateVertices(d,x)):t.vertexCount>e.vertexCount?(this._freeVertices(d,e.vertexFrom,e.vertexCount),x=t.vertexCount,a=this._allocateVertices(d,x)):t.vertexCount===e.vertexCount?(a=e.vertexFrom,x=e.vertexCount):(this._freeVertices(d,e.vertexFrom+t.vertexCount,e.vertexCount-t.vertexCount),a=e.vertexFrom,x=t.vertexCount);let u,f,l,c=!0;if(void 0===e.indexFrom?(u=n,l=t.indexCount,f=this._allocateIndices(d,l)):t.indexCount>e.indexCount?(u=this._displayList.removeFromList(e),this._freeIndices(d,e.indexFrom,e.indexCount),l=t.indexCount,f=this._allocateIndices(d,l)):t.indexCount===e.indexCount?(c=!1,f=e.indexFrom,l=e.indexCount):(u=this._displayList.removeFromList(e),this._freeIndices(d,e.indexFrom+t.indexCount,e.indexCount-t.indexCount),f=e.indexFrom,l=t.indexCount),-1!==a&&-1!==f){const s=this._storageFor(d);if(q(a,f,s.vertexBuffers,s.indexBuffer,t,i,o),e.vertexFrom=a,e.indexFrom=f,e.vertexCount=t.vertexCount,e.indexCount=t.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in i)this._dirtyMap.markDirtyVertices(e.geometryType,t,e.vertexFrom,e.vertexCount);}return c&&this._displayList.addToList(e,u),!0}return -1!==a&&this._freeVertices(d,a,x),-1!==f&&this._freeIndices(d,f,l),e.setMeshDataFromBuffers(t,i,o),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1}tryAddMeshData(e,t){const i=t.vertexBuffer,o=t.indexBuffer,n=s$1[e.geometryType],d=this._allocateVertices(n,e.vertexCount);if(-1===d)return this._freeVertices(n,d,e.vertexCount),!1;const a=this._allocateIndices(n,e.indexCount);if(-1===a)return this._freeVertices(n,d,e.vertexCount),this._freeIndices(n,a,e.indexCount),!1;const x=this._storageFor(n);if(q(d,a,x.vertexBuffers,x.indexBuffer,e,i,o),e.vertexFrom=d,e.indexFrom=a,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in i)this._dirtyMap.markDirtyVertices(e.geometryType,t,d,e.vertexCount);}return this._displayList.addToList(e),!0}_allocateVertices(e,t){const r=this._storageFor(e),i=r.vtxFreeList.allocate(t);if(-1===i)return -1;return r.vtxFreeList.fragmentation>.5?-1:i}_freeVertices(e,t,r){this._storageFor(e).vtxFreeList.free(t,r);}_freeIndices(e,t,r){this._storageFor(e).idxFreeList.free(t,r);}_allocateIndices(e,t){const r=this._storageFor(e),i=r.idxFreeList.allocate(t);if(-1===i)return -1;return r.idxFreeList.fragmentation>.5?-1:i}_storageFor(e){return this._freeListsAndStorage[e]}_stridesFor(e,t){return this._strides[e][t]}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
class f{constructor(t=400){this.duration=t,this._lastTime=0,this._elapsed=0,this._value=0,this._finished=!1;}get value(){return this._value}reset(){this._lastTime=0,this._elapsed=0,this._value=0;}step(){const t=performance.now();if(0===this._lastTime)return this._lastTime=t,this._value=0,!0;if(this._elapsed>=this.duration)return !0;const s=t-this._lastTime;return this._elapsed+=s,this._lastTime=t,this._value=Math.min(this._elapsed/this.duration,1),!1}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
class u$1{constructor(s){this.geometryMap=K((()=>({indexBuffer:i$4.createIndex(s,35044),vao:null})),((t,f)=>({vertexBuffer:i$4.createVertex(s,D$1[f])})));}dispose(){for(let e=0;e<5;e++){const t=this.geometryMap[e];if(t){t.data.vao&&t.data.vao.dispose(!1),t.data.indexBuffer&&t.data.indexBuffer.dispose();for(const e in t.buffers)t.buffers[e]&&t.buffers[e].data.vertexBuffer.dispose();}}}get(e){const t=this.geometryMap[e],r={};for(const e in t.buffers)r[e]=t.buffers[e].data.vertexBuffer;return {indexBuffer:t.data.indexBuffer,get vao(){return t.data.vao},set vao(e){t.data.vao=e;},vertexBufferMap:r}}has(e){return null!=this.geometryMap[e]}upload(e,t){t.forEach(((t,r)=>{this._upload(t,r,e);}));}_upload(e,t,r){if(e.indices&&(e.indices.allDirty?this._uploadIndices(r,t):null!=e.indices.from&&null!=e.indices.count&&this._uploadIndices(r,t,e.indices.from,e.indices.count)),e.vertices){const s=e.vertices;for(const e in s){const f=s[e];f.allDirty?this._uploadVertices(r,t,e):null!=f.from&&null!=f.count&&this._uploadVertices(r,t,e,f.from,f.count);}}}_uploadVertices(e,t,r,s,f){const a=this.geometryMap[t];if(!a)return;const i=e.geometries[t].vertexBuffer[r];if(!i)return;const o=i.stride,u=i.data.buffer;a.buffers[r]&&u.byteLength>0&&(null!=s&&null!=f?a.buffers[r].data.vertexBuffer.setSubData(u,s*o,s*o,(s+f)*o):a.buffers[r].data.vertexBuffer.setData(u));}_uploadIndices(e,t,r,s){const f=this.geometryMap[t];if(!f)return;const a=e.geometries[t].indexBuffer.buffer;f.data.indexBuffer&&a.byteLength>0&&(null!=r&&null!=s?f.data.indexBuffer.setSubData(a,4*r,4*r,4*(r+s)):f.data.indexBuffer.setData(a));}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const _=new Set;class m$2 extends r$5{constructor(t,s,a=!1){super(t,s,[o$1,o$1]),this._data=null,this._displayList=null,this._wglBuffers=null,this._deferPatches=!1,this._dirtyMap=new n$1,this._labelIndex=null,this._lastCommitTime=0,this._patchQueue=new e$4(100),this.fader=new f,this._dirty=!0,this._replaceBuffers=!1,this._uploadsLocked=!1,this._hasData=!1,this._invalidated=!1,this.transforms.labelMat2d=n$2(),this._ensureCorrectZOrder=a,this._deferPatches=!a;}destroy(){super.destroy(),this.clear();}get displayObjects(){var t;return null!=(t=this._displayObjects)?t:[]}get isDirty(){return this._dirty}get hasData(){return !!this._hasData}get labelIndex(){return this._labelIndex}set isDirty(t){this._dirty=t,this.requestRender();}getGeometry(t){return this._wglBuffers&&this._wglBuffers.has(t)?this._wglBuffers.get(t):null}getDisplayList(){return this._displayList}setTransform(t,e){super.setTransform(t,e);const i=this.transforms.labelMat2d,a=t.getScreenTransform(i,e),h=n$4();D$2(h,this.coords,a),n$3(i),h$1(i,i,h),u$2(i,t.viewMat2d,i);}setData(t){const e=t.addOrUpdate,s=t.remove;t.clear&&(this.clear(),this._patchQueue.clear(),this._hasData=!1),"replace"===t.type&&(this._replaceBuffers=!0,this._patchQueue.clear(),this._data=null),!this._data&&e&&e.tileDisplayData.displayObjects.length?(e.tileDisplayData.computeDisplayList(this._ensureCorrectZOrder),this._dirtyMap=new n$1,this._dispRecStore=o.fromTileData(e,this._dirtyMap),this._data=e,this._dirtyMap.markAllDirty(),this._hasData=!0,t.end&&this.ready()):this._data&&(e&&e.tileDisplayData.displayObjects.length||s.length)?this._deferPatches?this._patchQueue.enqueue(t):this._doPatchData(t):t.end&&this.ready(),t.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change");}lockUploads(){this._uploadsLocked=!0;}unlockUploads(){this._uploadsLocked=!1,this.requestRender();}commitChanges(e){if(!e.time||e.time!==this._lastCommitTime){if(this._lastCommitTime=e.time,this.fader.step()||this.requestRender(),this._patchQueue.size){const e=this._patchQueue.dequeue();u$3(e)&&(e.end&&this.ready(),this._doPatchData(e),this.requestRender(),this._hasData=!0);}if(this._uploadsLocked)this.requestRender();else if(this.visible&&this._data){if(this._replaceBuffers)for(this._wglBuffers&&this._wglBuffers.dispose(),this._wglBuffers=null,this._replaceBuffers=!1;this._patchQueue.size;){const e=this._patchQueue.dequeue();u$3(e)&&(e.end&&this.ready(),this._doPatchData(e),this._hasData=!0);}this._wglBuffers||(this._wglBuffers=new u$1(e.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._rebuildLabelIndex(),this._dirtyMap.markAllClean());}}}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null);}_doPatchData(t){try{if("new"===t.type){if(!t.addOrUpdate)return;this._invalidated=!0;const e=this._bulkAddFeatures(t);e&&(this._dirtyMap.markAllDirty(),this._data.reshuffleBulkAdd(t,e.objectIndex,e.recordIndex),this._dispRecStore=o.fromTileData(this._data,this._dirtyMap));}else this._invalidated=!0,this._patchData(t)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=o.fromTileData(this._data,this._dirtyMap));}catch(t){}this.requestRender();}_rebuildLabelIndex(){var t,e;if(!(null==(t=this._data)||null==(e=t.tileBufferData.geometries[E.LABEL])||!e.indexBuffer.length)){this.isDirty=!0,this._labelIndex=this._initLabelIndex();for(const t of this.displayObjects)for(const e of t.metrics)this._insertIntoLabelIndex(e);}}_insertIntoLabelIndex(t){if(t.xBucket<0||t.yBucket<0||t.yBucket>3||t.xBucket>3)return;this.labelIndex[t.yBucket][t.xBucket].push(t);}_initLabelIndex(){const t=[];for(let e=0;e<o$1/p$2;e++){t.push([]);for(let s=0;s<o$1/p$2;s++)t[e].push([]);}return t}_bulkAddFeatures(t){const e=t.addOrUpdate.tileDisplayData.displayObjects,s=this._data.tileDisplayData.displayObjects,i=this._data.tileDisplayData.displayObjectRegistry;for(let a=0;a<e.length;a++){const r=e[a],l=i.get(r.id);for(let e=0;e<r.displayRecords.length;++e){const s=r.displayRecords[e];if(l){if(s.geometryType!==E.FILL&&s.geometryType!==E.LINE)continue;l.displayRecords.push(s);}const i=t.addOrUpdate.tileBufferData.geometries[s.geometryType];if(!this._dispRecStore.tryAddMeshData(s,i))return {objectIndex:a,recordIndex:e}}l||(i.set(r.id,r),s.push(r));}return null}_patchData(t){let e=!0;const s=t.addOrUpdate&&t.addOrUpdate.tileDisplayData&&t.addOrUpdate.tileDisplayData.displayObjects||[],i=(t.remove||[]).slice();for(const t of s)null!=t.insertAfter&&i.push(t.id);for(const t of i){const e=this._data.tileDisplayData.displayObjectRegistry.get(t);if(e){this._data.tileDisplayData.displayList.removeFromList(e.displayRecords);for(const t of e.displayRecords)this._dispRecStore.delete(t);this._data.tileDisplayData.displayObjectRegistry.delete(t);const s=this._data.tileDisplayData.displayObjects.indexOf(e);this._data.tileDisplayData.displayObjects.splice(s,1);}}for(const i of s){let s,a=this._data.tileDisplayData.displayObjectRegistry.get(i.id);if(a){const t=a.displayRecords;a.set(i),a.displayRecords=t;const e=a.displayRecords.length;for(let t=0;t<e;++t){const e=a.displayRecords[t],s=i.displayRecords[t];(t>=i.displayRecords.length||e.geometryType!==s.geometryType||e.symbolLevel!==s.symbolLevel||e.zOrder!==s.zOrder||e.materialKey!==s.materialKey)&&(this._dispRecStore.delete(a.displayRecords[t]),t<i.displayRecords.length&&(a.displayRecords[t]=void 0));}a.displayRecords.length=i.displayRecords.length,a.metrics=i.metrics;}else {let t;a=i.copy(),a.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(i.id,a);const e=this._data.tileDisplayData.displayObjects;if(null!=a.insertAfter)if(s={},a.insertAfter>=0){const s=this._data.tileDisplayData.displayObjectRegistry.get(a.insertAfter);s?(t=e.indexOf(s)+1,t<e.length?e.splice(t,0,a):(e.push(a),t=e.length)):(e.push(a),t=e.length);}else e.unshift(a),t=0;else e.push(a),t=e.length;if(s){let a;if(this._data.tileDisplayData.displayList.unified)a=i.displayRecords.length>0?1:0;else {_.clear();for(const t of i.displayRecords){const e=this._data.tileDisplayData.displayList.getDPInfoType(t.geometryType);_.add(e);}a=_.size;}let r=0;for(let i=t-1;i>=0&&r<a;--i)for(let t=e[i].displayRecords.length-1;t>=0&&r<a;--t){const a=e[i].displayRecords[t],l=this._data.tileDisplayData.displayList.getDPInfoType(a.geometryType);s[l]||(s[l]=a,++r);}}}const r=i.displayRecords.length;for(let l=0;l<r;++l){const r=i.displayRecords[l];let d=a.displayRecords[l];d?(d.meshData=r.meshData,d.materialKey=r.materialKey):(d=r.copy(),d.vertexFrom=void 0,d.indexFrom=void 0,a.displayRecords[l]=d);const h=r.geometryType,o=this._data.tileDisplayData.displayList.getDPInfoType(h),p=t.addOrUpdate.tileBufferData.geometries[h],c=p.vertexBuffer,n=p.indexBuffer;let y;s&&(y=s[o]?this._data.tileDisplayData.displayList.splitAfter(s[o]):-1),e=this._dispRecStore.setMeshData(d,r,c,n,y)&&e,s&&null!=d.indexFrom&&null!=d.indexFrom&&(s[o]=d);}}return e}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
const z=i$3.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),D=n$5(l$2,z),S=t=>2147483647&t;class U{constructor(t,e,i){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:s,pixelType:r,textureOnly:h}=t,o=H(r);this.shared=i,this.pixelType=r,this.size=e,this.textureOnly=h,h||(this.data=new o(f$2(s))),this._resetRange();}destroy(){d$1(this._texture,(t=>t.dispose()));for(const t in this._fbos)d$1(this._fbos[t],(e=>{"0"===t&&e.detachColorTexture(),e.dispose();})),this._fbos[t]=null;this._texture=null;}get _textureDesc(){return {target:3553,wrapMode:33071,pixelFormat:6408,dataType:this.pixelType,samplingMode:9728,width:this.size,height:this.size}}setData(t,e,i){const s=S(t),r=f$2(this.data),h=s*this.texelSize+e;!r||h>=r.length||(r[h]=i,this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,s));}getData(t,i){if(t$1(this.data))return null;const s=S(t)*this.texelSize+i;return !this.data||s>=this.data.length?null:this.data[s]}getTexture(t){return c$2(this._texture,(()=>this._initTexture(t)))}getFBO(t,i=0){if(t$1(this._fbos[i])){const e={colorTarget:0,depthStencilTarget:0},s=0===i?this.getTexture(t):this._textureDesc;this._fbos[i]=new r$6(t,e,s);}return this._fbos[i]}get locked(){return !(5121!==this.pixelType||!this.shared||this.textureOnly||!t$2("esri-atomics")||!this.data)&&1===Atomics.load(this.data,0)}updateTexture(t){if(!this.locked)try{const e=this.dirtyStart,i=this.dirtyEnd;if(e>i)return;this._resetRange();const s=f$2(this.data).buffer,r=this.getTexture(t),h=4,o=(e-e%this.size)/this.size,n=(i-i%this.size)/this.size,d=o,l=this.size,p=n,x=o*this.size*h,c=(l+p*this.size)*h-x,_=H(this.pixelType),g=_.BYTES_PER_ELEMENT;try{new _(s,x*g,c);}catch(t){console.debug(t);}const f=new _(s,x*g,c),b=this.size,m=p-d+1;if(m>this.size)return void z.error(new s$3("mapview-webgl","Out-of-bounds index when updating AttributeData"));r.updateData(0,0,d,b,m,f);}catch(t){console.debug(t);}}update(t){const{data:e,start:i,end:r}=t;if(u$3(e)){const s=this.data,r=i*this.texelSize;for(let i=0;i<e.length;i++){const a=1<<i%this.texelSize;t.layout&a&&(s[r+i]=e[i]);}}this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,r);}resize(t,e){const i=this.size;if(this.size=e,this.textureOnly)return void(i!==this.size&&(this._lastTexture=this._texture,this._texture=null));const s=H(this.pixelType);this.destroy(),this.data=new s(f$2(t.buffer));}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0;}_initTexture(t){const e=new i$5(t,this._textureDesc,c$2(this.data,void 0));if(u$3(this._lastTexture)&&this._fbos[0]){const i=this._lastTexture.descriptor.width,s=this._lastTexture.descriptor.height,r=this._lastTexture.descriptor.dataType,a=this._lastTexture.descriptor.pixelFormat,h=this.getFBO(t),o=G$1(r),n=new(H(r))(new ArrayBuffer(i*s*o*this.texelSize)),d=t.getBoundFramebufferObject(),{x:u,y:l,width:p,height:x}=t.getViewport();t.bindFramebuffer(h),h.readPixels(0,0,i,s,a,r,n),e.updateData(0,0,0,2*i,s/2,n),t.setViewport(u,l,p,x),t.bindFramebuffer(d);}return this.destroy(),this._texture=e,this._texture}}class j{constructor(){this._initialized=!1,this._forceNextUpload=!1,this._locked=!1;}initialize(t){const{blocks:r,shared:a,size:h}=t;if(this.shared=a,this.size=h,D("Initializing AttributeStoreView",t),t$1(this._data))this._data=h$2(r,(t=>new U(t,h,a)));else for(let t=0;t<this._data.length;t++){const i=this._data[t],o=r[t];u$3(o)&&(t$1(i)?this._data[t]=new U(o,h,a):i.resize(o,h));}this._initialized=!0;}destroy(){d$1(this._data,(t=>h$2(t,(t=>t.destroy())))),d$1(this._defaultTexture,(t=>t.dispose()));}getBlock(t){if(t$1(this._data))return null;return this._data[t]}setLabelMinZoom(t,e){this.setData(t,0,1,e);}getLabelMinZoom(t){return this.getData(t,0,1,255)}getFilterFlags(t){return this.getData(t,0,0,0)}getVVSize(t){return this.getData(t,K$1,0,0)}getData(t,i,r,h){if(!this._data)return 0;const o=f$2(this._data)[i];if(t$1(o))return 0;const n=o.getData(t,r);return u$3(n)?n:h}setData(t,e,i,s){const r=f$2(this._data)[e];f$2(r).setData(t,i,s);}lockTextureUpload(){this._locked=!0;}unlockTextureUpload(){this._locked=!1;}forceTextureUpload(){this._forceNextUpload=!0;}async requestUpdate(t){if(this._pendingAttributeUpdate)return void z.error(new s$3("mapview-webgl","Tried to update attribute data with a pending update"));const e=G();return D("AttributeStoreView Update Requested",t),this._pendingAttributeUpdate={data:t,resolver:e},e.promise}update(){if(this._initialized&&u$3(this._pendingAttributeUpdate)){const{data:t,resolver:e}=this._pendingAttributeUpdate,i=f$2(this._data);for(let e=0;e<t.blocks.length;e++){const s=t.blocks[e],a=i[e];d$1(a,(t=>d$1(s,(i=>{D(`Updating block ${e}`,i),t.update(i);}))));}this._pendingAttributeUpdate=null,e();}}bindTextures(t){this.update();const e=this._getDefaultTexture(t);if(!this._initialized)return t.bindTexture(e,A),t.bindTexture(e,B),t.bindTexture(e,C$1),void t.bindTexture(e,D$3);const i=f$2(this._data);this._locked&&!this._forceNextUpload||(y$1(i,(e=>e.updateTexture(t))),this._forceNextUpload=!1),t.bindTexture(a(i[0],e,(e=>e.getTexture(t))),A),t.bindTexture(a(i[1],e,(e=>e.getTexture(t))),B),t.bindTexture(a(i[2],e,(e=>e.getTexture(t))),C$1),t.bindTexture(a(i[3],e,(e=>e.getTexture(t))),D$3);}_getDefaultTexture(t){if(t$1(this._defaultTexture)){const e={wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1};this._defaultTexture=new i$5(t,e,new Uint8Array(4));}return this._defaultTexture}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
function c$1(e,t){const i=t.length;if(e<t[0].value||1===i)return t[0].size;for(let s=1;s<i;s++)if(e<t[s].value){const i=(e-t[s-1].value)/(t[s].value-t[s-1].value);return t[s-1].size+i*(t[s].size-t[s-1].size)}return t[i-1].size}function h(e,t,i=0){if(t$1(t))return e[i+0]=0,e[i+1]=0,e[i+2]=0,void(e[i+3]=0);const{r:a,g:o,b:l,a:r}=t;e[i+0]=a*r/255,e[i+1]=o*r/255,e[i+2]=l*r/255,e[i+3]=r;}class p$1{constructor(){this.symbolLevels=[],this.vvColorValues=new Float32Array(8),this.vvColors=new Float32Array(32),this.vvOpacityValues=new Float32Array(8),this.vvOpacities=new Float32Array(8),this.vvSizeMinMaxValue=new Float32Array(4),this.ddColors=new Float32Array(32),this.ddBackgroundColor=new Float32Array(4),this.ddActiveDots=new Float32Array(8),this._vvMaterialParameters={vvSizeEnabled:!1,vvColorEnabled:!1,vvRotationEnabled:!1,vvRotationType:"geographic",vvOpacityEnabled:!1};}getSizeVVFieldStops(i){const s=this._vvSizeFieldStops;switch(s.type){case"static":return s;case"level-dependent":return c$2(s.levels[i],(()=>{let e=1/0,a=0;for(const t in s.levels){const s=parseFloat(t),o=Math.abs(i-s);o<e&&(e=o,a=s);}if(e===1/0)return {sizes:new Float32Array([0,0,0,0,0,0]),values:new Float32Array([0,0,0,0,0,0])};const o=i-a,l=Math.pow(2,o/2),r=f$2(s.levels[a]),n=new Float32Array(r.values);return n[2]*=l,n[3]*=l,{sizes:f$2(r.sizes),values:n}}))}}get vvMaterialParameters(){return this._vvMaterialParameters}update(e){u$3(this._vvInfo)&&this._updateVisualVariables(this._vvInfo.vvRanges,e);}setInfo(e,t,s){switch(u$3(s)&&s.forEach((e=>this._updateEffects(e))),this._vvInfo=t,e.type){case"dot-density":this._updateDotDensityInfo(e);}}getVariation(){return {ddDotBlending:this.ddDotBlending,outsideLabelsVisible:this.outsideLabelsVisible,oesTextureFloat:r$7().supportsTextureFloat}}getVariationHash(){return (this.ddDotBlending?1:0)|(this.outsideLabelsVisible?1:0)<<1}_updateEffects(e){u$3(e)&&e.filter&&e.filter.enabled&&(this.outsideLabelsVisible=e.excludedLabelsVisible);}_updateVisualVariables(e,t){const i=this._vvMaterialParameters;if(i.vvOpacityEnabled=!1,i.vvSizeEnabled=!1,i.vvColorEnabled=!1,i.vvRotationEnabled=!1,!e)return;const s=e.size;if(s){if(i.vvSizeEnabled=!0,s.minMaxValue){const e=s.minMaxValue;let i,a;if(N(e.minSize)&&N(e.maxSize))if(P(e.minSize)&&P(e.maxSize))i=t$3(e.minSize),a=t$3(e.maxSize);else {const s=t.scale;i=t$3(c$1(s,e.minSize.stops)),a=t$3(c$1(s,e.maxSize.stops));}this.vvSizeMinMaxValue.set([e.minDataValue,e.maxDataValue,i,a]);}if(s.scaleStops&&(this.vvSizeScaleStopsValue=t$3(c$1(t.scale,s.scaleStops.stops))),s.unitValue){const e=K$2(t.spatialReference)/m$3[s.unitValue.unit];this.vvSizeUnitValueToPixelsRatio=e/t.resolution;}s.fieldStops&&(this._vvSizeFieldStops=s.fieldStops);}const a=e.color;a&&(i.vvColorEnabled=!0,this.vvColorValues.set(a.values),this.vvColors.set(a.colors));const n=e.opacity;n&&(i.vvOpacityEnabled=!0,this.vvOpacityValues.set(n.values),this.vvOpacities.set(n.opacities));const v=e.rotation;v&&(i.vvRotationEnabled=!0,i.vvRotationType=v.type);}_updateDotDensityInfo(e){const t=e.attributes;this.ddDotValue=e.dotValue,this.ddDotScale=e.referenceScale,this.ddDotSize=e.dotSize,this.ddDotBlending=e.dotBlendingEnabled,this.ddSeed=e.seed;for(let e=0;e<r$8;e++){const i=e>=t.length?new o$2([0,0,0,0]):t[e].color;h(this.ddColors,i,4*e);}for(let t=0;t<8;t++)this.ddActiveDots[t]=t<e.attributes.length?1:0;h(this.ddBackgroundColor,e.backgroundColor);}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
class l$1 extends d$2{constructor(e){super(e),this._rendererInfo=new p$1,this._materialItemsRequestQueue=new s$4,this.attributeView=new j;}destroy(){this.removeAllChildren(),this.children.forEach((e=>e.destroy())),this.attributeView.destroy(),this._materialItemsRequestQueue.clear();}setRendererInfo(e,t,r){this._rendererInfo.setInfo(e,t,r),this.requestRender();}async getMaterialItems(t,r){if(!t||0===t.length)return null;const s=G();return this._materialItemsRequestQueue.push({items:t,abortOptions:r,resolver:s}),this.requestRender(),s.promise}onTileData(e,t){if(t.addOrUpdate&&"tileDisplayData"in t.addOrUpdate)e.setData(t);else {const r=t.addOrUpdate&&m$1.decode(t.addOrUpdate),s={...t,addOrUpdate:r};e.setData(s);}this.contains(e)||this.addChild(e),this.requestRender();}onTileError(e){e.clear(),this.contains(e)||this.addChild(e);}doRender(e){if(e.context.capabilities.textureFloat,e.context.capabilities.vao,this._materialItemsRequestQueue.length>0){let t=this._materialItemsRequestQueue.pop();for(;t;)this._processMaterialItemRequest(e,t),t=this._materialItemsRequestQueue.pop();}super.doRender(e);}renderChildren(e){for(const t of this.children)t.commitChanges(e);this._rendererInfo.update(e.state),super.renderChildren(e);}createTile(e){const t=this._tileInfoView.getTileBounds(t$4(),e);return new m$2(e,t)}destroyTile(e){this.removeChild(e),e.destroy();}createRenderParams(e){return {...super.createRenderParams(e),rendererInfo:this._rendererInfo,attributeView:this.attributeView}}_processMaterialItemRequest(e,{items:r,abortOptions:s,resolver:i}){const{painter:o,pixelRatio:a}=e,n=r.map((e=>o.textureManager.rasterizeItem(e.symbol,a,e.glyphIds,s)));f$3(n).then((e=>{if(!this.stage)return void i.reject();const t=e.map(((e,t)=>({id:r[t].id,mosaicItem:e})));i.resolve(t);}),i.reject);}}

export { m$1 as a, l$1 as l, m$2 as m };
