import { q as e, y, bZ as z, e5 as e$1, r as i, d8 as g, aS as y$1, cP as n, bI as f, ah as w, eX as f$1 } from './index.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
let u=class extends g{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null;}readFeatures(e,r){(e||[]).forEach((e=>{this._decompressFeatureGeometry(e,r.summary.envelope.spatialReference);}));const o=y$1.fromJSON(r.spatialReference);return e.map((e=>{const r=n.fromJSON(e),s=e.geometry&&e.geometry.spatialReference;return r.geometry&&!s&&(f(r.geometry).spatialReference=o),r.strings=e.strings,r.events=(e.events||[]).map((t=>{const r=new n({geometry:new w({x:t.point.x,y:t.point.y,z:t.point.z,hasZ:void 0!==t.point.z,spatialReference:e.geometry&&e.geometry.spatialReference}),attributes:{ETA:t.ETA,arriveTimeUTC:t.arriveTimeUTC}});return r.strings=t.strings,r})),r}))}get mergedGeometry(){if(!this.features)return null;const e=this.features.map((({geometry:e})=>f(e))),r=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,r)}get strings(){return this.features.map((({strings:e})=>e))}_decompressFeatureGeometry(e,t){e.geometry=this._decompressGeometry(e.compressedGeometry,t);}_decompressGeometry(e,t){let r=0,o=0,s=0,a=0;const p=[];let n,i,m,l,u,c,y,f,d=0,g=0,h=0;if(u=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),u||(u=[]),0===parseInt(u[d],32)){d=2;const e=parseInt(u[d],32);d++,c=parseInt(u[d],32),d++,1&e&&(g=u.indexOf("|")+1,y=parseInt(u[g],32),g++),2&e&&(h=u.indexOf("|",g)+1,f=parseInt(u[h],32),h++);}else c=parseInt(u[d],32),d++;for(;d<u.length&&"|"!==u[d];){n=parseInt(u[d],32)+r,d++,r=n,i=parseInt(u[d],32)+o,d++,o=i;const e=[n/c,i/c];g&&(l=parseInt(u[g],32)+s,g++,s=l,e.push(l/y)),h&&(m=parseInt(u[h],32)+a,h++,a=m,e.push(m/f)),p.push(e);}return {paths:[p],hasZ:g>0,hasM:h>0,spatialReference:t}}_mergePolylinesToSinglePath(e,t){let r=[];(e||[]).forEach((e=>{e.paths.forEach((e=>{r=r.concat(e);}));}));const o=[];let s=[0,0];return r.forEach((e=>{e[0]===s[0]&&e[1]===s[1]||(o.push(e),s=e);})),new f$1({paths:[o]},t)}};e([y({type:z,json:{read:{source:"summary.envelope"}}})],u.prototype,"extent",void 0),e([y()],u.prototype,"features",void 0),e([e$1("features")],u.prototype,"readFeatures",null),e([y()],u.prototype,"geometryType",void 0),e([y({readOnly:!0,dependsOn:["features","extent.spatialReference"]})],u.prototype,"mergedGeometry",null),e([y()],u.prototype,"routeId",void 0),e([y()],u.prototype,"routeName",void 0),e([y({value:null,readOnly:!0,dependsOn:["features"]})],u.prototype,"strings",null),e([y({json:{read:{source:"summary.totalDriveTime"}}})],u.prototype,"totalDriveTime",void 0),e([y({json:{read:{source:"summary.totalLength"}}})],u.prototype,"totalLength",void 0),e([y({json:{read:{source:"summary.totalTime"}}})],u.prototype,"totalTime",void 0),u=e([i("esri.tasks.support.DirectionsFeatureSet")],u);var c=u;

export { c };
