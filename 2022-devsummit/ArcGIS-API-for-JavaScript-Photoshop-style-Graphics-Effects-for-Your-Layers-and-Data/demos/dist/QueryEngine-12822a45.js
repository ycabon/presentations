import { fs as e, s as s$1, g as t$1, bz as I, bA as E, h as r$2, bK as et, ft as H$1, fj as a$1, fu as h$1, fv as a$2, fw as i, co as d$2, fx as s$4, fy as l$1, bf as l$2, fz as A, fA as D$2, fB as f$2, cN as H$2, cU as v, cS as d$3, fC as C, fD as u$1, aG as s$5, bk as o$1, aH as c$3, aJ as c$4, aA as u$2 } from './_virtual_index-49b2bc11.js';
import { WhereClause as m } from './WhereClause-dc0be1a8.js';
import { g, M, f as f$3 } from './projectionSupport-f94b815a.js';
import { t as t$2 } from './QueryEngineCapabilities-0bbc1064.js';
import { s as s$3 } from './quantizationUtils-65d5f437.js';
import { T, s as s$2, m as m$1, c as c$2, V as V$1, g as g$1, h, y, D as D$1, z as z$1, f as f$1, d as d$1 } from './utils-af32d0af.js';
import { z, n as n$1, J as J$1, O, t as t$3, P, U as U$1, v as v$1, I as I$1, a as P$1 } from './spatialQuerySupport-a3fb0dc1.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
class c$1{constructor(e$1,c){this._cache=new e(e$1),this._invalidCache=new e(c);}get(t,c){const i=`${c.uid}:${t}`,r=this._cache.get(i);if(r)return r;if(void 0!==this._invalidCache.get(i))return null;try{const r=m.create(t,c);return this._cache.put(i,r),r}catch{return this._invalidCache.put(i,null),null}}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
const s=new c$1(50,500),n="feature-store:unsupported-query",t=" as ",r$1=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function o(i,t){if(!t)return !0;const r=s.get(t,i);if(!r)throw new s$1(n,"invalid SQL expression",{where:t});if(!r.isStandardized)throw new s$1(n,"where clause is not standard",{where:t});return c(i,r.fieldNames,"where clause contains missing fields"),!0}function a(i,t,r){if(!t)return !0;const o=s.get(t,i);if(!o)throw new s$1(n,"invalid SQL expression",{having:t});if(!o.isAggregate)throw new s$1(n,"having does not contain a valid aggregate function",{having:t});const a=o.fieldNames;c(i,a,"having contains missing fields");if(!o.getExpressions().every((e=>{const{aggregateType:s,field:n}=e,t=i.has(n)&&i.get(n).name;return r.some((e=>{const{onStatisticField:n,statisticType:r}=e;return (i.has(n)&&i.get(n).name)===t&&r.toLowerCase().trim()===s}))})))throw new s$1(n,"expressions in having should also exist in outStatistics",{having:t});return !0}function l(e,i){return e?s.get(e,i):null}function c(i,s,t,r=!0){const o=[];for(const u of s)if("*"!==u&&!i.has(u))if(r){const s=d(u);try{const t=l(s,i);if(!t)throw new s$1(n,"invalid SQL expression",{where:s});if(!t.isStandardized)throw new s$1(n,"expression is not standard",{clause:t});c(i,t.fieldNames,"expression contains missing fields");}catch(a){const e=a&&a.details;if(e&&(e.clause||e.where))throw a;e&&e.missingFields?o.push(...e.missingFields):o.push(u);}}else o.push(u);if(o.length)throw new s$1(n,t,{missingFields:o})}function d(e){return e.split(t)[0]}function u(e){return e.split(t)[1]}function f(e,i){const s=i.get(e);return !!s&&!r$1.has(s.type)}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
class r{constructor(t,a,r){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues,this.fieldsIndex=r,this.featureAdapter=a;const l$1=t.outFields;if(l$1&&-1===l$1.indexOf("*")){this.outFields=l$1;let t=0;for(const a of l$1){const l$1=d(a),u$1=this.fieldsIndex.get(l$1),n=u$1?null:l(l$1,r),c=u$1?u$1.name:u(a)||"FIELD_EXP_"+t++;this._fieldDataCache.set(a,{alias:c,clause:n});}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){const a=i?i.name:e;let r=null;return this._fieldDataCache.has(a)?r=this._fieldDataCache.get(a).clause:i||(r=l(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:r})),i?this.featureAdapter.getAttribute(t,a):r.calculateValue(t,this.featureAdapter)}getNormalizedValue(t,e){const s=e.normalizationType,i=e.normalizationTotal;let r=this.getFieldValue(t,e.field,e.fieldInfo);if(s&&Number.isFinite(r)){const l=this.getFieldValue(t,e.normalizationField,e.normalizationFieldInfo);r=T(r,s,l,i);}return r}getExpressionValue(t,e,s){const i={attributes:this.featureAdapter.getAttributes(t)},a=s.createExecContext(i,e.viewInfo);return s.executeFunction(e.compiledFunc,a)}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:l(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testFeature(t,this.featureAdapter)}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:l(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testSet(t,this.featureAdapter)}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const s={};for(const i of e){const{alias:e,clause:a}=this._fieldDataCache.get(i);s[e]=a?a.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,e);}return s}_processAttributesForDistinctValues(e){if(t$1(e)||!this.returnDistinctValues)return e;const s=this.outFields,i=[];if(s)for(const t of s){const{alias:s}=this._fieldDataCache.get(t);i.push(e[s]);}else for(const t in e)i.push(e[t]);const a=`${(s||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++r),r>1?null:e}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
class S{constructor(e,t,i){this.items=e,this.queryGeometry=t,this.definitionExpression=i.definitionExpression,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.fieldsIndex=i.fieldsIndex,this.timeInfo=i.timeInfo,this.featureAdapter=i.featureAdapter,this.aggregateAdapter=i.aggregateAdapter;}get size(){return this.items.length}createQueryResponseForCount(e){const t=new r(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:s}=e;if(!!!(null==i?void 0:i.length))return 1;const a=new Map,r$1=new Map,o=new Set,l=e.outStatistics;for(const n of l){const{statisticType:e}=n,l="exceedslimit"!==e?n.onStatisticField:void 0;if(!r$1.has(l)){const e=[];for(const s of i){const i=this._getAttributeValues(t,s,a);e.push(i);}r$1.set(l,this._calculateUniqueValues(e,t.returnDistinctValues));}const u=r$1.get(l);for(const i in u){const{data:e,items:a}=u[i],r=e.join(",");s&&!t.validateItems(a,s)||o.add(r);}}return o.size}createQueryResponse(e){let t;if(e.outStatistics){t=e.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(e):this._createStatisticsQueryResponse(e);}else t=this._createFeatureQueryResponse(e);return e.returnQueryGeometry&&(I(e.outSR)&&!E(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=z({spatialReference:e.outSR,...g(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR)}):t.queryGeometry=z({spatialReference:e.outSR,...this.queryGeometry})),t}createSnappingResponse(t,i){const s=this.featureAdapter,a=R(this.hasZ,this.hasM),{x:r,y:n}=t.point,o="number"==typeof t.distance?t.distance:t.distance.x,l="number"==typeof t.distance?t.distance:t.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,d=this.getPointCreator(t.point,this.spatialReference,i);for(const m of this.items){const i=s.getGeometry(m);if(t$1(i))continue;const{coords:h,lengths:f}=i;if(1&t.types){let e=0;for(let t=0;t<f.length;t++){const i=f[t];for(let t=0;t<i;t++,e+=a){const c=h[e],f=h[e+1];if(t!==i-1){const t=h[e+a],i=h[e+a+1],{x:p,y}=_(r,n,c,f,t,i),g=(r-p)/o,I=(n-y)/l,x=g*g+I*I;x<=1&&u.candidates.push({type:"edge",objectId:s.getObjectId(m),distance:Math.sqrt(x),target:d(p,y),start:d(c,f),end:d(t,i)});}}}}if(2&t.types){const e=c?h.length-a:h.length;for(let t=0;t<e;t+=a){const e=h[t],i=h[t+1],a=(r-e)/o,c=(n-i)/l,f=a*a+c*c;f<=1&&u.candidates.push({type:"vertex",objectId:s.getObjectId(m),distance:Math.sqrt(f),target:d(e,i)});}}}return u.candidates.sort(((e,t)=>e.distance-t.distance)),u}getPointCreator(e,i,s){const r=r$2(s)&&!E(i,s)?e=>g(e,i,s):e=>e;return null!=e.z&&null!=e.m?(t,i)=>r({x:t,y:i,z:e.z,m:e.m}):null!=e.z?(t,i)=>r({x:t,y:i,z:e.z}):null!=e.m?(t,i)=>r({x:t,y:i,m:e.m}):(e,t)=>r({x:e,y:t})}executeAttributesQuery(e){const t=l(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let i=0;const s=[];for(const e of this.items)t.testFeature(e,this.featureAdapter)&&(s[i++]=e);const a=new S(s,this.queryGeometry,this);return a.definitionExpression=e.where,Promise.resolve(a)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(t){if(!t.aggregateIds||!t.aggregateIds.length||t$1(this.aggregateAdapter))return Promise.resolve(this);const i=new Set;for(const e of t.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(e).forEach((e=>i.add(e)));}const s=this.featureAdapter.getObjectId;return Promise.resolve(new S(this.items.filter((e=>i.has(s(e)))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),i=this.featureAdapter.getObjectId;return Promise.resolve(new S(this.items.filter((e=>t.has(i(e)))),this.queryGeometry,this))}executeTimeQuery(e){const i=n$1(this.timeInfo,e.timeExtent,this.featureAdapter);if(!r$2(i))return Promise.resolve(this);const s=this.items.filter(i);return Promise.resolve(new S(s,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:i}=this.timeInfo,s=i||t,a=new Map,r=this.featureAdapter.getAttribute;for(const o of this.items){const t=r(o,e),i=r(o,s),n=a.get(t);(!n||i>r(n,s))&&a.set(t,o);}const n=Array.from(a.values());return Promise.resolve(new S(n,this.queryGeometry,this))}async project(e){if(!e||E(this.spatialReference,e))return this;const t=this.featureAdapter,i=(await M(this.items.map((e=>J$1(this.geometryType,this.hasZ,this.hasM,t.getGeometry(e)))),this.spatialReference,e)).map(((e,i)=>t.cloneWithGeometry(this.items[i],et(e,this.hasZ,this.hasM))));return new S(i,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,minValue:o,maxValue:l,scale:u}=t,c=this.fieldsIndex.isDateField(i),d=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:u}),m=s$2({normalizationType:r,normalizationField:a,minValue:o,maxValue:l}),h=this.fieldsIndex.get(i),x={value:.5,fieldType:null==h?void 0:h.type},T=H$1(h)?m$1({values:d,supportsNullCount:m,percentileParams:x}):c$2({values:d,minValue:o,maxValue:l,useSampleStdDev:!r,supportsNullCount:m,percentileParams:x});return V$1(T,c)}async createUniqueValuesResponse(e,t){const{field:i,valueExpression:s,domain:a,returnAllCodedValues:r,scale:n}=t,o=await this._getDataValues(e,{field:i,valueExpression:s,scale:n}),l=g$1(o);return h(l,a,r)}async createClassBreaksResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d,scale:m}=t,h=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:m}),f=y(h,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d});return D$1(f,o)}async createHistogramResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d,scale:m}=t,h=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:m});return z$1(h,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=t[1]&&"desc"===t[1].toLowerCase(),o=f$1(null==r?void 0:r.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}));}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:a,hasZ:r,objectIdField:n,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:m,resultOffset:h,returnZ:f,returnM:p}=e,y=null!=m&&t.length>(h||0)+m,g=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return {exceededTransferLimit:y,features:this._createFeatures(e,t),fields:g,geometryType:s,hasM:a&&p,hasZ:r&&f,objectIdFieldName:n,spatialReference:z(u||o),transform:c&&s$3(c)||null}}_createFeatures(e,t){const s=new r(e,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:r$1}=this,{orderByFields:o,quantizationParameters:l,returnGeometry:u,returnCentroid:c,maxAllowableOffset:d,resultOffset:f,resultRecordCount:p,returnZ:y=!1,returnM:g=!1}=e,I=r$1&&y,x=a&&g;let T=[],V=0;const F=[...t];if(this._sortFeatures(F,o,((e,t,i)=>s.getFieldValue(e,t,i))),u||c){const e=s$3(l);if(u&&!c)for(const t of F)T[V++]={attributes:s.getAttributes(t),geometry:J$1(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,I,x)};else if(!u&&c)for(const t of F)T[V++]={attributes:s.getAttributes(t),centroid:O(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)T[V++]={attributes:s.getAttributes(t),centroid:O(this,this.featureAdapter.getCentroid(t,this),e),geometry:J$1(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,I,x)};}else for(const i of F){const e=s.getAttributes(i);e&&(T[V++]={attributes:e});}const b=f||0;if(null!=p){const e=b+p;T=T.slice(b,Math.min(T.length,e));}return T}_createExceedsLimitQueryResponse(e){let i=!1,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const t of e.outStatistics)if("exceedslimit"===t.statisticType){s=null!=t.maxPointCount?t.maxPointCount:Number.POSITIVE_INFINITY,a=null!=t.maxRecordCount?t.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=t.maxVertexCount?t.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>s;else if(this.items.length>a)i=!0;else {const e=this.hasZ?this.hasM?4:3:this.hasM?3:2,s=this.featureAdapter;i=this.items.reduce(((e,i)=>{const a=s.getGeometry(i);return e+(r$2(a)&&a.coords.length||0)}),0)/e>r;}return {fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}_createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,r$1=new Map,o=new Map,l=new r(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:m}=e,h=c&&c.length,f=!!h,p=f&&c[0],y=f&&!this.fieldsIndex.get(p);for(const n of u){const{outStatisticFieldName:e,statisticType:u}=n,m=n,g="exceedslimit"!==u?n.onStatisticField:void 0,I="percentile_disc"===u||"percentile_cont"===u,x=f&&1===h&&(g===p||y)&&"count"===u;if(f){if(!r$1.has(g)){const e=[];for(const t of c){const i=this._getAttributeValues(l,t,s);e.push(i);}r$1.set(g,this._calculateUniqueValues(e,l.returnDistinctValues));}const t=r$1.get(g);for(const i in t){const{count:a,data:r,items:n,itemPositions:u}=t[i],h=r.join(",");if(!d||l.validateItems(n,d)){const t=o.get(h)||{attributes:{}};let i=null;if(x)i=a;else {const e=this._getAttributeValues(l,g,s),t=u.map((t=>e[t]));i=I&&"statisticParameters"in m?this._getPercentileValue(m,t):this._getStatisticValue(m,t,null,l.returnDistinctValues);}t.attributes[e]=i,c.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:`EXPR_${i+1}`]=r[i])),o.set(h,t);}}}else {const i=this._getAttributeValues(l,g,s);t.attributes[e]=I&&"statisticParameters"in m?this._getPercentileValue(m,i):this._getStatisticValue(m,i,a,l.returnDistinctValues);}i.push({name:e,alias:e,type:"esriFieldTypeDouble"});}const g=f?Array.from(o.values()):[t];return this._sortFeatures(g,m,((e,t)=>e.attributes[t])),{fields:i,features:g}}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;n=null!=i&&i.has(a)?i.get(a):H$1(this.fieldsIndex.get(a))?m$1({values:t,returnDistinct:s}):c$2({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i),l={value:r,orderBy:n,fieldType:null==o?void 0:o.type,isDiscrete:"percentile_disc"===a};return d$1(t,l)}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map((i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await a$1(),a=s.createFunction(t),r=i&&s.getViewInfo(i);return this.items.map((t=>e.getExpressionValue(t,{compiledFunc:a,viewInfo:r},s)))}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let r=0;r<a;r++){const a=s[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");t?null==i[o]&&(i[o]={count:1,data:n,items:[a],itemPositions:[r]}):null==i[o]?i[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i[o].count++,i[o].items.push(a),i[o].itemPositions.push(r));}return i}async _getDataValues(e,t){const i=new r(e,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:a,normalizationField:r$1,normalizationType:o,normalizationTotal:l,scale:u}=t,c=s?{viewingMode:"map",scale:u,spatialReference:e.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(i,s,c):this._getAttributeNormalizedValues(i,{field:a,normalizationField:r$1,normalizationType:o,normalizationTotal:l})}}function _(e,t,i,s,a,r){const n=a-i,o=r-s,l=n*n+o*o,u=(e-i)*n+(t-s)*o,c=Math.min(1,Math.max(0,u/l));return {x:i+n*c,y:s+o*c}}function R(e,t){return e?t?4:3:t?3:2}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
function U(e){return e.every((e=>"exceedslimit"!==e.statisticType))}const N="feature-store:unsupported-query";const H=new Set,D=new h$1(2e6);let J=0;class L{constructor(e){this.capabilities={query:t$2},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new i(J+++"$$",D)),this.fieldsIndex=new d$2(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority));}destroy(){this._frameTask=s$4(this._frameTask),this.clearCache(),l$1(this._geometryQueryCache),this._changeHandle=s$4(this._changeHandle),l$1(this.fieldsIndex);}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:z(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=t$3(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null;}async executeQuery(e={},i){let s,r=l$2(e);try{r=await this._schedule((()=>P(r,this.definitionExpression,this.spatialReference)),i),r=await this._reschedule((()=>this._checkQuerySupport(r)),i),s=await this._reschedule((()=>this._executeGeometryQuery(r,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),i),s=await this._reschedule((()=>s.executeTimeQuery(r)),i),s=await this._reschedule((()=>s.executeAttributesQuery(r)),i);}catch(a){if(a!==U$1)throw a;s=new S([],null,this);}return s.createQueryResponse(r)}async executeQueryForCount(e={},i){let s=l$2(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule((()=>P(s,this.definitionExpression,this.spatialReference)),i),s=await this._reschedule((()=>this._checkQuerySupport(s)),i);let e=await this._reschedule((()=>this._executeGeometryQuery(s,i)),i);return e=await this._reschedule((()=>e.executeAggregateIdsQuery(s)),i),e=await this._reschedule((()=>e.executeObjectIdsQuery(s)),i),e=await this._reschedule((()=>e.executeTimeQuery(s)),i),e=await this._reschedule((()=>e.executeAttributesQuery(s)),i),e.createQueryResponseForCount(s)}catch(r){if(r!==U$1)throw r;return 0}}async executeQueryForExtent(e={},i){let s,r=l$2(e);const a=r.outSR;try{r=await this._schedule((()=>P(r,this.definitionExpression,this.spatialReference)),i),r=await this._reschedule((()=>this._checkQuerySupport(r)),i),r.returnGeometry=!0,r.returnCentroid=!1,r.outSR=null,s=await this._reschedule((()=>this._executeGeometryQuery(r,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),i),s=await this._reschedule((()=>s.executeTimeQuery(r)),i),s=await this._reschedule((()=>s.executeAttributesQuery(r)),i);const e=s.size;if(!e)return {count:e,extent:null};A($,D$2),this.featureStore.forEachBounds(s.items,(e=>f$2($,e)),V);const t={xmin:$[0],ymin:$[1],xmax:$[3],ymax:$[4],spatialReference:z(this.spatialReference)};this.hasZ&&isFinite($[2])&&isFinite($[5])&&(t.zmin=$[2],t.zmax=$[5]);const n=g(t,s.spatialReference,a);if(n.spatialReference=z(a||this.spatialReference),n.xmax-n.xmin==0){const e=H$2(n.spatialReference);n.xmin-=e,n.xmax+=e;}if(n.ymax-n.ymin==0){const e=H$2(n.spatialReference);n.ymin-=e,n.ymax+=e;}if(this.hasZ&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin==0){const e=H$2(n.spatialReference);n.zmin-=e,n.zmax+=e;}return {count:e,extent:n}}catch(n){if(n===U$1)return {count:0,extent:null};throw n}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e={},i){let s,r=l$2(e);r.returnGeometry=!1,r.returnCentroid=!1,r.outSR=null;try{r=await this._schedule((()=>P(r,this.definitionExpression,this.spatialReference)),i),r=await this._reschedule((()=>this._checkQuerySupport(r)),i),s=await this._reschedule((()=>this._executeGeometryQuery(r,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),i),s=await this._reschedule((()=>s.executeTimeQuery(r)),i),s=await this._reschedule((()=>s.executeAttributesQuery(r)),i);const e=s.items,t=new Set;return await this._reschedule((()=>{for(const i of e)t.add(s.featureAdapter.getObjectId(i));}),i),t}catch(a){if(a===U$1)return new Set;throw a}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:a}=e;if(0===a)return {candidates:[]};const n=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),u=!E(i.spatialReference,this.spatialReference);u&&await f$3(i.spatialReference,this.spatialReference);const o="number"==typeof s?s:s.x,c="number"==typeof s?s:s.y,h={xmin:i.x-o,xmax:i.x+o,ymin:i.y-c,ymax:i.y+c,spatialReference:i.spatialReference},l=u?g(h,this.spatialReference):h;if(!l)return {candidates:[]};const p=(await v(d$3(i),null,{signal:t}))[0],d=(await v(d$3(l),null,{signal:t}))[0];if(t$1(p)||t$1(d))return {candidates:[]};let y=new S(this._searchFeatures(this._getQueryBBoxes(d.toJSON())),null,this);y=await this._reschedule((()=>y.executeObjectIdsQuery(n)),t),y=await this._reschedule((()=>y.executeTimeQuery(n)),t),y=await this._reschedule((()=>y.executeAttributesQuery(n)),t);const m=p.toJSON(),f=u?g(m,this.spatialReference):m,_=u?Math.max(l.xmax-l.xmin,l.ymax-l.ymin)/2:s;return y.createSnappingResponse({...e,point:f,distance:_},i.spatialReference)}async executeQueryForLatestObservations(i={},s){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new s$1(N,"Missing timeInfo or timeInfo.trackIdField",{query:i,timeInfo:this.timeInfo});let r,a=l$2(i);try{a=await this._schedule((()=>P(a,this.definitionExpression,this.spatialReference)),s),a=await this._reschedule((()=>this._checkQuerySupport(a)),s),r=await this._reschedule((()=>this._executeGeometryQuery(a,s)),s),r=await this._reschedule((()=>r.executeAggregateIdsQuery(a)),s),r=await this._reschedule((()=>r.executeObjectIdsQuery(a)),s),r=await this._reschedule((()=>r.executeTimeQuery(a)),s),r=await this._reschedule((()=>r.executeAttributesQuery(a)),s),r=await this._reschedule((()=>r.filterLatest()),s);}catch(n){if(n!==U$1)throw n;r=new S([],null,this);}return r.createQueryResponse(a)}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,valueExpression:r}=t;return (await this._getQueryEngineResultForStats(e,{field:s,valueExpression:r},i)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(e,t)}async _schedule(e,t){return r$2(this._frameTask)?this._frameTask.schedule(e,t):e(C)}async _reschedule(e,t){return r$2(this._frameTask)?this._frameTask.reschedule(e,t):e(C)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach((t=>e.push(t))),this._allItems=new S(e,null,this);}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:i,outSR:s,spatialRel:r,returnGeometry:a,returnCentroid:u}=e,o=a||u,c=I(s)&&!E(this.spatialReference,s),h=this._geometryQueryCache?c&&o?JSON.stringify({geometry:i,spatialRelationship:r,outSpatialReference:s}):JSON.stringify({geometry:i,spatialRelationship:r}):null;if(h){const e=this._geometryQueryCache.get(h);if(!u$1(e))return e}const l=async e=>{if(c&&o){const t=await e.project(s);return h&&this._geometryQueryCache.put(h,t,t.size||1),t}return h&&this._geometryQueryCache.put(h,e,e.size||1),e};if(!i)return l(this._getAll());const p=this.featureAdapter;if("esriSpatialRelDisjoint"===r){const e=this._searchFeatures(this._getQueryBBoxes(i));if(!e.length)return l(this._getAll());let s,a;const n=new Set;for(const t of e)n.add(p.getObjectId(t));await this._reschedule((()=>{let e=0;s=new Array(n.size),this.featureStore.forEach((t=>s[e++]=t)),a=n;}),t);const u=await this._reschedule((async()=>{const e=await v$1(r,i,this.geometryType,this.hasZ,this.hasM),n=t=>!a.has(p.getObjectId(t))||e(p.getGeometry(t));return new S(await this._runSpatialFilter(s,n,t),i,this)}),t);return l(u)}const d=this._searchFeatures(this._getQueryBBoxes(i));if(!d.length){const e=new S([],i,this);return h&&this._geometryQueryCache.put(h,e,e.size||1),e}if(this._canExecuteSoloPass(i,e))return l(new S(d,i,this));const y=await v$1(r,i,this.geometryType,this.hasZ,this.hasM),m=await this._runSpatialFilter(d,(e=>y(p.getGeometry(e))),t);return l(new S(m,i,this))}async _runSpatialFilter(e,t,i){if(!t)return e;if(t$1(this._frameTask))return e.filter((e=>t(e)));let s=0;const a=new Array,n=async r=>{for(;s<e.length;){const u=e[s++];t(u)&&(a.push(u),r.madeProgress()),r.done&&await this._reschedule((e=>n(e)),i);}};return this._reschedule((e=>n(e)),i).then((()=>a))}_canExecuteSoloPass(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return I$1(e)&&("esriSpatialRelEnvelopeIntersects"===s||"esriGeometryPoint"===i&&("esriSpatialRelIntersects"===s||"esriSpatialRelContains"===s||"esriSpatialRelWithin"===s))}_getQueryBBoxes(e){if(I$1(e)){if(s$5(e))return [o$1(e.xmin,e.ymin,e.xmax,e.ymax)];if(c$3(e))return e.rings.map((e=>o$1(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return [c$4(u$2(),e)]}_searchFeatures(e){for(const s of e)this.featureStore.forEachInBounds(s,(e=>{H.add(e);}));const t=new Array(H.size);let i=0;return H.forEach((e=>t[i++]=e)),H.clear(),t}async _checkStatisticsSupport(t,i){if(t.distance<0||null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text||t.outStatistics||t.groupByFieldsForStatistics||t.having||t.orderByFields)throw new s$1(N,"Unsupported query options",{query:t});return Promise.all([this._checkAttributesQuerySupport(t),this._checkStatisticsParamsSupport(i),P$1(t,this.geometryType,this.spatialReference),f$3(this.spatialReference,t.outSR)]).then((()=>t))}async _checkStatisticsParamsSupport(t){let i=[];if(t.valueExpression){const{arcadeUtils:e}=await a$1();i=e.extractFieldNames(t.valueExpression);}if(t.field&&i.push(t.field),t.normalizationField&&i.push(t.normalizationField),!i.length)throw new s$1(N,"params should have at least a field or valueExpression",{params:t});c(this.fieldsIndex,i,"params contains missing fields");}async _checkQuerySupport(t){if(t.distance<0||null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text)throw new s$1(N,"Unsupported query options",{query:t});return Promise.all([this._checkAttributesQuerySupport(t),this._checkStatisticsQuerySupport(t),P$1(t,this.geometryType,this.spatialReference),f$3(this.spatialReference,t.outSR)]).then((()=>t))}_checkAttributesQuerySupport(t){const{outFields:i,orderByFields:s,returnDistinctValues:r,outStatistics:a}=t,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())):[];if(s&&s.length>0){const e=" asc",t=" desc",i=s.map((i=>{const s=i.toLowerCase();return s.indexOf(e)>-1?s.split(e)[0]:s.indexOf(t)>-1?s.split(t)[0]:i})).filter((e=>-1===n.indexOf(e)));c(this.fieldsIndex,i,"orderByFields contains missing fields");}if(i&&i.length>0)c(this.fieldsIndex,i,"outFields contains missing fields");else if(r)throw new s$1(N,"outFields should be specified for returnDistinctValues",{query:t});o(this.fieldsIndex,t.where);}async _checkStatisticsQuerySupport(t){const{outStatistics:i,groupByFieldsForStatistics:s,having:r}=t,a$1=s&&s.length,n=i&&i.length;if(r){if(!a$1||!n)throw new s$1(N,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});a(this.fieldsIndex,r,i);}if(n){if(!U(i))return;const r=i.map((e=>e.onStatisticField));c(this.fieldsIndex,r,"onStatisticFields contains missing fields"),a$1&&c(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const s of i){const{onStatisticField:i,statisticType:r}=s;if(("percentile_disc"===r||"percentile_cont"===r)&&"statisticParameters"in s){const{statisticParameters:i}=s;if(!i)throw new s$1(N,"statisticParamters should be set for percentile type",{definition:s,query:t})}else if("count"!==r&&i&&f(i,this.fieldsIndex))throw new s$1(N,"outStatistics contains non-numeric fields",{definition:s,query:t})}}}async _getQueryEngineResultForStats(e={},i,s){let r;e=l$2(e);try{e=await this._schedule((()=>P(e,this.definitionExpression,this.spatialReference)),s),e=await this._reschedule((()=>this._checkStatisticsSupport(e,i)),s),r=await this._reschedule((()=>this._executeGeometryQuery(e,s)),s),r=await this._reschedule((()=>r.executeAggregateIdsQuery(e)),s),r=await this._reschedule((()=>r.executeObjectIdsQuery(e)),s),r=await this._reschedule((()=>r.executeTimeQuery(e)),s),r=await this._reschedule((()=>r.executeAttributesQuery(e)),s);}catch(a){if(a!==U$1)throw a;r=new S([],null,this);}return r}}const V=a$2(),$=a$2();

export { L };
