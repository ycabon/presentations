import { bF as v, R as k$2, aH as n$1, ey as z$1, ez as yn, e7 as P$2, gF as Hn, f0 as x$2, aL as o, fd as u$2, bj as g$2, h9 as p$1, qt as d$1, qu as jn, f2 as r, e9 as z$2, ea as _, f3 as n$2, fM as O$1, fL as An, qv as Ce, br as n$3, e6 as n$4, qw as xn, qx as q$3, fc as j$1, e8 as e, aE as r$1, fu as Bn, qy as b$1, ix as u$3, e_ as m$1, qz as G$1, fH as S$1, fp as M$1, r as r$2, cA as c$4, iu as i, B as e$2, C as d$2, D as n$5, E as f, b3 as l$1, h5 as U$2, fN as I, fO as p$2, Z as s$1, aZ as n$6, by as t$1, ks as D, dX as l$2, cr as m$2, er as w$1, i_ as Rn, t as t$2, bG as e$3, bg as b$2, hG as o$2, hL as v$2, gh as O$2, hF as n$7, hO as n$8, jc as e$4, hM as e$5, hK as e$6, hR as o$3, iL as l$3, am as R$2, i2 as t$3, hU as e$7, hV as o$4, iK as E, hW as W, hY as A, jB as l$4, h_ as a$2, h$ as E$1, i0 as _$1, hS as e$8, hT as s$2, i3 as d$3, i4 as x$3, hH as h$1, i5 as E$2, iO as i$1, iP as o$5, i6 as t$4, i7 as h$2, aQ as r$3, f4 as r$4, g7 as o$6, bv as a$3, gf as D$1, f7 as a$4, nU as j$2, iS as g$4, gO as e$9, ga as r$5, qA as s$3, qB as f$1, eU as E$3, gG as x$4, qC as T$1, qD as A$1, qE as K, qF as O$3, g1 as u$4 } from './_virtual_index-9b831d4a.js';
import { c as c$3, e as e$1, t, r as r$6 } from './UnitNormalizer-a90cd009.js';
import { n as n$a } from './AnalysisView3D-e549779b.js';
import { o as o$1, a, v as v$4 } from './quantityUtils-95a87361.js';
import { geodesicArea as q$2 } from './geometryEngine-54622e44.js';
import { v as v$1 } from './euclideanAreaMeasurementUtils-66d0703c.js';
import { a as a$1 } from './projectionUtils-27d92f9b.js';
import { S as S$2, g as g$3, R as R$1, p as p$3 } from './EditGeometryOperations-7433228d.js';
import { g as g$5 } from './quantityFormatUtils-2bdbcd46.js';
import { v as v$3, m as m$3, l as l$5 } from './Segment-b8cea6ae.js';
import { n as n$9, C } from './LineVisualElement-53a30f81.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
function y(o$1,s){const i=s.center;o(i,0,0,0);for(let t=0;t<o$1.length;++t)u$2(i,i,o$1[t]);g$2(i,i,1/o$1.length);let f=0;for(let t=0;t<o$1.length;++t)f=Math.max(f,p$1(i,o$1[t]));s.radius=Math.sqrt(f);}function M(t,e){if(t.length<3)throw new Error("need at least 3 points to fit a plane");d$1(t[0],t[1],t[2],e);}function b(t,e){return P$2(t,e)+t[3]}function P$1(t,e,n){return Hn(t,R,n)&&Hn(e,S,n)?x$2(R,S):0}function w(t,e){if(!jn(t,R)||!jn(e,S))return 0;const n={distance:null};return z$1(n,[R[0],R[1]],[S[0],S[1]]),n.distance}function k$1(t,e,n){const r={distance:null};return z$1(r,[t[0],t[1]],[e[0],e[1]],n),r.distance}function q$1(t,e,n,r){const o=G;return yn(t,r,R)&&yn(e,r,S)&&yn(n,r,U$1)?(o.setPoint(0,0,R),o.setPoint(0,1,S),o.setPoint(0,2,U$1),Math.abs(q$2(o,"square-meters"))):0}function x$1(n,r$1=null,s=!0){const a=1e-6,c=(t,e)=>{if(0===e[0]&&0===e[1]&&0===e[2])return !1;for(let n=0;n<t.length;++n)if(P$2(e,t[n])<-a)return !1;return !0};if(0===n.length)return !1;if(1===n.length)return r$1&&r(r$1,n[0]),!0;o(T,0,0,0);for(let t=0;t<n.length;++t)u$2(T,T,n[t]);if(z$2(T,T),c(n,T))return r$1&&r(r$1,T),!0;if(!s)return !1;for(let t=0;t<n.length;++t)for(let e=0;e<n.length;++e)if(t!==e&&(_(T,n[t],n[e]),z$2(T,T),c(n,T)))return r$1&&r(r$1,T),!0;return !1}const R=n$1(),S=n$1(),U$1=n$1(),G=new v({rings:[[R,S,U$1]],spatialReference:k$2.WGS84}),T=n$1();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class H{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=n$1(),this.areaCentroidRenderCoords=n$1(),this.geodesicAreaCentroidRenderCoords=n$1(),this._length=0,this._centroidRenderCoords=n$1(),this._planeWorldCoords=n$2(),this._worldUp=n$1(),this._worldTangent=n$1(),this._frame=[n$1(),n$1(),n$1()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=n$1(),this._tempV=n$1(),this._tempVec3=n$1(),this._tempSphere={center:n$1(),radius:0},this._sceneView=e,this.unitNormalizer=t;}update(e,s,o,r,n,h,d){const g=this.unitNormalizer,l=this._sceneView.renderSpatialReference,p=this.unitNormalizer.spatialReference,c=r$2(s);if(this._pathVersion===e.version&&this._validMeasurement===r&&!d&&this._hasCursorPoint===c&&this._mode===h){return !e.isValidPolygon&&(this._updateCursorSegmentLength(e,s),!0)}this._pathVersion=e.version,this._validMeasurement=r,this._hasCursorPoint=c;const m=e.numVertices;this._resize(m);const u=O$1(o.spatialReference),_=An(o.spatialReference,u)&&Ce(o.spatialReference),{positionsGeographic:C,positionsWorldCoords:f,positionsRenderCoords:j,positionsSpherical:M}=this;e.forEachVertexPosition(((e,t)=>{X(o.elevationProvider,e),Hn(e,f[t],p),Hn(e,j[t],l),_&&(jn(e,C[t]),Hn(e,M[t],u),z$2(M[t],M[t]));}));const W=this._updatePathLengths(r);if(this.pathLength=this._length>1?o$1(g.normalizeDistance(W),"meters"):null,_){const e=this._updateGeodesicPathLengths(r,p);this.geodesicPathLength=this._length>1?o$1(e,"meters"):null;}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,s),this._updateMode(e,h),r?(this._updateArea(o,g,l,p,n),_&&this._updateGeodesicArea(o),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return {positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(n$1()),this.positionsRenderCoords.push(n$1()),this.positionsProjectedWorldCoords.push(n$3()),this.positionsFittedRenderCoords.push(n$1()),this.positionsGeographic.push(n$1()),this.positionsSpherical.push(n$1()),this.positionsStereographic.push(n$3()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length;}_updatePathLengths(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const r=s[o]=x$2(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=r);}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=k$1(s[r],s[(r+1)%this._length],t);(r<this._length-1||e)&&(o+=n);}return o}_updateArea(e$1,t,s,n,h){const a$1=e$1.renderCoordsHelper,d=this.positionsWorldCoords,C=this.positionsRenderCoords,f=this.positionsProjectedWorldCoords,S=this.positionsFittedRenderCoords,L=this._planeWorldCoords,P=this._centroidRenderCoords;c$3(C,P),a$1.worldUpAtPosition(P,this._worldUp),a$1.worldBasisAtPosition(P,n$4.X,this._worldTangent),xn(P,this._worldUp,s,this._worldUp,n),xn(P,this._worldTangent,s,this._worldTangent,n),d.length>2&&M(d,L),this.fittingMode=this._selectFittingMode(L,d,this._worldUp,h);let R=0;if("horizontal"===this.fittingMode){let e=-1/0;C.forEach(((t,s)=>{const i=a$1.getAltitude(C[s]);i>e&&(e=i,R=s);}));}const A=d[R];let W=L,v=this._worldTangent;"horizontal"===this.fittingMode?W=this._worldUp:"vertical"===this.fittingMode&&(W=this._tempVec3,v=this._worldUp,q$3(L,this._worldUp,W)),r(this._frame[2],W),q$3(v,W,this._frame[0]),_(this._frame[1],this._frame[0],this._frame[2]),j$1(this._frame[1],this._frame[1]);const z=this._tempVec3,U=this._tempU,I=this._tempV;for(let i=0;i<this._length;++i){const e$1=f[i],t=S[i];e(z,d[i],A),r$1(e$1,P$2(this._frame[0],z),P$2(this._frame[1],z)),g$2(U,this._frame[0],e$1[0]),g$2(I,this._frame[1],e$1[1]),u$2(z,U,I),u$2(z,z,A),Bn(z,n,t,s);}this.perimeterLength=this._length>0?o$1(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,c$3(S,this.areaCentroidRenderCoords),Bn(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,n),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?a(t.normalizeArea(this._computeArea()),"square-meters"):null;}_updateGeodesicArea(e){const{renderCoordsHelper:t,spatialReference:s}=e,{positionsSpherical:i,positionsStereographic:n}=this,h=this._tempVec3,a$1=x$1(i,h);if(!a$1)return void(this.geodesicArea=null);const d=this._tempU,g=this._tempV;b$1(h,d,g);for(let o=0;o<this._length;++o){const e=P$2(i[o],d),t=P$2(i[o],g),s=P$2(i[o],h);r$1(n[o],e/s,t/s);}g$2(h,h,u$3(s).radius),t.toRenderCoords(h,O$1(s),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=a$1&&0===this.geodesicIntersectingSegments.size?a(this._computeGeodesicArea(),"square-meters"):null;}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=m$1(e[i],e[(i+1)%this._length]);}return s}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];G$1(o,r,n,h)&&(t.add(s),t.add(i));}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=this.triangleIndices=new Uint32Array(v$1(e));let s=0;for(let i=0;i<t.length;i+=3)s+=S$1(e[t[i]],e[t[i+1]],e[t[i+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];G$1(o,r,n,h)&&(t.add(s),t.add(i));}}_computeGeodesicArea(){const e=this.positionsGeographic,t=this.positionsStereographic,s=this.geodesicTriangleIndices=new Uint32Array(v$1(t));let i=0;for(let o=0;o<s.length;o+=3)i+=q$1(e[s[o]],e[s[o+1]],e[s[o+2]],k$2.WGS84);return i}_selectFittingMode(t,s,i,o){const r=s.map((e=>Math.abs(b(t,e)))).reduce(((e,t)=>Math.max(e,t)),0);y(s,this._tempSphere);const n=r/(2*this._tempSphere.radius),h=n<o.maxRelativeErrorCoplanar,a=n<o.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(h)d="oblique";else if(a){d=Math.abs(P$2(i,t))>Math.cos(M$1(o.verticalAngleThreshold))?"horizontal":"vertical";}return d}_updateCursorSegmentLength(e,s){const o=e.lastPoint;!e.isValidPolygon&&r$2(o)&&r$2(s)?(this.geodesicCursorSegmentLength=o$1(w(o,s),"meters"),this.cursorSegmentLength=o$1(this.unitNormalizer.normalizeDistance(P$1(o,s,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null);}_updateMode(e,s){if(s===e$1.Auto){this.actualMeasurementMode="euclidean";let s=0;null!=this.geodesicPathLength&&(s+=this.geodesicPathLength.value),!e.isValidPolygon&&r$2(this.geodesicCursorSegmentLength)&&(s+=this.geodesicCursorSegmentLength.value),s>Z&&(this.actualMeasurementMode="geodesic");}else this.actualMeasurementMode=s===e$1.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=s;}}function X(e,t){t.hasZ||(t.z=c$4(i(e,t,"ground"),0));}const Z=1e5;

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
let u$1=class extends f{constructor(e){super(e);}initialize(){const{spatialReference:e}=this.view,t$1=O$1(e),a=t$1===I?p$2:t$1,o=!e||An(e,a)?a:e,u=new t(o);this._measurementDataManager=new H(this.view,u),this.addHandles([this.analysisViewData.path.on("change",(()=>this._update())),l$1((()=>this.analysisViewData.cursorPoint),(()=>this._update()),U$2),l$1((()=>this.analysisViewData.mode),(()=>this._update()),U$2)]),this._update();}_update(e=!1){const{analysisViewData:t,view:r}=this,s={maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80};this._measurementDataManager.update(t.path,t.cursorPoint,r,t.validMeasurement,s,t.mode,e)&&(t.measurementData=this._measurementDataManager.getData());}};e$2([d$2({constructOnly:!0})],u$1.prototype,"view",void 0),e$2([d$2({constructOnly:!0})],u$1.prototype,"analysis",void 0),e$2([d$2({constructOnly:!0})],u$1.prototype,"analysisViewData",void 0),u$1=e$2([n$5("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")],u$1);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const V="esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper",x=s$1.getLogger(V);let j=class extends n$6.EventedAccessor{constructor(e={}){super(e),this._handles=new t$1,this._version=0,this._internalGeometryChange=!1,this._extent=D();}destroy(){this._handles=l$2(this._handles);}set areaMeasurement(e){this._set("areaMeasurement",e),r$2(e)&&r$2(this.view)&&this._initialize(e,this.view);}set view(e){this._set("view",e),r$2(e)&&r$2(this.areaMeasurement)&&this._initialize(this.areaMeasurement,e);}get constructed(){return r$2(this.areaMeasurement)&&r$2(this.view)}get version(){return this._version}get isValidPolygon(){return this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].isClosed()}get extent(){if(this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].vertices.length>0){const e=D(this._extent);return this.forEachVertex((t=>{m$2(e,t.pos);})),e}return null}get spatialReference(){return this.constructed?this._editGeometry.coordinateHelper.spatialReference:null}_initialize(e,t){this._handles.removeAll(),this._handles.add(l$1((()=>e.geometry),(()=>{this._updateEditGeometryFromModelGeometry(e,t);}),w$1)),this._makeDirty(!0);}_makeDirty(e=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),this.notifyChange("extent"),e&&this.notifyChange("numVertices");}_updateEditGeometryFromModelGeometry(e,t){if(this._version++,this._internalGeometryChange)return;this._handles.remove("EditGeometry");let r=e.geometry;if(r$2(r)){const o=Rn(r,t.spatialReference);t$2(o)&&a$1(e,r.spatialReference,x),r=o;}r$2(r)?this._editGeometryOperations=S$2.fromGeometry(r,t.state.viewingMode):this._editGeometryOperations=new S$2(new g$3("polygon",R$1(!0,!1,t.spatialReference))),this._makeDirty(!0),this.emit("change"),this._handles.add(this._editGeometry.on("change",(t=>{this._makeDirty(null!=t.addedVertices||null!=t.removedVertices),this._internalGeometryChange=!0,e.geometry=this.numVertices>0?this._editGeometry.geometry:null,this._internalGeometryChange=!1;})),"EditGeometry");}get _editGeometry(){return this._editGeometryOperations.data}get vertices(){const e=[];return this.forEachVertex((t=>{e.push(t);})),e}get numVertices(){return this.constructed&&this._editGeometry.components.length>0?this._editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.constructed&&this._editGeometry.components.length>0){const e=this._editGeometry.components[0].getLastVertex();if(r$2(e))return this._editGeometry.coordinateHelper.vectorToPoint(e.pos)}return null}getVertex(e){if(!this.constructed||0===this._editGeometry.components.length||0===this._editGeometry.components[0].vertices.length)return null;const t=this._editGeometry.components[0].vertices[0];let r=t;do{if(r.index===e)return r;r=r.rightEdge.rightVertex;}while(r!==t&&null!=r);return null}getVertexPositionAsPoint(e){return this._editGeometry.coordinateHelper.vectorToPoint(e.pos)}getVertexPositionAsPointFromIndex(e){return this._editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e).pos)}forEachVertex(e){this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].iterateVertices(e);}forEachVertexPosition(e){const t=this._editGeometry.coordinateHelper;this.forEachVertex(((r,o)=>{t.vectorToPoint(r.pos,P),e(P,o);}));}clear(){r$2(this.areaMeasurement)&&(this.areaMeasurement.geometry=null);}add(e){if(!this.constructed)return null;if(0===this._editGeometry.components.length){const e=e$3(this.view);this._editGeometry.components.push(new p$3(e.spatialReference,e.state.viewingMode));}const t=this._editGeometryOperations.appendVertex(this._editGeometry.coordinateHelper.pointToVector(e));return this.emit("change"),t}close(){if(!this.constructed||0===this._editGeometry.components.length)return null;const e=this._editGeometryOperations.closeComponent(this._editGeometry.components[0]);return this.emit("change"),e}ensureContains(e,t=""){let r=!1;if(this._editGeometry.components.forEach((t=>{t.iterateVertices((t=>{t===e&&(r=!0);}));})),!r)throw new Error(`vertex doesnt exist ${t}`);return r}setVertexPosition(e,t){if(!this.constructed)return null;const r=this._editGeometryOperations.setVertexPosition(e,this._editGeometry.coordinateHelper.pointToVector(t));return this.emit("change"),r}equals(e){if(this.numVertices!==e.numVertices)return !1;let t=!0;return this.forEachVertexPosition(((r,o)=>{const i=e.getVertexPositionAsPointFromIndex(o);r.equals(i)||(t=!1);})),!!t}};e$2([d$2({value:null})],j.prototype,"areaMeasurement",null),e$2([d$2({value:null})],j.prototype,"view",null),e$2([d$2()],j.prototype,"isValidPolygon",null),e$2([d$2()],j.prototype,"extent",null),e$2([d$2()],j.prototype,"spatialReference",null),e$2([d$2()],j.prototype,"numVertices",null),j=e$2([n$5(V)],j);const P=new b$2;

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
function n(n){const c=new o$2;return c.extensions.add("GL_OES_standard_derivatives"),v$2(c,n),c.attributes.add(O$2.POSITION,"vec3"),c.attributes.add(O$2.UV0,"vec2"),c.varyings.add("vUV","vec2"),n.hasMultipassTerrain&&c.varyings.add("depth","float"),c.vertex.code.add(n$7`
    void main(void) {
      vUV = uv0;
      ${n.hasMultipassTerrain?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),c.include(n$8,n),c.fragment.uniforms.add(new e$4("size",(e=>e.size))),c.fragment.uniforms.add(new e$5("color1",(e=>e.color1))),c.fragment.uniforms.add(new e$5("color2",(e=>e.color2))),c.fragment.include(e$6),c.fragment.code.add(n$7`
    void main() {
      ${n.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${n.transparencyPassType===o$3.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),c}const c$2=Object.freeze(Object.defineProperty({__proto__:null,build:n},Symbol.toStringTag,{value:"Module"}));

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class h extends e$7{initializeProgram(e){return new o$4(e.rctx,h.shader.get().build(this.configuration),E)}_setPipelineState(e){const r=this.configuration,t=e===o$3.NONE,s=e===o$3.FrontFace;return W({blending:r.transparent?t?g$1:A(e):null,depthTest:{func:l$4(e)},depthWrite:t?r.writeDepth&&a$2:E$1(e),colorWrite:_$1,polygonOffset:t||s?r.polygonOffset&&u:{factor:-1,units:-25}})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}h.shader=new t$3(c$2,(()=>import('./CheckerBoard.glsl-d45d59a5.js')));const u={factor:0,units:-25},g$1=l$3(R$2.SRC_ALPHA,R$2.ONE,R$2.ONE_MINUS_SRC_ALPHA,R$2.ONE_MINUS_SRC_ALPHA);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class s extends s$2{constructor(){super(...arguments),this.transparencyPassType=o$3.NONE,this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1;}}e$2([e$8({count:o$3.COUNT})],s.prototype,"transparencyPassType",void 0),e$2([e$8()],s.prototype,"transparent",void 0),e$2([e$8()],s.prototype,"writeDepth",void 0),e$2([e$8()],s.prototype,"polygonOffset",void 0),e$2([e$8()],s.prototype,"hasMultipassTerrain",void 0),e$2([e$8()],s.prototype,"cullAboveGround",void 0);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class c$1 extends d$3{constructor(r){super(r,new m),this._configuration=new s;}dispose(){}getConfiguration(r,t){return this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(r,t,e,i,s,n,o){return x$3(r,t,i,s,n,void 0,o)}requiresSlot(r,t){if(t===h$1.Color||t===h$1.Alpha){return r===(this.parameters.transparent?this.parameters.writeDepth?E$2.TRANSPARENT_MATERIAL:E$2.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:E$2.OPAQUE_MATERIAL)||r===E$2.DRAPED_MATERIAL}return !1}createGLMaterial(r){return new l(r)}createBufferWriter(){return new i$1(o$5)}}class l extends t$4{beginSlot(r){return this.ensureTechnique(h,r)}}class m extends h$2{constructor(){super(...arguments),this.size=r$3(1,1),this.color1=r$4(.75,.75,.75,1),this.color2=r$4(.5,.5,.5,1),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1;}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class p extends n$9{constructor(e){super(e),this._checkerBoardMaterial=null,this._renderOccluded=o$6.OccludeAndTransparent,this._geometry=null,this._size=r$3(1,1),this._color1=r$4(1,.5,0,.5),this._color2=r$4(1,1,1,.5),this.applyProps(e);}get renderOccluded(){return this._renderOccluded}set renderOccluded(e){e!==this._renderOccluded&&(this._renderOccluded=e,this._updateMaterial());}get geometry(){return this._geometry}set geometry(e){this._geometry=e,this._geometryChanged();}get size(){return this._size}set size(e){a$3(this._size,e),this._updateMaterial();}get color1(){return this._color1}set color1(e){D$1(e,this._color1)||(a$4(this._color1,e),this._updateMaterial());}get color2(){return this._color2}set color2(e){D$1(e,this._color2)||(a$4(this._color2,e),this._updateMaterial());}_updateMaterial(){r$2(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameters({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded});}createExternalResources(){this._checkerBoardMaterial=new c$1({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:o$6.OccludeAndTransparent});}destroyExternalResources(){this._checkerBoardMaterial=null;}forEachExternalMaterial(r){r$2(this._checkerBoardMaterial)&&r(this._checkerBoardMaterial);}createGeometries(e$1){if(t$2(this._geometry)||t$2(this._checkerBoardMaterial))return;const s=g;j$2(s,this.transform);const o=this._geometry,a=[],l=n$1();o.position.forEach((e$1=>{e(l,e$1,s),a.push(l[0],l[1],l[2]);}));const h=[];o.uv.forEach((e=>{h.push(e[0],e[1]);}));const n=new g$4([[O$2.POSITION,{size:3,data:a,exclusive:!0}],[O$2.UV0,{size:2,data:h,exclusive:!0}]],[[O$2.POSITION,o.triangleIndices],[O$2.UV0,o.triangleIndices]]);e$1.addGeometry(n,this._checkerBoardMaterial);}_geometryChanged(){this.recreateGeometry();}}const g=n$1();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
let O=class extends f{constructor(e){super(e),this._handles=new t$1,this._params={...z},this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=n$1(),this._originTransform=e$9(),this._cursorPositionRenderSpace=n$1(),this.messages=null,this.viewData=q,this.areaLabel=null,this.perimeterLengthLabel=null,this.loadingMessages=!0;}get visible(){return this.analysisViewData.visible}get testData(){return {labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}initialize(){const{analysisViewData:e,_params:t,view:i}=this;this._path=new C({view:i,attached:!0,width:t.pathLineWidth,color:t.pathLineColor,polygonOffset:!0,renderOccluded:o$6.OccludeAndTransparent}),this._intersectedPath=new C({view:i,attached:!0,width:t.pathLineWidth,color:t.intersectingLineColor,polygonOffset:!0,renderOccluded:o$6.OccludeAndTransparent}),this._perimeter=new C({view:i,attached:!0,width:t.perimeterLineWidth,color:t.perimeterLineColor,polygonOffset:!0,renderOccluded:o$6.OccludeAndTransparent}),this._intersectedPerimeter=new C({view:i,attached:!0,width:t.perimeterLineWidth,color:t.intersectingLineColor,polygonOffset:!0,renderOccluded:o$6.OccludeAndTransparent}),this._projectionLines=new C({view:i,attached:!0,width:t.projectionLineWidth,color:t.projectionLineColor,stipplePattern:r$5(t.projectionLineStippleSize),polygonOffset:!0,renderOccluded:o$6.OccludeAndTransparent}),this._measurementArea=new p({view:i,attached:!0,color1:t.areaColor1,color2:t.areaColor2}),this._areaLabel=new v$3({view:i,attached:!0,fontSize:U.Large}),this._pathLengthLabel=new v$3({view:i,attached:!0,fontSize:U.Small}),this._cursorSegmentLengthLabel=new v$3({view:i,attached:!0,fontSize:U.Small}),this._perimeterLengthLabel=new v$3({view:i,attached:!0,fontSize:U.Small}),this._handles.add([l$1((()=>[e.mode,this.visible,e.unit,e.measurementData,e.cursorPoint]),(()=>this._update()),w$1),l$1((()=>i.state?.camera),(()=>this._updateLabels()),w$1),s$3((async()=>this._updateMessageBundle()))]),this._updateMessageBundle();}destroy(){this._measurementArea=l$2(this._measurementArea),this._path=l$2(this._path),this._intersectedPath=l$2(this._intersectedPath),this._perimeter=l$2(this._perimeter),this._intersectedPerimeter=l$2(this._intersectedPerimeter),this._areaLabel=l$2(this._areaLabel),this._pathLengthLabel=l$2(this._pathLengthLabel),this._cursorSegmentLengthLabel=l$2(this._cursorSegmentLengthLabel),this._perimeterLengthLabel=l$2(this._perimeterLengthLabel),this._projectionLines=l$2(this._projectionLines),this._handles=l$2(this._handles),this.set("view",null);}_update(){if(this.destroyed||!this.view.ready||!this.view.renderCoordsHelper)return;const{analysisViewData:{measurementData:e},analysisViewData:t}=this;t$2(e)||(this._updateViewData(e,t.path,t.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels());}_updateViewData(e,t,i){const r=t.isValidPolygon,n="geodesic"===e.actualMeasurementMode,a=n?e.geodesicArea:e.area;let o=1;if(a){const t=this._toPreferredAreaUnit(a,this.analysisViewData.unit);o=f$1(Math.sqrt(t.value)/Math.sqrt(300)),o*=Math.sqrt(E$3(1,t.unit,"square-meters")),o/=e.unitNormalizer.normalizeDistance(1);}const l={validMeasurement:r,path:t,pathVersion:t.version,cursorPoint:i,measurementData:e,mode:e.actualMeasurementMode,positionsGeographic:e.positionsGeographic,positionsRenderCoords:e.positionsRenderCoords,positionsProjected:e.positionsProjectedWorldCoords,positionsFittedRenderCoords:e.positionsFittedRenderCoords,intersectingSegments:n?e.geodesicIntersectingSegments:e.intersectingSegments,triangleIndices:n?e.geodesicTriangleIndices:e.triangleIndices,fittingMode:e.fittingMode,areaCentroid:n?e.geodesicAreaCentroidRenderCoords:e.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:r?0:t.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:o};this._set("viewData",l);}_updateOrigin(){const e=this.viewData;c$3(e.positionsRenderCoords,this._origin),x$4(this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform;}_createSegments(e){const t=this.viewData,i=t.path,s=this.view.renderCoordsHelper.spatialReference,r=t.mode,n=[],a=[],o=[],l=t.validMeasurement?i.numVertices:i.numVertices-1;for(let h=0;h<l;++h){const l=t[e][h],c=t[e][(h+1)%i.numVertices];let m=null;switch(r){case"euclidean":m=new l$5(l,c);break;case"geodesic":m=new m$3(l,c,s);}t.intersectingSegments.has(h)?o.push(m):a.push(m),n.push(m);}return {all:n,nonIntersecting:a,intersecting:o}}_updatePathSegments(){const{view:{renderCoordsHelper:e},viewData:t,visible:i}=this,s=this._createSegments("positionsRenderCoords"),{cursorPoint:r,mode:n,path:o}=t,l=!o.isValidPolygon,h=e.spatialReference;if(this._cursorSegment=null,o.numVertices>0&&l&&r$2(r)){if(e.toRenderCoords(r,this._cursorPositionRenderSpace)){const e=t.positionsRenderCoords[o.numVertices-1],i=this._cursorPositionRenderSpace;let r=null;switch(n){case"euclidean":r=new l$5(e,i);break;case"geodesic":r=new m$3(e,i,h);}s.nonIntersecting.push(r),this._cursorSegment=r;}}this._path.setGeometryFromSegments(s.nonIntersecting,this._origin),this._path.visible=i,this._intersectedPath.setGeometryFromSegments(s.intersecting,this._origin),this._intersectedPath.visible=i,this._pathSegments=s.all;}_updatePerimeterSegments(){const e=this.visible&&"euclidean"===this.viewData.mode,t=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(t.nonIntersecting,this._origin),this._perimeter.visible=e,this._intersectedPerimeter.setGeometryFromSegments(t.intersecting,this._origin),this._intersectedPerimeter.visible=e,this._perimeterSegments=t.all;}_updateArea(){const e=this.viewData;switch(e.mode){case"euclidean":this._updateAreaEuclidean(e);break;case"geodesic":this._updateAreaGeodesic();}}_updateAreaEuclidean(e){const t=this.visible;e.validMeasurement&&0===e.intersectingSegments.size&&e.triangleIndices?(this._measurementArea.geometry={uv:e.positionsProjected,position:e.positionsFittedRenderCoords,triangleIndices:e.triangleIndices},this._measurementArea.size=[e.checkerSize,e.checkerSize],this._measurementArea.visible=t):this._measurementArea.visible=!1;}_updateAreaGeodesic(){this._measurementArea.visible=!1;}_updateProjectionLines(){const e$1=this.viewData,t=this.visible,i=e$1.path,s=e$1.mode;if(i.numVertices>0&&e$1.validMeasurement&&"euclidean"===s){const s=[];for(let t=0;t<i.numVertices;++t){const i=n$1();e(i,e$1.positionsRenderCoords[t],this._origin);const r=n$1();e(r,e$1.positionsFittedRenderCoords[t],this._origin),s.push([i,r]);}this._projectionLines.geometry=s,this._projectionLines.visible=t;}else this._projectionLines.geometry=null,this._projectionLines.visible=!1;}_updateLabels(){if(this.destroyed)return;const{viewData:e}=this,{measurementData:t,mode:i,path:s}=e;if(!s)return;const r=!s.isValidPolygon,n=this.visible,l=this._formatAreaLabel(this.messages,"geodesic"===i?t.geodesicArea:t.area,this.analysisViewData.unit);r$2(l)?(this._areaLabel.geometry={type:"point",point:e.areaCentroid},this._areaLabel.text=l,this._areaLabel.visible=e.validMeasurement&&0===e.intersectingSegments.size&&n):this._areaLabel.visible=!1,this._set("areaLabel",e$3(l));const h=this._formatLengthLabel(this.messages,"geodesic"===i?t.geodesicPathLength:t.pathLength,this.analysisViewData.unit);if(r$2(h)&&e.pathLengthLabelSegmentIndex>=0&&e.pathLengthLabelSegmentIndex<this._pathSegments.length){const t=this._pathSegments[e.pathLengthLabelSegmentIndex],i=r$2(this._cursorSegment)?this._cursorSegment:k;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:t,right:i},this._pathLengthLabel.text=h,this._pathLengthLabel.visible=r&&s.numVertices>0&&n;}else this._pathLengthLabel.visible=!1;const c="geodesic"===i?e.measurementData.geodesicCursorSegmentLength:e.measurementData.cursorSegmentLength;if(r$2(c)){const e=this._formatLengthLabel(this.messages,c,this.analysisViewData.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=r$2(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=e$3(e),this._cursorSegmentLengthLabel.visible=r&&0!==c.value&&n;}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const m="geodesic"===e.mode,d=m?t.geodesicPathLength:t.perimeterLength,p=this._formatLengthLabel(this.messages,d,this.analysisViewData.unit);if(this._set("perimeterLengthLabel",e$3(p)),e.validMeasurement&&0===e.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=e$3(p),this._perimeterLengthLabel.visible=!0;let t=!0;for(let i=0;i<e.path.numVertices;++i){const s=(e.perimeterLengthLabelSegmentIndex+i)%e.path.numVertices,r=m?this._pathSegments[s]:this._perimeterSegments[s];if(t=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:r,sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;t=!1;}this._perimeterLengthLabel.visible=t&&n;}else this._perimeterLengthLabel.visible=!1;}_toPreferredAreaUnit(e,t){return v$4(e,this._preferredAreaUnit(e,t))}_preferredAreaUnit(e,t){switch(t){case"metric":return A$1(e.value,e.unit);case"imperial":return T$1(e.value,e.unit);default:return t}}_preferredLengthUnit(e,t){const i=this._deriveLengthUnitFromAreaUnit(t);switch(i){case"metric":return O$3(e.value,e.unit);case"imperial":return K(e.value,e.unit);default:return i}}_deriveLengthUnitFromAreaUnit(e){switch(e){case"metric":case"ares":case"hectares":return "metric";case"imperial":case"acres":return "imperial";case"square-inches":return "inches";case"square-feet":return "feet";case"square-yards":return "yards";case"square-miles":return "miles";case"square-us-feet":return "us-feet";case"square-millimeters":return "millimeters";case"square-centimeters":return "centimeters";case"square-decimeters":return "decimeters";case"square-meters":return "meters";case"square-kilometers":return "kilometers"}throw new Error("unhandled area unit")}_formatAreaLabel(e,t,i){return e&&t&&g$5(e,t,this._preferredAreaUnit(t,i))}_formatLengthLabel(e,t,i){return e&&t&&g$5(e,t,this._preferredLengthUnit(t,i))}_updateMessageBundle(){this.loadingMessages=!0,u$4("esri/core/t9n/Units").then((e=>{this.messages=e,this.view&&this._update();})).finally((()=>{this.loadingMessages=!1;}));}};var U;e$2([d$2()],O.prototype,"view",void 0),e$2([d$2()],O.prototype,"messages",void 0),e$2([d$2()],O.prototype,"analysis",void 0),e$2([d$2()],O.prototype,"viewData",void 0),e$2([d$2()],O.prototype,"analysisViewData",void 0),e$2([d$2({readOnly:!0})],O.prototype,"areaLabel",void 0),e$2([d$2({readOnly:!0})],O.prototype,"perimeterLengthLabel",void 0),e$2([d$2()],O.prototype,"loadingMessages",void 0),e$2([d$2()],O.prototype,"visible",null),O=e$2([n$5("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")],O),function(e){e[e.Small=12]="Small",e[e.Large=16]="Large";}(U||(U={}));const z={laserLineGlowColor:[1,.5,0],laserLineGlowWidth:8,laserLineGlowFalloff:8,laserLineInnerColor:[1,1,1],laserLineInnerWidth:1,laserLineGlobalAlpha:.75,laserLineEnabled:!0,handleColor:[1,.5,0],handleOpacity:.5,handleRadius:5,handleRadiusHovered:10,handleRadiusMouse:10,handleRadiusTouch:25,pathLineColor:[1,.5,0,1],pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:[1,.5,0,1],perimeterLineWidth:2,projectionLineColor:[1,.5,0,1],projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:[1,.5,0,.5],areaColor2:[1,1,1,.5],fillColor:[1,.5,0,.5],lineSubdivisions:64,labelDistance:25},q={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null},k=new l$5(n$1(),n$1());

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
let d=class extends(n$a(f)){constructor(e){super(e),this.type="area-measurement-view-3d",this.analysis=null,this.measurementData=null,this.lastDraggedVertex=null,this.cursorPoint=null,this.mode=e$1.Auto;}initialize(){const{analysis:e,view:t}=this;this.path=new j({view:t,areaMeasurement:e}),this.analysisVisualization=new O({view:t,analysis:e,analysisViewData:this}),this.analysisController=new u$1({view:t,analysis:e,analysisViewData:this});}destroy(){this.analysisController=l$2(this.analysisController),this.analysisVisualization=l$2(this.analysisVisualization),this.path.destroy();}get updating(){return !!this.analysisVisualization?.loadingMessages}get result(){const{measurementData:e}=this;return t$2(e)?{area:null,mode:null,perimeter:null}:"euclidean"===e.actualMeasurementMode?{area:e.area,perimeter:e.perimeterLength,mode:"euclidean"}:{area:e.geodesicArea,perimeter:e.pathLength,mode:"geodesic"}}get viewData(){return this.analysisVisualization.viewData}get validMeasurement(){return this.path.isValidPolygon}get unit(){return c$4(this.analysis.unit,this._defaultUnit)}get testData(){return {visualization:this.analysisVisualization,controller:this.analysisController}}};e$2([d$2({readOnly:!0})],d.prototype,"type",void 0),e$2([d$2({constructOnly:!0,nonNullable:!0})],d.prototype,"analysis",void 0),e$2([d$2()],d.prototype,"updating",null),e$2([d$2()],d.prototype,"analysisVisualization",void 0),e$2([d$2()],d.prototype,"analysisController",void 0),e$2([d$2()],d.prototype,"result",null),e$2([d$2()],d.prototype,"measurementData",void 0),e$2([d$2()],d.prototype,"viewData",null),e$2([d$2()],d.prototype,"validMeasurement",null),e$2([d$2()],d.prototype,"path",void 0),e$2([d$2()],d.prototype,"lastDraggedVertex",void 0),e$2([d$2()],d.prototype,"cursorPoint",void 0),e$2([d$2()],d.prototype,"mode",void 0),e$2([d$2()],d.prototype,"unit",null),e$2([d$2(r$6)],d.prototype,"_defaultUnit",void 0),d=e$2([n$5("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")],d);const c=d;

var AreaMeasurementAnalysisView3D = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': c
});

export { AreaMeasurementAnalysisView3D as A, n };
