import { m as r, t, bB as r$1, aH as D, aJ as d, cd as r$2, aS as M, cf as t$1, aR as h, dE as b, ce as i$1, as as b$1, aL as e, aI as r$3, ai as E, aV as M$1, aq as P, e6 as U, ar as G, ay as D$1, d3 as o } from './_virtual_index-1ea2035a.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class i{constructor(e,t,i){this.pixelBlock=e,this.extent=t,this.originalPixelBlock=i;}get width(){return r(this.pixelBlock)?this.pixelBlock.width:0}get height(){return r(this.pixelBlock)?this.pixelBlock.height:0}render(e){const i=this.pixelBlock;if(t(i))return;const l=this.filter({pixelBlock:i});if(t(l.pixelBlock))return;const r=l.pixelBlock.getAsRGBA(),o=e.createImageData(l.pixelBlock.width,l.pixelBlock.height);o.data.set(r),e.putImageData(o,0,0);}getRenderedRasterPixels(){const e=this.filter({pixelBlock:this.pixelBlock});return t(e.pixelBlock)?null:{width:e.pixelBlock.width,height:e.pixelBlock.height,renderedRasterPixels:new Uint8Array(e.pixelBlock.getAsRGBA().buffer)}}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
function S(t){return t&&"render"in t}function T(t){const e=document.createElement("canvas");return e.width=t.width,e.height=t.height,t.render(e.getContext("2d")),e}function v(t){return S(t)?t instanceof i?o(t.getRenderedRasterPixels(),(t=>t.renderedRasterPixels)):T(t):t}class R extends r$1{constructor(t=null,e){super(),this.blendFunction="standard",this._sourceWidth=0,this._sourceHeight=0,this._textureInvalidated=!1,this.stencilRef=0,this.coordScale=[1,1],this._height=void 0,this.pixelRatio=1,this.resolution=0,this.rotation=0,this._source=null,this._width=void 0,this.x=0,this.y=0,this.immutable=e.immutable??!1,this.requestRenderOnSourceChangedEnabled=e.requestRenderOnSourceChangedEnabled??!0,this.source=t,this.requestRender=this.requestRender.bind(this);}destroy(){this._texture&&(this._texture.dispose(),this._texture=null),r(this._uploadStatus)&&(this._uploadStatus.controller.abort(),this._uploadStatus=null);}get isSourceScaled(){return this.width!==this._sourceWidth||this.height!==this._sourceHeight}get height(){return void 0!==this._height?this._height:this._sourceHeight}set height(t){this._height=t;}get source(){return this._source}set source(t){null==t&&null==this._source||(this._source=t,this._source instanceof HTMLImageElement?(this._sourceHeight=this._source.naturalHeight,this._sourceWidth=this._source.naturalWidth):(this._sourceHeight=this._source.height,this._sourceWidth=this._source.width),this.invalidateTexture());}get width(){return void 0!==this._width?this._width:this._sourceWidth}set width(t){this._width=t;}beforeRender(t){super.beforeRender(t),this.updateTexture(t);}async setSourceAsync(e,r$1){r(this._uploadStatus)&&this._uploadStatus.controller.abort();const h=new AbortController,o=D();return d(r$1,(()=>h.abort())),d(h,(t=>o.reject(t))),this._uploadStatus={controller:h,resolver:o},this.source=e,o.promise}invalidateTexture(){this._textureInvalidated||(this._textureInvalidated=!0,this.requestRenderOnSourceChangedEnabled&&this.requestRender());}updateTransitionProperties(t,e){t>=64&&(this.fadeTransitionEnabled=!1,this.inFadeTransition=!1),super.updateTransitionProperties(t,e);}setTransform(t){const e=r$2(this.transforms.dvs),[s,i]=t.toScreenNoRotation([0,0],[this.x,this.y]),r=this.resolution/this.pixelRatio/t.resolution,d=r*this.width,c=r*this.height,_=Math.PI*this.rotation/180;M(e,e,t$1(s,i)),M(e,e,t$1(d/2,c/2)),h(e,e,-_),M(e,e,t$1(-d/2,-c/2)),b(e,e,t$1(d,c)),i$1(this.transforms.dvs,t.displayViewMat3,e);}setSamplingProfile(t){this._texture&&(t.mips&&!this._texture.descriptor.hasMipmap&&this._texture.generateMipmap(),this._texture.setSamplingMode(t.samplingMode));}bind(t,e){this._texture&&t.bindTexture(this._texture,e);}async updateTexture({context:e,painter:s}){if(!this._textureInvalidated)return;if(this._textureInvalidated=!1,this._texture||(this._texture=this._createTexture(e)),!this.source)return void this._texture.setData(null);this._texture.resize(this._sourceWidth,this._sourceHeight);const i=v(this.source);try{if(r(this._uploadStatus)){const{controller:t,resolver:e}=this._uploadStatus,r={signal:t.signal},{width:h,height:o}=this,u=this._texture,a=s.textureUploadManager;await a.enqueueTextureUpdate({data:i,texture:u,width:h,height:o},r),e.resolve(),this._uploadStatus=null;}else this._texture.setData(i);this.ready();}catch(h){b$1(h);}}onDetach(){this.destroy();}_createTransforms(){return {dvs:e()}}_createTexture(t){const e=this.immutable&&t.type===r$3.WEBGL2;return new E(t,{target:M$1.TEXTURE_2D,pixelFormat:P.RGBA,internalFormat:e?U.RGBA8:P.RGBA,dataType:G.UNSIGNED_BYTE,wrapMode:D$1.CLAMP_TO_EDGE,isImmutable:e,width:this._sourceWidth,height:this._sourceHeight})}}

export { R, S, T, i };
