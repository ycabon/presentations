import { t as t$1, r, h as L, jL as a, bG as w, a4 as Ke, a7 as b, $ as B } from './_virtual_index-a68dd1ed.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const t={analytics:{supportsCacheHint:!1},attachment:{supportsContentType:!1,supportsExifInfo:!1,supportsKeywords:!1,supportsName:!1,supportsSize:!1,supportsCacheHint:!1,supportsResize:!1},data:{isVersioned:!1,supportsAttachment:!1,supportsM:!1,supportsZ:!1},editing:{supportsDeleteByAnonymous:!1,supportsDeleteByOthers:!1,supportsGeometryUpdate:!1,supportsGlobalId:!1,supportsReturnServiceEditsInSourceSpatialReference:!1,supportsRollbackOnFailure:!1,supportsUpdateByAnonymous:!1,supportsUpdateByOthers:!1,supportsUpdateWithoutM:!1,supportsUploadWithItemId:!1},metadata:{supportsAdvancedFieldProperties:!1},operations:{supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsAdd:!1,supportsDelete:!1,supportsEditing:!1,supportsChangeTracking:!1,supportsQuery:!1,supportsQueryAnalytics:!1,supportsQueryAttachments:!1,supportsQueryTopFeatures:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsUpdate:!1,supportsExceedsLimitStatistics:!1},queryRelated:{supportsCount:!1,supportsOrderBy:!1,supportsPagination:!1,supportsCacheHint:!1},queryTopFeatures:{supportsCacheHint:!1},query:{maxRecordCount:0,maxRecordCountFactor:0,standardMaxRecordCount:0,supportsCacheHint:!1,supportsCentroid:!1,supportsCompactGeometry:!1,supportsDefaultSpatialReference:!1,supportsDisjointSpatialRelationship:!1,supportsDistance:!1,supportsDistinct:!1,supportsExtent:!1,supportsFormatPBF:!1,supportsGeometryProperties:!1,supportsHavingClause:!1,supportsHistoricMoment:!1,supportsMaxRecordCountFactor:!1,supportsOrderBy:!1,supportsPagination:!1,supportsPercentileStatistics:!1,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryByOthers:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsSqlExpression:!1,supportsStandardizedQueriesOnly:!1,supportsTopFeaturesQuery:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsStatistics:!1,tileMaxRecordCount:0}};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class l{constructor(t,r,e,a){this._parsedUrl=t,this._portalItem=r,this._apiKey=e,this.signal=a,this.rootDocument=null;const s=this._parsedUrl.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);s&&(this.urlParts={root:s[1],layerId:parseInt(s[2],10)});}async fetch(){if(!this.urlParts)return null;const t=this._portalItem??await this._portalItemFromServiceItemId();if(t$1(t))return this._loadFromUrl();const r=await this._findAndLoadRelatedPortalItem(t);return t$1(r)?null:this._loadFeatureLayerFromPortalItem(r)}async fetchPortalItem(){if(!this.urlParts)return null;const t=this._portalItem??await this._portalItemFromServiceItemId();return t$1(t)?null:this._findAndLoadRelatedPortalItem(t)}async _fetchRootDocument(){if(r(this.rootDocument))return this.rootDocument;if(t$1(this.urlParts))return this.rootDocument={},{};const t={query:{f:"json",token:this._apiKey},responseType:"json",signal:this.signal},s=`${this.urlParts.root}/SceneServer`;try{const e=await L(s,t);this.rootDocument=e.data;}catch{this.rootDocument={};}return this.rootDocument}async _fetchServiceOwningPortalUrl(){const e=a?.findServerInfo(this._parsedUrl.path);if(e?.owningSystemUrl)return e.owningSystemUrl;const a$1=this._parsedUrl.path.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const t=(await L(a$1,{query:{f:"json"},responseType:"json",signal:this.signal})).data.owningSystemUrl;if(t)return t}catch(i){w(i);}return null}async _findAndLoadRelatedPortalItem(t){try{return (await t.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:this.signal})).find((t=>"Feature Service"===t.type))||null}catch(r){return w(r),null}}async _loadFeatureLayerFromPortalItem(t){await t.load({signal:this.signal});const r=await this._findMatchingAssociatedSublayerUrl(t.url);return new Ke({url:r,portalItem:t}).load({signal:this.signal})}async _loadFromUrl(){const t=await this._findMatchingAssociatedSublayerUrl(`${this.urlParts.root}/FeatureServer`);return new Ke({url:t}).load({signal:this.signal})}async _findMatchingAssociatedSublayerUrl(t){const e=t.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i,"$1"),a={query:{f:"json"},responseType:"json",authMode:"no-prompt",signal:this.signal},s=this.urlParts.layerId,i=this._fetchRootDocument(),o=L(e,a),[n,l]=await Promise.all([o,i]),c=l&&l.layers,h=n.data&&n.data.layers;if(!Array.isArray(h))throw new Error("expected layers array");if(Array.isArray(c))for(let r=0;r<Math.min(c.length,h.length);r++){if(c[r].id===s)return `${e}/${h[r].id}`}else if(s<h.length)return `${e}/${h[s].id}`;throw new Error("could not find matching associated sublayer")}async _portalItemFromServiceItemId(){const t=(await this._fetchRootDocument()).serviceItemId;if(!t)return null;const r$1=new b({id:t,apiKey:this._apiKey}),e=await this._fetchServiceOwningPortalUrl();r(e)&&(r$1.portal=new B({url:e}));try{return r$1.load({signal:this.signal})}catch(i){return w(i),null}}}

export { l, t };
