import { Z as s$1, B as e, C as d, lI as y$1, D as n$1, ge as a, E as f$1, jX as j, bG as e$1, r, t, nd as f$2, o9 as ce, nY as bn, oa as X, k4 as M, R as k, mj as tn, eY as rn, cm as o, ob as x$1, oc as y$2, l0 as h$1, od as v, nX as se, oe as G$1, ev as k$1, b7 as o$1, of as s$2, il as S, fd as u, fu as Bn, aL as o$2, by as t$1, d as b, w, s as s$3, q as x$2, o3 as Ie, bI as t$2, bE as u$1, aZ as n$2, bW as E, kq as G$2, f3 as n$3 } from './_virtual_index-9b831d4a.js';
import { Y } from './QueryEngine-12d30a72.js';
import { e as e$2 } from './centroid-3313e4f0.js';
import { L as L$1 } from './I3SMeshView3D-64bd86c7.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const A="esri.views.3d.layers.i3s.I3SMeshViewFilter",G=s$1.getLogger(A);let x=class extends f$1{constructor(e){super(e),this._projectionEngineLoaded=!1;}initialize(){j((()=>e$1(this.viewFilter)?.geometry||r(this.layerFilter))).then((()=>this.loadAsyncModule(import('./geometryEngine-54622e44.js').then((e=>{this.destroyed||(this._geometryEngine=e,this.applyFilters());})))));}get sortedObjectIds(){if(t(this.viewFilter)||t(this.viewFilter.objectIds))return null;const e=new Float64Array(this.viewFilter.objectIds);return e.sort(),e}get parsedWhereClause(){const e=r(this.viewFilter)?this.viewFilter.where:null;if(t(e)||!e)return null;try{return f$2.create(e,this.layerFieldsIndex)}catch(t){G.error(`Failed to parse filter where clause: ${t}`);}return null}addFilters(e,t,r$1,i){const s=this.sortedObjectIds;r(s)&&e.push((e=>ce(s,!0,e))),this.addSqlFilter(e,this.parsedWhereClause);const o=this._layerMaskGeometries,n=this._geometryEngine;if(r(o)&&r(this.layerFilter)&&r(n)){const s=this.layerFilter.spatialRelationship;e.push(((e,a)=>W(n,e,a,i,t,r$1,o,s)));}const l=this._viewMaskGeometries;if(r(l)&&r(this.viewFilter)&&r(n)){const s=this.viewFilter.spatialRelationship;e.push(((e,o)=>W(n,e,o,i,t,r$1,l,s)));}}isMBSGeometryVisible(e,t,r$1){const i=this._layerMaskGeometries,s=this._geometryEngine;if(r(i)&&r(this.layerFilter)&&r(s)){const o=this.layerFilter.spatialRelationship,n=i[0].spatialReference||t;if(!bn(e,r$1,U,n))return G.warnOnce("SceneLayer.mask geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0;return K(s,U,i,n,o)}const o=this._viewMaskGeometries;if(r(o)&&r(this.viewFilter)&&r(s)){const i=this.viewFilter.spatialRelationship,n=o[0].spatialReference||t;if(!bn(e,r$1,U,n))return G.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0;return K(s,U,o,n,i)}return !0}get parsedGeometry(){const e=this._viewMaskGeometries,t$1=this._layerMaskGeometries;return t(e)||t(t$1)?e||t$1:t$1.concat(e)}get _layerMaskGeometries(){const e=this.layerFilter;return t(e)||t(this._geometryEngine)?null:P(this._geometryEngine,e.geometry,e.spatialRelationship)}get _viewMaskGeometries(){if(t(this.viewFilter)||t(this._geometryEngine))return null;const{geometry:e}=this.viewFilter;if(t(e))return null;const{distance:t$1,units:r$1}=this.viewFilter,i=this.viewFilter.spatialRelationship,s="mesh"===e.type?e.extent:e;if(t(t$1)||0===t$1)return P(this._geometryEngine,s,i);const o=r$1||X(s.spatialReference);if(s.spatialReference.isWGS84){const e=this._geometryEngine.geodesicBuffer(s,t$1,o);return P(this._geometryEngine,e,i)}const l=M(s,k.WGS84);if(r(l)){const e=M(this._geometryEngine.geodesicBuffer(l,t$1,o),s.spatialReference);return P(this._geometryEngine,e,i)}if(!this._projectionEngineLoaded&&(this.loadAsyncModule(tn().then((()=>this._projectionEngineLoaded=!0))),!this._projectionEngineLoaded))return null;let c=null;try{c=rn(s,k.WGS84);}catch(u){}if(c)try{c=rn(this._geometryEngine.geodesicBuffer(c,t$1,o),s.spatialReference);}catch(u){c=null;}return c||G.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${s.spatialReference.wkid}) to WGS84.`),P(this._geometryEngine,c,i)}static checkSupport(e){return !t(e)&&(e.timeExtent?(G.warn("Filters with a timeExtent are not supported for mesh scene layers"),!1):!!B(e.spatialRelationship)||(G.warn(`Filters with spatialRelationship other than ${O.join(", ")} are not supported for mesh scene layers`),!1))}};e([d()],x.prototype,"layerFilter",void 0),e([d({type:y$1})],x.prototype,"viewFilter",void 0),e([d()],x.prototype,"layerFieldsIndex",void 0),e([d()],x.prototype,"loadAsyncModule",void 0),e([d()],x.prototype,"applyFilters",void 0),e([d()],x.prototype,"addSqlFilter",void 0),e([d({readOnly:!0})],x.prototype,"sortedObjectIds",null),e([d({readOnly:!0})],x.prototype,"parsedWhereClause",null),e([d({readOnly:!0})],x.prototype,"parsedGeometry",null),e([d({readOnly:!0})],x.prototype,"_layerMaskGeometries",null),e([d({readOnly:!0})],x.prototype,"_viewMaskGeometries",null),e([d()],x.prototype,"_projectionEngineLoaded",void 0),e([d()],x.prototype,"_geometryEngine",void 0),x=e([n$1(A)],x);const O=(e=>e)(["contains","intersects","disjoint"]);function B(e){return null!=e&&O.includes(e)}var L;function P(e,t$1,s){if(t(t$1))return null;if("disjoint"===s&&"polygon"===t$1.type){const s=new Array(t$1.rings.length);for(let e=0;e<t$1.rings.length;++e){const r=o(1/0,1/0,-1/0,-1/0);x$1(r,t$1.rings[e]),s[e]={type:"polygon",rings:[t$1.rings[e]],spatialReference:t$1.spatialReference,aabr:r};}s.sort(((e,t)=>e.aabr[0]-t.aabr[0]));const o$1=new Set,n=new y$2;for(let t=0;t<s.length;++t){const r=s[t];for(let e=t+1;e<s.length;++e){const t=s[e];if(t.aabr[0]>=r.aabr[2])break;o$1.add(t);}o$1.forEach((t=>{if(r!==t)if(t.aabr[2]<=r.aabr[0])o$1.delete(t);else if(e.intersects(r,t)){r.rings=r.rings.concat(t.rings),h$1(r.aabr,t.aabr,r.aabr),delete r._geVersion,o$1.delete(t);const e=v(s,t,s.length,n);s.splice(e,1);}})),o$1.add(r);}for(const e of s)delete e.aabr;return s}return [t$1]}function K(e,t,r,i,s){const o=q(e,t,i);return r.every((t=>N(e,t,o,s)!==L.DISCARD))}function W(e,t,r,i,s,o,n,a){const l=n[0].spatialReference||s.spatialReference;if(!bn(r.node.mbs,o,U,l))return void G.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");const c=q(e,U,l),p=V(a,s,l,i,r.objectHandle);for(const u of n){if(0===t.length)return;switch(N(e,u,c,a)){case L.DISCARD:return void(t.length=0);case L.KEEP:continue}se(t,r.featureIds,(t=>H(e,u,t,p)));}}!function(e){e[e.KEEP=0]="KEEP",e[e.DISCARD=1]="DISCARD",e[e.TEST=2]="TEST";}(L||(L={}));const U=[0,0,0,0];function V(e,t,r,i,s){const o=t.renderSpatialReference,n=new Map,a={rings:[[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]],hasZ:!1,hasM:!1,type:"polygon",spatialReference:r};a.rings[0][3]=a.rings[0][0];const l={indices:null,data:null,stride:0,startIndex:0,endIndex:0};let c,p;switch(e){case"intersects":c=(e,t,r)=>e.intersects(t,r)?L.KEEP:L.TEST,p=Z;break;case"contains":c=(e,t,r)=>e.contains(t,r)?L.TEST:L.DISCARD,p=Z;break;default:c=(e,t,r)=>e.disjoint(t,r)?L.TEST:L.DISCARD,p=$;}return {collection:i,object:s,type:e,maskSR:r,renderSR:o,aabbCache:n,triangle:a,positions:l,triangleTest:c,geometryTest:p}}function q(e,t,r){const i={x:t[0],y:t[1],hasZ:!1,hasM:!1,type:"point",spatialReference:r},s=!G$1(r)&&!k$1(r),n=Number.isNaN(t[3])?0:o$1(t[3],0,2*s$2.radius),a=s?e.buffer(i,n,1):e.geodesicBuffer(i,n,1);return a.type="polygon",a}function N(e,t,r,i){switch(i){case"intersects":case"contains":return Z(e,t,r);case"disjoint":return $(e,t,r)}}function Z(e,t,r){return e.intersects(t,r)?e.contains(t,r)?L.KEEP:L.TEST:L.DISCARD}function $(e,t,r){return e.intersects(t,r)?e.contains(t,r)?L.DISCARD:L.TEST:L.KEEP}const z=2**-32;function H(e,t,r,i){const{collection:s,object:o,renderSR:n,maskSR:a,geometryTest:l,aabbCache:c}=i;let p=c.get(r);if(!p){const e=s.getObjectTransform(o);s.getComponentAabb(o,r,J);const t=[[J[0],J[1],0],[J[0],J[4],0],[J[3],J[4],0],[J[3],J[1],0]];for(let r=0;r<4;++r)S(t[r],t[r],e.rotationScale),u(t[r],t[r],e.position),Bn(t[r],n,t[r],a);p={rings:[t],hasZ:!1,hasM:!1,type:"polygon",spatialReference:a},p.rings[0][4]=p.rings[0][0],c.set(r,p);}switch(l(e,t,p)){case L.DISCARD:return !1;case L.KEEP:return !0}const{triangle:u$1,triangleTest:g,positions:y}=i,h=u$1.rings[0][0],S$1=u$1.rings[0][1],j=u$1.rings[0][2],w=s.getObjectTransform(o);s.getComponentPositions(o,r,y);const{indices:R,data:b,stride:F,startIndex:v,endIndex:_}=y;for(let I=v;I<_;I+=3){const r=F*R[I+0],i=F*R[I+1],s=F*R[I+2];o$2(h,b[r+0],b[r+1],b[r+2]),o$2(S$1,b[i+0],b[i+1],b[i+2]),o$2(j,b[s+0],b[s+1],b[s+2]),S(h,h,w.rotationScale),S(S$1,S$1,w.rotationScale),S(j,j,w.rotationScale),u(h,h,w.position),u(S$1,S$1,w.position),u(j,j,w.position),Bn(h,n,h,a),Bn(S$1,n,S$1,a),Bn(j,n,j,a);const o=S$1[0]-h[0],l=S$1[1]-h[1],c=j[0]-h[0],p=j[1]-h[1];if(!(Math.abs(o*p-l*c)<z))switch(delete u$1._geVersion,g(e,t,u$1)){case L.DISCARD:return !1;case L.KEEP:return !0}}return "intersects"!==i.type}const J=a();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const l$1=Y;let p=class extends f$1{constructor(e){super(e),this._dataQueryEngineInstance=null,this._handles=new t$1;}get defaultQueryJSON(){return new b({outSpatialReference:this.spatialReference}).toJSON()}get _dataQueryEngine(){return this._ensureDataQueryEngine()}initialize(){this._handles.add(this.layerView.on("visible-geometry-changed",(()=>this.spatialIndex.events.emit("changed"))));}destroy(){this._dataQueryEngineInstance&&(this._dataQueryEngineInstance.destroy(),this._dataQueryEngineInstance=null),this._handles&&(this._handles.destroy(),this._handles=null),this._set("layerView",null);}async executeQueryForCount(e,r){return this._dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e),r)}async executeQueryForExtent(e,r){const{count:t,extent:s}=await this._dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e),r);return {count:t,extent:w.fromJSON(s)}}async executeQueryForIds(e,r){return this._dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e),r)}async executeQuery(e,r){const s=this._ensureQueryJSON(e);if(s.returnGeometry)throw new s$3("feature-store:unsupported-query","returnGeometry is not yet supported for mesh scene layer queries");if(s.returnCentroid)throw new s$3("feature-store:unsupported-query","returnCentroid is not yet supported for mesh scene layer queries");const n=await this._dataQueryEngine.executeQuery(s,r),o=x$2.fromJSON(n);return o.features.forEach((e=>{e.geometry=null;})),o}_ensureQueryJSON(e){return t(e)?this.defaultQueryJSON:e.toJSON()}_ensureDataQueryEngine(){if(this._dataQueryEngineInstance)return this._dataQueryEngineInstance;const e=this.layer.objectIdField||"OBJECTID",r="esriGeometryPolygon",t=this.layer.fields.map((e=>e.toJSON())),s=this.layerView.view.resourceController.scheduler,n=this.spatialReference.toJSON(),o=this.priority,i=this.spatialIndex;return this._dataQueryEngineInstance=new l$1({hasZ:!0,hasM:!1,geometryType:r,fields:t,timeInfo:null,spatialReference:n,objectIdField:e,featureStore:i,scheduler:s,priority:o}),this._dataQueryEngineInstance}};e([d({constructOnly:!0})],p.prototype,"layerView",void 0),e([d({constructOnly:!0})],p.prototype,"priority",void 0),e([d({constructOnly:!0})],p.prototype,"spatialIndex",void 0),e([d({readOnly:!0,aliasOf:"layerView.view.spatialReference"})],p.prototype,"spatialReference",void 0),e([d({readOnly:!0,aliasOf:"layerView.i3slayer"})],p.prototype,"layer",void 0),e([d({readOnly:!0})],p.prototype,"defaultQueryJSON",null),p=e([n$1("esri.views.3d.layers.i3s.I3SQueryEngine")],p);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class n{constructor(t){this.objectIdField=t.objectIdField,this.getFeatureExtent=t.getFeatureExtent;}getObjectId(t){return t.id}getAttributes(e){const{meta:r$1,index:o}=e,n={};this.objectIdField&&(n[this.objectIdField]=e.id);const s=r(r$1.attributeInfo)&&r$1.attributeInfo.attributeData;if(r(s))for(const t of Object.keys(s))n[t]=Ie(s[t],o);return n}getAttribute(e,r$1){if(r$1===this.objectIdField)return e.id;const{meta:o,index:n}=e,s=r(o.attributeInfo)&&o.attributeInfo.attributeData;return r(s)?Ie(s[r$1],n):null}getGeometry(t){if(t.geometry)return t.geometry;const[e,r,i,n,a]=this.getFeatureExtent(t,s);return new t$2([5],[e,r,i,n,r,i,n,a,i,e,a,i,e,r,i])}getCentroid(t,e){if(t.geometry)return e$2(new t$2,t.geometry,e.hasZ,e.hasM);const[i,n,a,m,u,d]=this.getFeatureExtent(t,s);return new t$2([0],[(i+m)/2,(n+u)/2,(a+d)/2])}cloneWithGeometry(t,e){const{id:r,index:o,meta:i}=t;return {id:r,index:o,meta:i,geometry:e}}}const s=a();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
let f=class extends f$1{constructor(r){super(r),this.events=new n$2;}forEach(r){this.forAllFeatures((t=>(r(t),L$1.CONTINUE)));}forEachBounds(r,t,e){const o=this.getFeatureExtent;for(const s of r)t(o(s,e));}forEachInBounds(r,t){this.forAllFeatures((e=>{const o=this.getFeatureExtent(e,y);return E(r,G$2(o,h))&&t(e),L$1.CONTINUE}),(t=>{if(bn(t.node.mbs,this.sourceSpatialReference,l,this.viewSpatialReference),l[0]>=r[0]&&l[2]<=r[2]&&l[1]>=r[1]&&l[3]<=r[3])return L$1.CONTINUE;const e=Math.max(r[0],Math.min(l[0],r[2])),o=Math.max(r[1],Math.min(l[1],r[3])),s=l[0]-e,c=l[1]-o;return s*s+c*c<=l[3]*l[3]?L$1.CONTINUE:L$1.SKIP}));}};e([d({constructOnly:!0})],f.prototype,"featureAdapter",void 0),e([d({constructOnly:!0})],f.prototype,"toArray",void 0),e([d({constructOnly:!0})],f.prototype,"forAllFeatures",void 0),e([d({constructOnly:!0})],f.prototype,"getFeatureExtent",void 0),e([d({constructOnly:!0})],f.prototype,"sourceSpatialReference",void 0),e([d({constructOnly:!0})],f.prototype,"viewSpatialReference",void 0),f=e([n$1("esri.views.3d.layers.i3s.I3SQueryFeatureStore")],f);const l=n$3(),y=a(),h=u$1();

export { f, n, p, x };
