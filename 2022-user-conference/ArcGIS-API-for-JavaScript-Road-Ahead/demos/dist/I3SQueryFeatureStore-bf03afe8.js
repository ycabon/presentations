import { $ as s$1, u as e, y as y$1, pT as y$2, z as n$1, gL as a, A as m, kH as j, L as e$1, m as r, t, qO as f$1, rA as ae, ro as kn, rB as X$1, kV as M, O as k, oz as tn, fr as rn, cB as o, rC as x, rD as x$1, lN as h, rE as b, rm as oe, ne as G, fA as k$1, bb as a$1, rF as s$2, j5 as S, g0 as u$1, gm as jn, aO as o$1, bC as t$2, x as x$2, w, E as s$3, k as x$3, ra as o$2, rn as be, bL as t$3, bI as u$2, b1 as n$3, bX as E, lf as B$1, fR as n$4 } from './_virtual_index-1ea2035a.js';
import { a as t$1, n as n$2, u } from './DefinitionExpressionSceneLayerView-04af8164.js';
import { Y } from './QueryEngine-c226e0c5.js';
import { e as e$2 } from './centroid-205dc6cf.js';
import { L as L$1 } from './I3SMeshView3D-ae8ce576.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const O="esri.views.3d.layers.i3s.I3SMeshViewFilter",B=s$1.getLogger(O);let L=class extends m{constructor(e){super(e),this._projectionEngineLoaded=!1;}initialize(){j((()=>e$1(this.viewFilter)?.geometry||r(this.layerFilter))).then((()=>this.loadAsyncModule(import('./geometryEngine-d05be472.js').then((e=>{this.destroyed||(this._geometryEngine=e);})))));}get sortedObjectIds(){if(t(this.viewFilter)||t(this.viewFilter.objectIds))return null;const e=new Float64Array(this.viewFilter.objectIds);return e.sort(),e}get parsedWhereClause(){const e=r(this.viewFilter)?this.viewFilter.where:null;if(t(e)||!e)return null;try{return f$1.create(e,this.layerFieldsIndex)}catch(t){B.error(`Failed to parse filter where clause: ${t}`);}return null}addFilters(e,t,r$1,i){const s=this.sortedObjectIds;r(s)&&e.push((e=>ae(s,!0,e))),this.addSqlFilter(e,this.parsedWhereClause);const n=t$1(this._layerMaskGeometries),o=this._geometryEngine;if(r(n)&&r(this.layerFilter)&&r(o)){const s=this.layerFilter.spatialRelationship;e.push(((e,a)=>q(o,e,a,i,t,r$1,n,s)));}const c=t$1(this._viewMaskGeometries);if(r(c)&&r(this.viewFilter)&&r(o)){const s=this.viewFilter.spatialRelationship;e.push(((e,n)=>q(o,e,n,i,t,r$1,c,s)));}}isMBSGeometryVisible(e,t,r$1){const i=t$1(this._layerMaskGeometries),s=this._geometryEngine;if(r(i)&&r(this.layerFilter)&&r(s)){const n=this.layerFilter.spatialRelationship,o=i[0].spatialReference||t;if(!kn(e,r$1,N,o))return B.warnOnce("SceneLayer.mask geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0;return V(s,N,i,o,n)}const n=t$1(this._viewMaskGeometries);if(r(n)&&r(this.viewFilter)&&r(s)){const i=this.viewFilter.spatialRelationship,o=n[0].spatialReference||t;if(!kn(e,r$1,N,o))return B.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0;return V(s,N,n,o,i)}return !0}get parsedGeometry(){const e=t$1(this._viewMaskGeometries),t$2=t$1(this._layerMaskGeometries);return t(e)||t(t$2)?e||t$2:t$2.concat(e)}get _layerMaskGeometries(){const e=this.layerFilter;return t(e)?null:t(this._geometryEngine)?n$2:"disjoint"===e.spatialRelationship?e.geometries.map((e=>({type:"polygon",rings:e.rings,spatialReference:e.spatialReference,cache:{}}))):[e.geometries.reduce(((e,t)=>(e.rings=e.rings.concat(t.rings),e)),{type:"polygon",rings:[],spatialReference:e.geometries[0].spatialReference,cache:{}})]}get _viewMaskGeometries(){if(t(this.viewFilter))return null;const{geometry:e}=this.viewFilter;if(t(e))return null;if(t(this.viewFilter)||t(this._geometryEngine))return n$2;const{distance:t$1,units:r$1}=this.viewFilter,i=this.viewFilter.spatialRelationship,s="mesh"===e.type?e.extent:e;if(t(t$1)||0===t$1)return W(this._geometryEngine,s,i);const n=r$1||X$1(s.spatialReference);if(s.spatialReference.isWGS84){const e=this._geometryEngine.geodesicBuffer(s,t$1,n);return W(this._geometryEngine,e,i)}const c=M(s,k.WGS84);if(r(c)){const e=M(this._geometryEngine.geodesicBuffer(c,t$1,n),s.spatialReference);return W(this._geometryEngine,e,i)}if(!this._projectionEngineLoaded&&(this.loadAsyncModule(tn().then((()=>this._projectionEngineLoaded=!0))),!this._projectionEngineLoaded))return null;let l=null;try{l=rn(s,k.WGS84);}catch(u){}if(l)try{l=rn(this._geometryEngine.geodesicBuffer(l,t$1,n),s.spatialReference);}catch(u){l=null;}return l||B.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${s.spatialReference.wkid}) to WGS84.`),W(this._geometryEngine,l,i)}get updating(){return u(this._layerMaskGeometries)||u(this._viewMaskGeometries)}static checkSupport(e){return !t(e)&&(e.timeExtent?(B.warn("Filters with a timeExtent are not supported for mesh scene layers"),!1):!!K(e.spatialRelationship)||(B.warn(`Filters with spatialRelationship other than ${P.join(", ")} are not supported for mesh scene layers`),!1))}};e([y$1()],L.prototype,"layerFilter",void 0),e([y$1({type:y$2})],L.prototype,"viewFilter",void 0),e([y$1()],L.prototype,"layerFieldsIndex",void 0),e([y$1()],L.prototype,"loadAsyncModule",void 0),e([y$1()],L.prototype,"addSqlFilter",void 0),e([y$1({readOnly:!0})],L.prototype,"sortedObjectIds",null),e([y$1({readOnly:!0})],L.prototype,"parsedWhereClause",null),e([y$1({readOnly:!0})],L.prototype,"parsedGeometry",null),e([y$1({readOnly:!0})],L.prototype,"_layerMaskGeometries",null),e([y$1({readOnly:!0})],L.prototype,"_viewMaskGeometries",null),e([y$1()],L.prototype,"updating",null),e([y$1()],L.prototype,"_projectionEngineLoaded",void 0),e([y$1()],L.prototype,"_geometryEngine",void 0),L=e([n$1(O)],L);const P=(e=>e)(["contains","intersects","disjoint"]);function K(e){return null!=e&&P.includes(e)}var U;function W(e,t$1,s){if(t(t$1))return null;if("disjoint"===s&&"polygon"===t$1.type){const s=t$1.rings.length,n=t$1.spatialReference,o$1=new Array(s);for(let e=0;e<s;++e){const r=o(1/0,1/0,-1/0,-1/0);x(r,t$1.rings[e]),o$1[e]={type:"polygon",rings:[t$1.rings[e]],spatialReference:n,cache:{},aabr:r};}o$1.sort(((e,t)=>e.aabr[0]-t.aabr[0]));const a=new Set,c=new x$1;for(let t=0;t<o$1.length;++t){const r=o$1[t],s=r.aabr[0];a.forEach((t=>{if(s>=t.aabr[2])return void a.delete(t);if(r.aabr[1]>t.aabr[3]||r.aabr[3]<t.aabr[1]||!e.intersects(r,t))return;r.rings=r.rings.concat(t.rings),h(r.aabr,t.aabr,r.aabr),r.cache={},a.delete(t);const n=b(o$1,t,o$1.length,c);o$1.splice(n,1);})),a.add(r);}for(const e of o$1)delete e.aabr;return o$1}return [t$1]}function V(e,t,r,i,s){const n=z(e,t,i);return r.every((t=>H(e,t,n,s)!==U.DISCARD))}function q(e,t,r,i,s,n,o,a){const c=o[0].spatialReference||s.spatialReference;if(!kn(r.node.mbs,n,N,c))return void B.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");const l=z(e,N,c),p=$(a,s,c,i,r.objectHandle);for(const u of o){if(0===t.length)return;switch(H(e,u,l,a)){case U.DISCARD:return void(t.length=0);case U.KEEP:continue}oe(t,r.featureIds,(t=>Q(e,u,t,p)));}}!function(e){e[e.KEEP=0]="KEEP",e[e.DISCARD=1]="DISCARD",e[e.TEST=2]="TEST";}(U||(U={}));const N=[0,0,0,0];function $(e,t,r,i,s){const n=t.renderSpatialReference,o=new Map,a={type:"polygon",rings:[[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]],spatialReference:r};a.rings[0][3]=a.rings[0][0];const c={indices:null,data:null,stride:0,startIndex:0,endIndex:0};let l,p;switch(e){case"intersects":l=(e,t,r)=>e.intersects(t,r)?U.KEEP:U.TEST,p=Z;break;case"contains":l=(e,t,r)=>e.contains(t,r)?U.TEST:U.DISCARD,p=Z;break;default:l=(e,t,r)=>e.disjoint(t,r)?U.TEST:U.DISCARD,p=J;}return {collection:i,object:s,type:e,maskSR:r,renderSR:n,aabbCache:o,triangle:a,positions:c,triangleTest:l,geometryTest:p}}function z(e,t,r){const i={type:"point",x:t[0],y:t[1],hasZ:!1,hasM:!1,spatialReference:r},s=!G(r)&&!k$1(r),o=Number.isNaN(t[3])?0:a$1(t[3],0,2*s$2.radius),a=s?e.buffer(i,o,1):e.geodesicBuffer(i,o,1);return a.type="polygon",a}function H(e,t,r,i){switch(i){case"intersects":case"contains":return Z(e,t,r);case"disjoint":return J(e,t,r)}}function Z(e,t,r){return e.intersects(t,r)?e.contains(t,r)?U.KEEP:U.TEST:U.DISCARD}function J(e,t,r){return e.intersects(t,r)?e.contains(t,r)?U.DISCARD:U.TEST:U.KEEP}function Q(e,t,r,i){const{collection:s,object:n,renderSR:o,maskSR:a,geometryTest:c,aabbCache:l}=i;let p=l.get(r);if(!p){const e=s.getObjectTransform(n);s.getComponentAabb(n,r,X);const t=[[X[0],X[1],0],[X[0],X[4],0],[X[3],X[4],0],[X[3],X[1],0]];for(let r=0;r<4;++r)S(t[r],t[r],e.rotationScale),u$1(t[r],t[r],e.position),jn(t[r],o,t[r],a);p={type:"polygon",rings:[t],spatialReference:a,cache:{}},p.rings[0][4]=p.rings[0][0],l.set(r,p);}switch(c(e,t,p)){case U.DISCARD:return !1;case U.KEEP:return !0}const{triangle:u,triangleTest:g,positions:m}=i,f=u.rings[0][0],d=u.rings[0][1],S$1=u.rings[0][2],w=s.getObjectTransform(n);s.getComponentPositions(n,r,m);const{indices:R,data:E,stride:v,startIndex:F,endIndex:_}=m;for(let k=F;k<_;k+=3){const r=v*R[k+0],i=v*R[k+1],s=v*R[k+2];switch(o$1(f,E[r+0],E[r+1],E[r+2]),o$1(d,E[i+0],E[i+1],E[i+2]),o$1(S$1,E[s+0],E[s+1],E[s+2]),S(f,f,w.rotationScale),S(d,d,w.rotationScale),S(S$1,S$1,w.rotationScale),u$1(f,f,w.position),u$1(d,d,w.position),u$1(S$1,S$1,w.position),jn(f,o,f,a),jn(d,o,d,a),jn(S$1,o,S$1,a),g(e,t,u)){case U.DISCARD:return !1;case U.KEEP:return !0}}return "intersects"!==i.type}const X=a();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const p=Y;let d$1=class extends m{constructor(e){super(e),this._dataQueryEngineInstance=null,this._handles=new t$2;}get spatialReference(){return this.layerView.view.spatialReference}get layer(){return this.layerView.i3slayer}get defaultQueryJSON(){return new x$2({outSpatialReference:this.spatialReference}).toJSON()}get _dataQueryEngine(){return this._ensureDataQueryEngine()}initialize(){this._handles.add(this.layerView.on("visible-geometry-changed",(()=>this.spatialIndex.events.emit("changed"))));}destroy(){this._dataQueryEngineInstance&&(this._dataQueryEngineInstance.destroy(),this._dataQueryEngineInstance=null),this._handles&&(this._handles.destroy(),this._handles=null),this._set("layerView",null);}async executeQueryForCount(e,r){return this._dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e),r)}async executeQueryForExtent(e,r){const{count:t,extent:s}=await this._dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e),r);return {count:t,extent:w.fromJSON(s)}}async executeQueryForIds(e,r){return this._dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e),r)}async executeQuery(e,r){const s=this._ensureQueryJSON(e);if(s.returnGeometry)throw new s$3("feature-store:unsupported-query","returnGeometry is not yet supported for mesh scene layer queries");if(s.returnCentroid)throw new s$3("feature-store:unsupported-query","returnCentroid is not yet supported for mesh scene layer queries");const n=await this._dataQueryEngine.executeQuery(s,r),o=x$3.fromJSON(n);return o.features.forEach((e=>{e.geometry=null;})),o}_ensureQueryJSON(e){return t(e)?this.defaultQueryJSON:e.toJSON()}_ensureDataQueryEngine(){if(this._dataQueryEngineInstance)return this._dataQueryEngineInstance;const e=this.layer.objectIdField||o$2,r="esriGeometryPolygon",t=this.layer.fields.map((e=>e.toJSON())),s=this.layerView.view.resourceController.scheduler,n=this.spatialReference.toJSON(),o=this.priority,i=this.spatialIndex;return this._dataQueryEngineInstance=new p({hasZ:!0,hasM:!1,geometryType:r,fields:t,timeInfo:null,spatialReference:n,objectIdField:e,featureStore:i,scheduler:s,priority:o}),this._dataQueryEngineInstance}};e([y$1({constructOnly:!0})],d$1.prototype,"layerView",void 0),e([y$1({constructOnly:!0})],d$1.prototype,"priority",void 0),e([y$1({constructOnly:!0})],d$1.prototype,"spatialIndex",void 0),e([y$1()],d$1.prototype,"spatialReference",null),e([y$1()],d$1.prototype,"layer",null),e([y$1()],d$1.prototype,"defaultQueryJSON",null),d$1=e([n$1("esri.views.3d.layers.i3s.I3SQueryEngine")],d$1);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class n{constructor(t){this._objectIdField=t.objectIdField,this._getFeatureExtent=t.getFeatureExtent;}getObjectId(t){return t.id}getAttributes(e){const{meta:r$1,index:o}=e,n={};this._objectIdField&&(n[this._objectIdField]=e.id);const s=r(r$1.attributeInfo)&&r$1.attributeInfo.attributeData;if(r(s))for(const t of Object.keys(s))n[t]=be(s[t],o);return n}getAttribute(e,r$1){if(r$1===this._objectIdField)return e.id;const{meta:o,index:n}=e,s=r(o.attributeInfo)&&o.attributeInfo.attributeData;return r(s)?be(s[r$1],n):null}getGeometry(t){if(t.geometry)return t.geometry;const[e,r,i,n,a]=this._getFeatureExtent(t,s);return new t$3([5],[e,r,i,n,r,i,n,a,i,e,a,i,e,r,i])}getCentroid(t,e){if(t.geometry)return e$2(new t$3,t.geometry,e.hasZ,e.hasM);const[i,n,a,m,u,d]=this._getFeatureExtent(t,s);return new t$3([0],[(i+m)/2,(n+u)/2,(a+d)/2])}cloneWithGeometry(t,e){const{id:r,index:o,meta:i}=t;return {id:r,index:o,meta:i,geometry:e}}}const s=a();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
let f=class extends m{constructor(t){super(t),this.events=new n$3;}forEach(t){this.forAllFeatures((r=>(t(r),L$1.CONTINUE)));}forEachBounds(t,r,e){const o=this.getFeatureExtent;for(const s of t)r(o(s,e));}forEachInBounds(t,r){this.forAllFeatures((e=>{const o=this.getFeatureExtent(e,y);return E(t,B$1(o,d))&&r(e),L$1.CONTINUE}),(r=>{if(kn(r.node.mbs,this.sourceSpatialReference,l,this.viewSpatialReference),l[0]>=t[0]&&l[2]<=t[2]&&l[1]>=t[1]&&l[3]<=t[3])return L$1.CONTINUE;const e=Math.max(t[0],Math.min(l[0],t[2])),o=Math.max(t[1],Math.min(l[1],t[3])),s=l[0]-e,c=l[1]-o;return s*s+c*c<=l[3]*l[3]?L$1.CONTINUE:L$1.SKIP}));}};e([y$1({constructOnly:!0})],f.prototype,"featureAdapter",void 0),e([y$1({constructOnly:!0})],f.prototype,"toArray",void 0),e([y$1({constructOnly:!0})],f.prototype,"forAllFeatures",void 0),e([y$1({constructOnly:!0})],f.prototype,"getFeatureExtent",void 0),e([y$1({constructOnly:!0})],f.prototype,"sourceSpatialReference",void 0),e([y$1({constructOnly:!0})],f.prototype,"viewSpatialReference",void 0),f=e([n$1("esri.views.3d.layers.i3s.I3SQueryFeatureStore")],f);const l=n$4(),y=a(),d=u$2();

export { L, d$1 as d, f, n };
