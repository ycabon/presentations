import { gz as e, s as s$1, t as t$1, cc as I, cd as E$1, r as r$2, gA as H, gB as v$1, gC as l$1, bm as e$1, gD as l$2, dW as a$1 } from './_virtual_index-4b72c57d.js';
import { s as s$3 } from './quantizationUtils-994cbb23.js';
import { WhereClause as f$1 } from './WhereClause-86b394c4.js';
import { T, s as s$2, m, c as c$2, V, g as g$1, h, y, D, z, f as f$2, d as d$1 } from './utils-c6710c6a.js';
import { g } from './projectionSupport-8e09cd0f.js';
import { x, J, O } from './utils-a3792e07.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class c$1{constructor(e$1,c){this._cache=new e(e$1),this._invalidCache=new e(c);}get(t,c){const i=`${c.uid}:${t}`,r=this._cache.get(i);if(r)return r;if(void 0!==this._invalidCache.get(i))return null;try{const r=f$1.create(t,c);return this._cache.put(i,r),r}catch{return this._invalidCache.put(i,null),null}}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const s=new c$1(50,500),n="feature-store:unsupported-query",t=" as ",r$1=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function o(i,t){if(!t)return !0;const r=s.get(t,i);if(!r)throw new s$1(n,"invalid SQL expression",{where:t});if(!r.isStandardized)throw new s$1(n,"where clause is not standard",{where:t});return c(i,r.fieldNames,"where clause contains missing fields"),!0}function a(i,t,r){if(!t)return !0;const o=s.get(t,i);if(!o)throw new s$1(n,"invalid SQL expression",{having:t});if(!o.isAggregate)throw new s$1(n,"having does not contain a valid aggregate function",{having:t});const a=o.fieldNames;c(i,a,"having contains missing fields");if(!o.getExpressions().every((e=>{const{aggregateType:s,field:n}=e,t=i.has(n)&&i.get(n).name;return r.some((e=>{const{onStatisticField:n,statisticType:r}=e;return (i.has(n)&&i.get(n).name)===t&&r.toLowerCase().trim()===s}))})))throw new s$1(n,"expressions in having should also exist in outStatistics",{having:t});return !0}function l(e,i){return e?s.get(e,i):null}function c(i,s,t,r=!0){const o=[];for(const u of s)if("*"!==u&&!i.has(u))if(r){const s=d(u);try{const t=l(s,i);if(!t)throw new s$1(n,"invalid SQL expression",{where:s});if(!t.isStandardized)throw new s$1(n,"expression is not standard",{clause:t});c(i,t.fieldNames,"expression contains missing fields");}catch(a){const e=a&&a.details;if(e&&(e.clause||e.where))throw a;e&&e.missingFields?o.push(...e.missingFields):o.push(u);}}else o.push(u);if(o.length)throw new s$1(n,t,{missingFields:o})}function d(e){return e.split(t)[0]}function u(e){return e.split(t)[1]}function f(e,i){const s=i.get(e);return !!s&&!r$1.has(s.type)}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class r{constructor(t,a,r){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues,this.fieldsIndex=r,this.featureAdapter=a;const l$1=t.outFields;if(l$1&&!l$1.includes("*")){this.outFields=l$1;let t=0;for(const a of l$1){const l$1=d(a),u$1=this.fieldsIndex.get(l$1),n=u$1?null:l(l$1,r),c=u$1?u$1.name:u(a)||"FIELD_EXP_"+t++;this._fieldDataCache.set(a,{alias:c,clause:n});}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){const a=i?i.name:e;let r=null;return this._fieldDataCache.has(a)?r=this._fieldDataCache.get(a).clause:i||(r=l(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:r})),i?this.featureAdapter.getAttribute(t,a):r.calculateValue(t,this.featureAdapter)}getNormalizedValue(t,e){const s=e.normalizationType,i=e.normalizationTotal;let r=this.getFieldValue(t,e.field,e.fieldInfo);if(s&&Number.isFinite(r)){const l=this.getFieldValue(t,e.normalizationField,e.normalizationFieldInfo);r=T(r,s,l,i);}return r}getExpressionValue(t,e,s,i){const a={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},r=i.createExecContext(a,s);return i.executeFunction(e,r)}getExpressionValues(t,e,s,i){const a={fields:this.fieldsIndex.fields};return t.map((t=>{const r={attributes:this.featureAdapter.getAttributes(t),layer:a},l=i.createExecContext(r,s);return i.executeFunction(e,l)}))}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:l(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testFeature(t,this.featureAdapter)}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:l(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testSet(t,this.featureAdapter)}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const s={};for(const i of e){const{alias:e,clause:a}=this._fieldDataCache.get(i);s[e]=a?a.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,e);}return s}_processAttributesForDistinctValues(e){if(t$1(e)||!this.returnDistinctValues)return e;const s=this.outFields,i=[];if(s)for(const t of s){const{alias:s}=this._fieldDataCache.get(t);i.push(e[s]);}else for(const t in e)i.push(e[t]);const a=`${(s||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++r),r>1?null:e}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class v{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter;}get size(){return this.items.length}createQueryResponseForCount(){const e=new r(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!!!a)return 1;const r$1=new Map,n=new Map,o=new Set;for(const l of s){const{statisticType:s}=l,a="exceedslimit"!==s?l.onStatisticField:void 0;if(!n.has(a)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,r$1);i.push(t);}n.set(a,this._calculateUniqueValues(i,e.returnDistinctValues));}const u=n.get(a);for(const t in u){const{data:s,items:a}=u[t],r=s.join(",");i&&!e.validateItems(a,i)||o.add(r);}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query);}else e=this._createFeatureQueryResponse(this.query);return this.query.returnQueryGeometry&&(I(this.query.outSR)&&!E$1(this.query.geometry.spatialReference,this.query.outSR)?e.queryGeometry=x({spatialReference:this.query.outSR,...g(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR)}):e.queryGeometry=x({spatialReference:this.query.outSR,...this.query.geometry})),e}createSnappingResponse(t,i){const s=this.featureAdapter,a=A(this.hasZ,this.hasM),{x:r,y:n}=t.point,o="number"==typeof t.distance?t.distance:t.distance.x,l="number"==typeof t.distance?t.distance:t.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,m=this._getPointCreator(t.point,this.spatialReference,i);for(const d of this.items){const i=s.getGeometry(d);if(t$1(i))continue;const{coords:h,lengths:g}=i;if(t.types&E.EDGE){let e=0;for(let t=0;t<g.length;t++){const i=g[t];for(let t=0;t<i;t++,e+=a){const c=h[e],g=h[e+1];if(t!==i-1){const t=h[e+a],i=h[e+a+1],{x:p,y:f}=R(r,n,c,g,t,i),y=(r-p)/o,x=(n-f)/l,I=y*y+x*x;I<=1&&u.candidates.push({type:"edge",objectId:s.getObjectId(d),distance:Math.sqrt(I),target:m(p,f),start:m(c,g),end:m(t,i)});}}}}if(t.types&E.VERTEX){const e=c?h.length-a:h.length;for(let t=0;t<e;t+=a){const e=h[t],i=h[t+1],a=(r-e)/o,c=(n-i)/l,g=a*a+c*c;g<=1&&u.candidates.push({type:"vertex",objectId:s.getObjectId(d),distance:Math.sqrt(g),target:m(e,i)});}}}return u.candidates.sort(((e,t)=>e.distance-t.distance)),u}_getPointCreator(e,i,s){const a=r$2(s)&&!E$1(i,s)?e=>g(e,i,s):e=>e;return null!=e.z&&null!=e.m?(t,i)=>a({x:t,y:i,z:e.z,m:e.m}):null!=e.z?(t,i)=>a({x:t,y:i,z:e.z}):null!=e.m?(t,i)=>a({x:t,y:i,m:e.m}):(e,t)=>a({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l}=e,u=this.fieldsIndex.isDateField(t),c=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:l}),m$1=s$2({normalizationType:a,normalizationField:s,minValue:n,maxValue:o}),d=this.fieldsIndex.get(t),h={value:.5,fieldType:d?.type},I=H(d)?m({values:c,supportsNullCount:m$1,percentileParams:h}):c$2({values:c,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:m$1,percentileParams:h});return V(I,u)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domain:s,returnAllCodedValues:a,scale:r}=e,n=await this._getDataValues({field:t,valueExpression:i,scale:r}),o=g$1(n);return h(o,s,a)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:m}=e,d=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:m}),h=y(d,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return D(h,n)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:m}=e,d=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:m});return z(d,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=t[1]&&"desc"===t[1].toLowerCase(),o=f$2(r?.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}));}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:h,returnZ:g,returnM:p}=e,f=null!=d&&t.length>(h||0)+d,y=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return {exceededTransferLimit:f,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&p,hasZ:a&&g,objectIdFieldName:r,spatialReference:x(u||o),transform:c&&s$3(c)||null}}_createFeatures(e,t){const i=new r(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r$1,quantizationParameters:o,returnGeometry:l,returnCentroid:c,maxAllowableOffset:m,resultOffset:g,resultRecordCount:p,returnZ:f=!1,returnM:y=!1}=e,x=a&&f,I=s&&y;let T=[],V=0;const F=[...t];if(this._sortFeatures(F,r$1,((e,t,s)=>i.getFieldValue(e,t,s))),l||c){const e=s$3(o);if(l&&!c)for(const t of F)T[V++]={attributes:i.getAttributes(t),geometry:J(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,x,I)};else if(!l&&c)for(const t of F)T[V++]={attributes:i.getAttributes(t),centroid:O(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)T[V++]={attributes:i.getAttributes(t),centroid:O(this,this.featureAdapter.getCentroid(t,this),e),geometry:J(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,x,I)};}else for(const n of F){const e=i.getAttributes(n);e&&(T[V++]={attributes:e});}const z=g||0;if(null!=p){const e=z+p;T=T.slice(z,Math.min(T.length,e));}return T}_createExceedsLimitQueryResponse(e){let i=!1,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const t of e.outStatistics)if("exceedslimit"===t.statisticType){s=null!=t.maxPointCount?t.maxPointCount:Number.POSITIVE_INFINITY,a=null!=t.maxRecordCount?t.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=t.maxVertexCount?t.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>s;else if(this.items.length>a)i=!0;else {const e=this.hasZ?this.hasM?4:3:this.hasM?3:2,s=this.featureAdapter;i=this.items.reduce(((e,i)=>{const a=s.getGeometry(i);return e+(r$2(a)&&a.coords.length||0)}),0)/e>r;}return {fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,r$1=new Map,n=new Map,o=new r(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:c,having:m,orderByFields:d}=e,h=c&&c.length,g=!!h,p=g&&c[0],f=g&&!this.fieldsIndex.get(p);for(const u of l){const{outStatisticFieldName:e,statisticType:l}=u,d=u,y="exceedslimit"!==l?u.onStatisticField:void 0,x="percentile_disc"===l||"percentile_cont"===l,I="EnvelopeAggregate"===l||"CentroidAggregate"===l||"ConvexHullAggregate"===l,T=g&&1===h&&(y===p||f)&&"count"===l;if(g){if(!r$1.has(y)){const e=[];for(const t of c){const i=this._getAttributeValues(o,t,s);e.push(i);}r$1.set(y,this._calculateUniqueValues(e,o.returnDistinctValues));}const t=r$1.get(y);for(const i in t){const{count:a,data:r,items:l,itemPositions:u}=t[i],h=r.join(",");if(!m||o.validateItems(l,m)){const t=n.get(h)||{attributes:{}};if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,l);t.aggregateGeometries[i]=e;}else {let i=null;if(T)i=a;else {const e=this._getAttributeValues(o,y,s),t=u.map((t=>e[t]));i=x&&"statisticParameters"in d?this._getPercentileValue(d,t):this._getStatisticValue(d,t,null,o.returnDistinctValues);}t.attributes[e]=i;}c.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:`EXPR_${i+1}`]=r[i])),n.set(h,t);}}}else if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,this.items);t.aggregateGeometries[i]=e;}else {const i=this._getAttributeValues(o,y,s);t.attributes[e]=x&&"statisticParameters"in d?this._getPercentileValue(d,i):this._getStatisticValue(d,i,a,o.returnDistinctValues);}i.push({name:e,alias:e,type:"esriFieldTypeDouble"});}const y=g?Array.from(n.values()):[t];return this._sortFeatures(y,d,((e,t)=>e.attributes[t])),{fields:i,features:y}}async _getAggregateGeometry(e,t){const n=await import('./geometryEngineJSON-c7445cad.js'),{statisticType:o,outStatisticFieldName:l}=e,{featureAdapter:u,spatialReference:c,geometryType:m,hasZ:h,hasM:g}=this,p=t.map((e=>J(m,h,g,u.getGeometry(e)))),f=n.convexHull(c,p,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=f?v$1(f):l$1(n.union(c,p));y.aggregateGeometries={...e,spatialReference:c},y.outStatisticFieldName=l||"extent";}else if("CentroidAggregate"===o){const e=f?e$1(f):l$2(l$1(n.union(c,p)));y.aggregateGeometries={x:e[0],y:e[1],spatialReference:c},y.outStatisticFieldName=l||"centroid";}else "ConvexHullAggregate"===o&&(y.aggregateGeometries=f,y.outStatisticFieldName=l||"convexHull");return y}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;n=i?.has(a)?i.get(a):H(this.fieldsIndex.get(a))?m({values:t,returnDistinct:s}):c$2({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i);return d$1(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:"percentile_disc"===a})}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map((i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await a$1(),a=s.createFunction(t),r=i&&s.getViewInfo(i);return e.getExpressionValues(this.items,a,r,s)}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let r=0;r<a;r++){const a=s[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");t?null==i[o]&&(i[o]={count:1,data:n,items:[a],itemPositions:[r]}):null==i[o]?i[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i[o].count++,i[o].items.push(a),i[o].itemPositions.push(r));}return i}async _getDataValues(e){const t=new r(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:a,normalizationType:r$1,normalizationTotal:n,scale:o}=e,l=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(t,i,l):this._getAttributeNormalizedValues(t,{field:s,normalizationField:a,normalizationType:r$1,normalizationTotal:n})}}function R(e,t,i,s,a,r){const n=a-i,o=r-s,l=n*n+o*o,u=(e-i)*n+(t-s)*o,c=Math.min(1,Math.max(0,u/l));return {x:i+n*c,y:s+o*c}}function A(e,t){return e?t?4:3:t?3:2}var E;!function(e){e[e.NONE=0]="NONE",e[e.EDGE=1]="EDGE",e[e.VERTEX=2]="VERTEX";}(E||(E={}));

export { E, a, c, f, l, o, v };
