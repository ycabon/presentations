import { t, m as r, e$ as g, I as x, gf as I, gg as y, f2 as k, gh as p, u as e$1, A as m, gi as h$1, y as y$1, z as n } from './_virtual_index-1ea2035a.js';
import { i } from './dehydratedFeatureComparison-73cd17db.js';
import { G } from './dragEventPipeline-b225d16a.js';
import { e } from './SnappingContext-a1ff8c28.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class u{constructor(){this.next=new G;}createSnapDragEventPipelineStep({predicate:o=(()=>!0),cancel:i,snappingManager:r$1,snappingContext:p$1,updatingHandles:l,useZ:c=!0}){if(t(r$1))return e=>e;let u=null,d=null;const f=()=>{u=p(u),r$1.doneSnapping(),r(d)&&d.frameTask.remove(),d=null;};i.next((e=>(f(),e))),this.next=new G;const m=this._createSnapFunction(r$1,c);let h=null,S=null,x=null;return n=>{if(!o(n))return n;if("start"===n.action){const e=this._createFrameTask(r$1.view);if(d=this._createSnappingInfo(p$1,n,e),d.context.selfSnappingZ=null,!c&&r(n.info)){const e=this._extractSelfSnappingZ(p$1.coordinateHelper,n.info.handle.component);r(e)&&(d.context.selfSnappingZ={value:e,elevationInfo:p$1.elevationInfo});}}if(r(d)){const{context:t$1,originalScenePos:o,originalPos:i}=d,{mapEnd:s,mapStart:p,action:f,scenePoints:P}=n,g$1=this._updatePosition(i,this._computeMapDelta(s,p)),_=this._computeMapDelta(p,i),y={...n,action:"update"},v=d.context,Z=this._updateScenePosition(o,P),T=r$1.update({point:g$1,scenePoint:Z,context:t$1});if(x=T,this._applySnappedUpdate(s,T,_,c),h=g$1,S=Z,"end"!==f){const{frameTask:t$1}=d;t(u)&&(u=new AbortController),l.addPromise(g(m({frameTask:t$1,event:y,context:v,point:g$1,scenePoint:Z,delta:_,lastPos:h,lastScenePos:S,lastUpdate:x},u.signal)));}}return "end"===n.action&&f(),n}}_createSnapFunction(e,n){return x((async({frameTask:a,point:o,scenePoint:r$1,context:s,event:p,delta:l,lastPos:c,lastScenePos:u,lastUpdate:d},f)=>{const m=await a.schedule((()=>e.snap({point:o,scenePoint:r$1,context:s,signal:f})),f);if(m.valid){let r$1=await a.schedule((()=>m.apply()),f);o!==c&&r(c)&&(r$1=e.update({point:c,scenePoint:u,context:s})),i(r$1,d)||(this._applySnappedUpdate(p.mapEnd,r$1,l,n),this.next.execute(p));}}))}_createFrameTask(e){return "3d"===e.type?e.resourceController.scheduler.registerTask(I.SNAPPING):y}_createSnappingInfo(e$1,n,a){return {context:new e({editGeometryOperations:e$1.editGeometryOperations,elevationInfo:e$1.elevationInfo,pointer:e$1.pointer,vertexHandle:r(n.info)?n.info.handle:null,excludeFeature:e$1.excludeFeature,visualizer:e$1.visualizer}),originalPos:r(n.snapOrigin)?e$1.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:r(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:a}}_updatePosition(e,[t,n,a]){const o=k(e);return o.x+=t,o.y+=n,o.hasZ&&(o.z+=a),o}_updateScenePosition(t$1,n){return t(t$1)||t(n)?null:this._updatePosition(t$1,this._computeMapDelta(n.sceneEnd,n.sceneStart))}_computeMapDelta(e,t){const n=e.hasZ&&t.hasZ?e.z-t.z:0;return [e.x-t.x,e.y-t.y,n]}_applySnappedUpdate(e,t,[n,a,o],i){e.x=t.x+n,e.y=t.y+a,i&&e.hasZ&&t.hasZ&&(e.z=t.z+o);}_extractSelfSnappingZ(n,a){if(!n.hasZ())return null;const o=a.vertices;let i=null;for(const r$1 of o){const a=n.getZ(r$1.pos);if(r(i)&&Math.abs(a-i)>1e-6)return null;t(i)&&(i=a);}return i}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
let h=class extends m{constructor(t){super(t),this.constrainResult=t=>t,this._snapPoints=null,this._abortController=null,this._stagedPoint=null,this._snap=x((async(t,s,r$1,e)=>{const i=await this._frameTask.schedule((()=>s.snap({...t,context:r$1,signal:e})),e);i.valid&&await this._frameTask.schedule((()=>{this.stagedPoint=i.apply(),t!==this._snapPoints&&r(this._snapPoints)&&(this.stagedPoint=s.update({...this._snapPoints,context:r$1}));}),e);}));}get stagedPoint(){return this._stagedPoint}set stagedPoint(t){this._stagedPoint=this.constrainResult(t);}initialize(){const t="3d"===this.view.type?this.view?.resourceController?.scheduler:null;this._frameTask=r(t)?t.registerTask(I.SNAPPING):y;}destroy(){this._abortController=p(this._abortController),this._frameTask=h$1(this._frameTask);}async snap(t$1,s,o){const{point:r,scenePoint:e}=t$1;return this.stagedPoint=s.update({point:r,scenePoint:e,context:o}),this._snapPoints=t$1,t(this._abortController)&&(this._abortController=new AbortController),this._snap(t$1,s,o,this._abortController.signal)}abort(){this._abortController=p(this._abortController);}};e$1([y$1({constructOnly:!0})],h.prototype,"view",void 0),e$1([y$1()],h.prototype,"stagedPoint",null),e$1([y$1()],h.prototype,"constrainResult",void 0),e$1([y$1()],h.prototype,"_stagedPoint",void 0),h=e$1([n("esri.views.interactive.snapping.SnappingOperation")],h);

export { h, u };
