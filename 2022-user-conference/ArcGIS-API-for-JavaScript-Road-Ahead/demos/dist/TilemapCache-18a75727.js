import { ji as S, j_ as m, s, bo as y, L, ao as a, eR as o$1, bW as e, l as l$1, C as s$1, o as v, Y as j$1, j$ as y$1, q as p, I, g9 as n$2, a as e$1, d, cw as s$2, n as n$3, ap as f, dn as w, W as a$1, k0 as t } from './_virtual_index-64b818a8.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const r={type:S,json:{origins:{service:{read:{source:["tileInfo","minScale","maxScale","minLOD","maxLOD"],reader:n$1}}}}};function n$1(r,n,l,o){if(!r)return null;const{minScale:i,maxScale:t,minLOD:m,maxLOD:s}=n;if(null!=m&&null!=s)return o&&o.ignoreMinMaxLOD?S.fromJSON(r):S.fromJSON({...r,lods:r.lods.filter((({level:e})=>null!=e&&e>=m&&e<=s))});if(0!==i&&0!==t){const n=e=>Math.round(1e4*e)/1e4,l=i?n(i):1/0,o=t?n(t):-1/0;return S.fromJSON({...r,lods:r.lods.filter((e=>{const r=n(e.scale);return r<=l&&r>=o}))})}return S.fromJSON(r)}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
class l{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40;}getAvailability(t,i){if("unknown"!==this._allAvailability)return this._allAvailability;const e=(t-this.location.top)*this.location.width+(i-this.location.left),a=e%8,l=e>>3,o=this._tileAvailabilityBitSet;return l<0||l>o.length?"unknown":o[l]&1<<a?"available":"unavailable"}_updateFromData(t){const i=this.location.width,e=this.location.height;let a=!0,l=!0;const o=Math.ceil(i*e/8),n=new Uint8Array(o);let r=0;for(let s=0;s<t.length;s++){const i=s%8;t[s]?(l=!1,n[r]|=1<<i):a=!1,7===i&&++r;}l?this._allAvailability="unavailable":a?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=n,this.byteSize+=n.length);}static fromDefinition(a,o){const r=a.service.request||L,{row:s$1,col:h,width:c,height:m$1}=a,d={query:{f:"json"}};return o=o?{...d,...o}:d,r(n(a),o).then((t=>t.data)).catch((t=>{if(t&&t.details&&422===t.details.httpStatus)return {location:{top:s$1,left:h,width:c,height:m$1},valid:!0,data:m(c*m$1,0)};throw t})).then((t=>{if(t.location&&(t.location.top!==s$1||t.location.left!==h||t.location.width!==c||t.location.height!==m$1))throw new s("tilemap:location-mismatch","Tilemap response for different location than requested",{response:t,definition:{top:s$1,left:h,width:c,height:m$1}});return l.fromJSON(t)}))}static fromJSON(t){l._validateJSON(t);const i=new l;return i.location=Object.freeze(y(t.location)),i._updateFromData(t.data),Object.freeze(i)}static _validateJSON(t){if(!t||!t.location)throw new s("tilemap:missing-location","Location missing from tilemap response");if(!1===t.valid)throw new s("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new s("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new s("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new s("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function o(t){return `${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}function n(t){let i;if("vector-tile"===t.service.type)i=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;else {const e=t.service.tileServers;i=`${e&&e.length?e[t.row%e.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;}const e=t.service.query;return e&&(i=`${i}?${e}`),i}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
var j;let z=j=class extends(a(f)){constructor(e){super(e),this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2*o$1.MEGABYTES,this.request=L,this._prefetchingEnabled=!0;}initialize(){this._tilemapCache=new e(this.cacheByteSize),this.addHandles([l$1((()=>{const{layer:e}=this;return [e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]}),(()=>this._initializeTilemapDefinition())),l$1((()=>this.layer?.tileInfo?.lods),(e=>this._initializeAvailableLevels(e)),w)]),this._initializeTilemapDefinition();}castLevels(e){return e<=2?(s$1.getLogger(this.declaredClass).error("Minimum levels for Tilemap is 3, but got ",e),3):e}get size(){return 1<<this.levels}fetchTilemap(e,t,i,r){if(!this._availableLevels[e])return Promise.reject(new s("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const l$1=this._tmpTilemapDefinition,a=this._tilemapFromCache(e,t,i,l$1);if(a)return Promise.resolve(a);const o$1=r&&r.signal;return r={...r,signal:null},new Promise(((e,t)=>{v(o$1,(()=>t(a$1())));const i=o(l$1);let s=this._pendingTilemapRequests[i];if(!s){s=l.fromDefinition(l$1,r).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=s,s.then(e,e);}s.then(e,t);}))}getAvailability(e,t,i){if(!this._availableLevels[e])return "unavailable";const r=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return r?r.getAvailability(t,i):"unknown"}fetchAvailability(e,t,i,r){return this._availableLevels[e]?this.fetchTilemap(e,t,i,r).catch((e=>e)).then((r=>{if(r instanceof l){const l=r.getAvailability(t,i);if("unavailable"===l)throw new s("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i});return l}if(j$1(r))throw r;return "unknown"})):Promise.reject(new s("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`))}fetchAvailabilityUpsample(e,t,i,r,s){r.level=e,r.row=t,r.col=i;const l=this.layer.tileInfo;l.updateTileInfo(r);const a=this.fetchAvailability(e,t,i,s).catch((e=>{if(j$1(e))throw e;if(l.upsampleTile(r))return this.fetchAvailabilityUpsample(r.level,r.row,r.col,r);throw e}));return this._fetchAvailabilityUpsamplePrefetch(r.id,e,t,i,s,a),a}async _fetchAvailabilityUpsamplePrefetch(e,t$1,i,r,s,l){if(!this._prefetchingEnabled)return;const a=`prefetch-${e}`;if(this.handles.has(a))return;const o=new AbortController;l.then((()=>o.abort()),(()=>o.abort()));let n=!1;const c={remove(){n||(n=!0,o.abort());}};if(this.handles.add(c,a),await y$1(10,o.signal).catch((()=>{})),n||(n=!0,this.handles.remove(a)),p(o))return;const h=new t(e,t$1,i,r),m={...s,signal:o.signal},f=this.layer.tileInfo;for(let p=0;j._prefetches.length<j._maxPrefetch&&f.upsampleTile(h);++p){const e=this.fetchAvailability(h.level,h.row,h.col,m);j._prefetches.push(e);const t=()=>{j._prefetches.removeUnordered(e);};e.then(t,t);}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:i}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:I({...e.query,...i,token:t??e.query?.token}),tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0};}_tilemapFromCache(e,t,i,r){r.level=e,r.row=t-t%this.size,r.col=i-i%this.size;const s=o(r);return this._tilemapCache.get(s)}_initializeAvailableLevels(e){this._availableLevels={},e&&e.forEach((e=>this._availableLevels[e.level]=!0));}get test(){const e=this;return {get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(t){e._prefetchingEnabled=t;},hasTilemap:(t,i,r)=>!!e._tilemapFromCache(t,i,r,e._tmpTilemapDefinition)}}};z._maxPrefetch=4,z._prefetches=new n$2({initialSize:j._maxPrefetch}),e$1([d({constructOnly:!0,type:Number})],z.prototype,"levels",void 0),e$1([s$2("levels")],z.prototype,"castLevels",null),e$1([d({readOnly:!0,type:Number})],z.prototype,"size",null),e$1([d({constructOnly:!0,type:Number})],z.prototype,"cacheByteSize",void 0),e$1([d({constructOnly:!0})],z.prototype,"layer",void 0),e$1([d({constructOnly:!0})],z.prototype,"request",void 0),z=j=e$1([n$3("esri.layers.support.TilemapCache")],z);

export { n$1 as n, r, z };
