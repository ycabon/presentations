import { hn as d, ho as d$1, j3 as l, hh as t, hp as s, r, hm as q$1, t as t$1, aH as n, gA as a, eN as f, bk as i, is as Pn, ea as _, fe as _$1, f2 as r$1, f9 as p, e8 as e, g$ as s$1, j4 as e$1, e7 as P$2, bj as g, fd as u, j5 as x, j6 as t$2, cA as c, j7 as j, j8 as i$1 } from './_virtual_index-9b831d4a.js';
import { P as P$1 } from './dragEventPipeline-b56dbe77.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
function C(e,r){return D(e,(()=>r))}function T(e){return D(e,(e=>e.plane))}function D(t$2,s$1){const c=n(),l$1=n();let i=!1;return a=>{const u=s$1(a);if("start"===a.action){const r$1=d$1(a.screenStart,l(t.get())),s$1=s(t$2.state.camera,r$1,L);r(s$1)&&(i=q$1(u,s$1,c));}if(!i)return null;const p=d$1(a.screenEnd,l(t.get())),m=s(t$2.state.camera,p,L);return t$1(m)?null:q$1(u,m,l$1)?{...a,renderStart:c,renderEnd:l$1,plane:u,ray:m}:null}}function M(t,n,o,c=null,l=null){let i$1=null;return a=>{if("start"===a.action&&(i$1=t.sceneIntersectionHelper.intersectElevationFromScreen(i(a.screenStart.x,a.screenStart.y),n,o,l),r(i$1)&&r(c)&&!Pn(i$1,i$1,c)))return null;if(t$1(i$1))return null;const u=t.sceneIntersectionHelper.intersectElevationFromScreen(i(a.screenEnd.x,a.screenEnd.y),n,o,l);return r(u)?r(c)&&!Pn(u,u,c)?null:{...a,mapStart:i$1,mapEnd:u}:null}}function N(e,r,t,n=null,o=null){return M(e,t,f(r,e,t),n,o)}function P(e,r,t,n=null,o=null){return N(e,t,a(r),n,o)}function h(r$1,t,n,o){const s=t.toMap(r$1.screenStart,{include:[n]});return r(s)?P(t,n,s,o):null}function k(e$1,r){const t=J,n=K,o=p();e$1.renderCoordsHelper.worldUpAtPosition(r,t);const s=_(o,t,e(n,r,e$1.state.camera.eye));return _(s,s,t),_$1(r,s,o)}function G(e,r,t){let n=null;const o=new P$1;return o.next(C(e,k(e,r))).next(A(e,r)).next(F(e,t)).next((e=>{e.mapEnd.x=e.mapStart.x,e.mapEnd.y=e.mapStart.y,n=e;})),e=>(n=null,o.execute(e),n)}function A(e$2,r){const t=n(),n$1=s$1(r);e$2.renderCoordsHelper.worldUpAtPosition(r,t);const o=n(),s=n(),m=o=>{if(e(o,o,r),e$1(t,o,o),"global"===e$2.viewingMode){s$1(o)*Math.sign(P$2(t,o))<.001-n$1&&e(o,g(o,t,.001),r);}return u(o,o,r),o};return e=>(e.renderStart=m(r$1(o,e.renderStart)),e.renderEnd=m(r$1(s,e.renderEnd)),e)}function F(r$1,t){const n=r$1.renderCoordsHelper;return r$1=>{const o=n.fromRenderCoords(r$1.renderStart,t),s=n.fromRenderCoords(r$1.renderEnd,t);return r(o)&&r(s)?{...r$1,mapStart:o,mapEnd:s}:null}}var q;function z(r$1){let t=null;return n=>{switch(n.action){case"start":t=r$1.disableDisplay();break;case"end":case"cancel":r(t)&&(t.remove(),t=null);}return n}}function B(o,c$1=null){const l=x(o.state.viewingMode);l.options.selectionMode=!0,l.options.store=t$2.MIN,l.options.hud=!1;const i$2=i(),a={requiresGroundFeedback:!0,enableDraped:!0,exclude:new Set},u=n(),p=c(c$1,o.spatialReference),m=e=>{o.map.ground&&o.map.ground.opacity<1?a.exclude.add(j):a.exclude.delete(j),o.sceneIntersectionHelper.intersectIntersectorScreen(d$1(e,i$2),l,a);const r=l.results.min;let t;if(r.getIntersectionPoint(u))t=r.intersector===i$1.TERRAIN?q.GROUND:q.OTHER;else {if(!l.results.ground.getIntersectionPoint(u))return null;t=q.GROUND;}return {location:o.renderCoordsHelper.fromRenderCoords(u,p),surfaceType:t}};let f;return t=>{if("start"===t.action){const r$1=m(t.screenStart);f=r(r$1)?r$1.location:null;}if(t$1(f))return null;const n=m(t.screenEnd);return r(n)&&r(n.location)?{...t,mapStart:f,mapEnd:n.location,surfaceType:n.surfaceType}:null}}!function(e){e[e.GROUND=0]="GROUND",e[e.OTHER=1]="OTHER";}(q||(q={}));const J=n(),K=n(),L=d();

export { B, C, F, G, N, P, T, h, z };
