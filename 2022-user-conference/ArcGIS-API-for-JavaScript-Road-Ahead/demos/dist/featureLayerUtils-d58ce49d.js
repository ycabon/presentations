import { $ as s, I as x$1, a0 as i, a1 as l, E as s$1, a2 as i$1, a3 as f, a4 as s$2, a5 as Ze, a6 as E$1, t, a7 as x$2, a8 as j$1, a9 as m, m as r$1, aa as a, ab as c, ac as o$1 } from './_virtual_index-1ea2035a.js';
import { r } from './fetchService-5c7089ef.js';
import { o } from './jsonContext-4d6c9fc0.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const I=s.getLogger("esri.layers.FeatureLayer"),S="Feature Service";function g(e,t){return `Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${t}`}function j(e,r){if(r.type!==S)throw new s$1("feature-layer:portal-item-wrong-type",g(e,`should have portal item of type "${S}"`))}async function L(e){if(await e.load(),l(e))throw new s$1("feature-layer:save",g(e,"using an in-memory source cannot be saved to a portal item"))}function P(e,r){let a=(e.messages??[]).filter((({type:e})=>"error"===e)).map((({name:e,message:r,details:a})=>new s$1(e,r,a)));if(r?.ignoreUnsupported&&(a=a.filter((({name:e})=>"layer:unsupported"!==e&&"symbol:unsupported"!==e&&"symbol-layer:unsupported"!==e&&"property:unsupported"!==e&&"url:unsupported"!==e))),a.length>0)throw new s$1("feature-layer:save","Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:a})}async function J(e,t,r){"beforeSave"in e&&"function"==typeof e.beforeSave&&await e.beforeSave();const a=e.write({},t);return P(t,r),a}function N(e){const{layer:t,layerJSON:r}=e;return t.isTable?{layers:[],tables:[r]}:{layers:[r],tables:[]}}function O(e){i$1(e,f.JSAPI),e.typeKeywords&&(e.typeKeywords=e.typeKeywords.filter(((e,t,r)=>r.indexOf(e)===t)));}function E(e){const r=e.portalItem;if(!r)throw I.error("save: requires the portalItem property to be set"),new s$1("feature-layer:portal-item-not-set",g(e,"requires the portalItem property to be set"));if(!r.loaded)throw new s$1("feature-layer:portal-item-not-loaded",g(e,"cannot be saved to a portal item that does not exist or is inaccessible"));j(e,r);}async function T(e,t){return /\/\d+\/?$/.test(e.url??"")?N(t[0]):$(e,t)}async function $(e,t){const{layer:{url:r,customParameters:a,apiKey:o}}=t[0];let s=await e.fetchData("json");s&&null!=s.layers&&null!=s.tables||(s=await x(s,{url:r??"",customParameters:a,apiKey:o},t.map((e=>e.layer.layerId))));for(const l of t)K(l.layer,l.layerJSON,s);return s}async function x(e,t,r$1){var a,o;e||(e={}),(a=e).layers||(a.layers=[]),(o=e).tables||(o.tables=[]);const{url:s,customParameters:l,apiKey:i}=t,{serviceJSON:n,layersJSON:u}=await r(s,{customParameters:l,apiKey:i}),c=A(e.layers,n.layers,r$1),y=A(e.tables,n.tables,r$1);e.layers=c.itemResources,e.tables=y.itemResources;const d=[...c.added,...y.added],m=u?[...u.layers,...u.tables]:[];return await U(e,d,s,m),e}function A(t,r,a){const o=s$2(t,r,((e,t)=>e.id===t.id));t=t.filter((e=>!o.removed.some((t=>t.id===e.id))));const s=o.added.map((({id:e})=>({id:e})));return s.forEach((({id:e})=>{t.push({id:e});})),{itemResources:t,added:s.filter((({id:e})=>!a.includes(e)))}}async function U(e,t$1,r,o){const s=t$1.map((({id:e})=>new Ze({url:r,layerId:e,sourceJSON:o.find((({id:t})=>t===e))})));await E$1(s.map((e=>e.load()))),s.forEach((t$1=>{const{layerId:r,loaded:o,defaultPopupTemplate:s}=t$1;if(!o||t(s))return;K(t$1,{id:r,popupInfo:s.toJSON()},e);}));}function K(e,t,r){e.isTable?F(r.tables,t):F(r.layers,t);}function F(e,t){if(!e)return;const r=e.findIndex((({id:e})=>e===t.id));-1===r?e.push(t):e[r]=t;}function R(e){const{portalItem:t}=e;return o$1(e)&&!e.dynamicDataSource&&!!t?.loaded&&t.type===S}async function D(e){if(!e?.length)throw new s$1("feature-layer-utils-saveall:missing-parameters","'layers' array should contain at least one feature layer");await Promise.all(e.map((e=>e.load())));for(const o of e)if(!R(o))throw new s$1("feature-layer-utils-saveall:invalid-parameters",`'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${g(o,"does not conform")}`,{layer:o});const r=e.map((e=>e.portalItem.id));if(new Set(r).size>1)throw new s$1("feature-layer-utils-saveall:invalid-parameters","All layers in the 'layers' array should be loaded from the same portal item");const a=e.map((e=>e.layerId));if(new Set(a).size!==a.length)throw new s$1("feature-layer-utils-saveall:invalid-parameters","'layers' array should contain only one instance each of layer or table in a feature service")}function _(e,t){var r,a;let o=x$2.from(t);return o.id&&(o=o.clone(),o.id=null),(r=o).type??(r.type=S),(a=o).portal??(a.portal=j$1.getDefault()),j(e,o),o}async function q(e,t){const{url:r,layerId:a$1,title:s,fullExtent:l,isTable:i}=e,n=m(r),p=r$1(n)&&"FeatureServer"===n.serverType;t.url=p?r:`${r}/${a$1}`,t.title||(t.title=s),t.extent=null,!i&&r$1(l)&&(t.extent=await a(l)),c(t,f.METADATA),c(t,f.MULTI_LAYER),i$1(t,f.SINGLE_LAYER),i&&i$1(t,f.TABLE),O(t);}async function z(e,t,r){const a=e.portal;await(a?._signIn()),await(a?.user?.addItem({item:e,data:t,folder:r?.folder}));}const C=x$1(M);async function M(e,t){await L(e),E(e);const r=e.portalItem,a=o(r),o$1=await J(e,a,t),s=await T(r,[{layer:e,layerJSON:o$1}]);return O(r),await r.update({data:s}),i(a),r}const Y=x$1((async(e,t)=>{await D(e);const r=e[0].portalItem,a=o(r),o$1=await Promise.all(e.map((e=>J(e,a,t)))),s=await T(r,e.map(((e,t)=>({layer:e,layerJSON:o$1[t]}))));return O(r),await r.update({data:s}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),i(a),r.clone()})),B=x$1(G);async function G(e,t,r){await L(e);const a=_(e,t),o$1=o(a),s=N({layer:e,layerJSON:await J(e,o$1,r)});return await q(e,a),await z(a,s,r),e.portalItem=a,i(o$1),a}

export { C as save, Y as saveAll, B as saveAs };
