import { V as V$1, y as v, K as K$1, ai as t, J as J$1, P, t as t$1, e, L as le, Y as Y$1, c as J$2, w, E, aj as t$2, F, r as re, h as g, ak as xe, al as R, a1 as n, am as l } from './arcadeUtils-cbca72a3.js';
import { D, q as q$1, e as e$1, v as v$1, G, d, c, a as e$2, b as a, f as a$1, F as F$1, k, N, C as C$1, x, E as E$1, W, A, g as F$2 } from './featureSetUtils-2ed33d22.js';
import { u, w as w$1 } from './SpatialFilter-b159d7ba.js';
import { sR as C, qO as f, a5 as Ze, nq as y } from './_virtual_index-1ea2035a.js';
import './number-2aae57c3.js';
import './hash-da85b7aa.js';
import './executeForIds-79135d28.js';
import './geometryEngineAsync-8eb3bd06.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
function J(e,t,n,i){if(1===i.length){if(Y$1(i[0]))return l(e,i[0],-1);if(E(i[0]))return l(e,i[0].toArray(),-1)}return l(e,i,-1)}async function V(e,t,n){const i=e.getVariables();if(i.length>0){const a=[];for(let e=0;e<i.length;e++){const r={name:i[e]};a.push(await t.evaluateIdentifier(n,r));}const r={};for(let e=0;e<i.length;e++)r[i[e]]=a[e];return e.parameters=r,e}return e}function q(e,t,n=null){for(const i in e)if(i.toLowerCase()===t.toLowerCase())return e[i];return n}function K(e){if(null===e)return null;const t={type:q(e,"type",""),name:q(e,"name","")};if("range"===t.type)t.range=q(e,"range",[]);else {t.codedValues=[];for(const n of q(e,"codedValues",[]))t.codedValues.push({name:q(n,"name",""),code:q(n,"code",null)});}return t}function X(e){if(null===e)return null;const t={},n=q(e,"wkt",null);null!==n&&(t.wkt=n);const i=q(e,"wkid",null);return null!==i&&(t.wkid=i),t}function Y(e){if(null===e)return null;const t={hasZ:q(e,"hasz",!1),hasM:q(e,"hasm",!1)},n=q(e,"spatialreference",null);n&&(t.spatialReference=X(n));const i=q(e,"x",null);if(null!==i)return t.x=i,t.y=q(e,"y",null),t;const a=q(e,"rings",null);if(null!==a)return t.rings=a,t;const r=q(e,"paths",null);if(null!==r)return t.paths=r,t;const s=q(e,"points",null);if(null!==s)return t.points=s,t;for(const o of ["xmin","xmax","ymin","ymax","zmin","zmax","mmin","mmax"]){const n=q(e,o,null);null!==n&&(t[o]=n);}return t}function Z(e,t){for(const n of t)if(n===e)return !0;return !1}function Q(e){return !!e.layerDefinition&&(!!e.featureSet&&(!1!==Z(e.layerDefinition.geometryType,["","esriGeometryPoint","esriGeometryPolyline","esriGeometryPolygon","esriGeometryMultipoint","esriGeometryEnvelope"])&&(null!==e.layerDefinition.objectIdField&&""!==e.layerDefinition.objectIdField&&(!1!==Y$1(e.layerDefinition.fields)&&!1!==Y$1(e.featureSet.features)))))}function ee(G$1){"async"===G$1.mode&&(G$1.functions.getuser=function(a,r){return G$1.standardFunctionAsync(a,r,(async(l,f,c)=>{V$1(c,0,2,a,r);let u=v(c[1],""),d=!0===u;if(u=!0===u||!1===u?"":K$1(u),0===c.length||c[0]instanceof t){let e=null;a.services&&a.services.portal&&(e=a.services.portal),c.length>0&&(e=D(c[0],e));const n=await q$1(e,u,d);if(n){const e=JSON.parse(JSON.stringify(n));for(const t of ["lastLogin","created","modified"])void 0!==e[t]&&null!==e[t]&&(e[t]=new Date(e[t]));return J$1.convertObjectToArcadeDictionary(e)}return null}let m=null;if(P(c[0])&&(m=c[0]),m){if(d=!1,u)return null;await m.load();const n=await m.getOwningSystemUrl();if(!n){if(!u){const e=await m.getIdentityUser();return e?J$1.convertObjectToArcadeDictionary({username:e}):null}return null}let i=null;a.services&&a.services.portal&&(i=a.services.portal),i=D(new t(n),i);const r=await q$1(i,u,d);if(r){const e=JSON.parse(JSON.stringify(r));for(const t of ["lastLogin","created","modified"])void 0!==e[t]&&null!==e[t]&&(e[t]=new Date(e[t]));return J$1.convertObjectToArcadeDictionary(e)}return null}throw new t$1(a,e.InvalidParameter,r)}))},G$1.signatures.push({name:"getuser",min:1,max:2}),G$1.functions.featuresetbyid=function(e$2,t){return G$1.standardFunctionAsync(e$2,t,((a,s,o)=>{if(V$1(o,2,4,e$2,t),o[0]instanceof e$1){const a=K$1(o[1]);let r=v(o[2],null);const s=le(v(o[3],!0));if(null===r&&(r=["*"]),!1===Y$1(r))throw new t$1(e$2,e.InvalidParameter,t);return o[0].featureSetById(a,s,r)}throw new t$1(e$2,e.InvalidParameter,t)}))},G$1.signatures.push({name:"featuresetbyid",min:2,max:4}),G$1.functions.getfeatureset=function(e$1,t){return G$1.standardFunctionAsync(e$1,t,((a,r,s)=>{if(V$1(s,1,2,e$1,t),J$2(s[0])){let t=v(s[1],"datasource");return null===t&&(t="datasource"),t=K$1(t).toLowerCase(),v$1(s[0].fullSchema(),t,e$1.lrucache,e$1.interceptor,e$1.spatialReference)}throw new t$1(e$1,e.InvalidParameter,t)}))},G$1.signatures.push({name:"getfeatureset",min:1,max:2}),G$1.functions.featuresetbyportalitem=function(t$2,a){return G$1.standardFunctionAsync(t$2,a,((r,o,l)=>{if(V$1(l,2,5,t$2,a),null===l[0])throw new t$1(t$2,e.PortalRequired,a);if(l[0]instanceof t){const e$1=K$1(l[1]),r=K$1(l[2]);let o=v(l[3],null);const c=le(v(l[4],!0));if(null===o&&(o=["*"]),!1===Y$1(o))throw new t$1(t$2,e.InvalidParameter,a);let u=null;return t$2.services&&t$2.services.portal&&(u=t$2.services.portal),u=D(l[0],u),G(e$1,r,t$2.spatialReference,o,c,u,t$2.lrucache,t$2.interceptor)}if(!1===w(l[0]))throw new t$1(t$2,e.PortalRequired,a);const c=K$1(l[0]),u=K$1(l[1]);let d=v(l[2],null);const m=le(v(l[3],!0));if(null===d&&(d=["*"]),!1===Y$1(d))throw new t$1(t$2,e.InvalidParameter,a);if(t$2.services&&t$2.services.portal)return G(c,u,t$2.spatialReference,d,m,t$2.services.portal,t$2.lrucache,t$2.interceptor);throw new t$1(t$2,e.PortalRequired,a)}))},G$1.signatures.push({name:"featuresetbyportalitem",min:2,max:5}),G$1.functions.featuresetbyname=function(e$2,t){return G$1.standardFunctionAsync(e$2,t,((a,s,o)=>{if(V$1(o,2,4,e$2,t),o[0]instanceof e$1){const a=K$1(o[1]);let r=v(o[2],null);const s=le(v(o[3],!0));if(null===r&&(r=["*"]),!1===Y$1(r))throw new t$1(e$2,e.InvalidParameter,t);return o[0].featureSetByName(a,s,r)}throw new t$1(e$2,e.InvalidParameter,t)}))},G$1.signatures.push({name:"featuresetbyname",min:2,max:4}),G$1.functions.featureset=function(e$1,a){return G$1.standardFunction(e$1,a,((r,s,o)=>{V$1(o,1,1,e$1,a);let l=o[0];const f={layerDefinition:{geometryType:"",objectIdField:"",globalIdField:"",typeIdField:"",fields:[]},featureSet:{geometryType:"",features:[]}};if(w(l))l=JSON.parse(l),void 0!==l.layerDefinition?(f.layerDefinition=l.layerDefinition,f.featureSet=l.featureSet,l.layerDefinition.spatialReference&&(f.layerDefinition.spatialReference=l.layerDefinition.spatialReference)):(f.featureSet.features=l.features,f.featureSet.geometryType=l.geometryType,f.layerDefinition.geometryType=f.featureSet.geometryType,f.layerDefinition.objectIdField=l.objectIdFieldName,f.layerDefinition.typeIdField=l.typeIdFieldName,f.layerDefinition.globalIdField=l.globalIdFieldName,f.layerDefinition.fields=l.fields,l.spatialReference&&(f.layerDefinition.spatialReference=l.spatialReference));else {if(!(o[0]instanceof J$1))throw new t$1(e$1,e.InvalidParameter,a);{l=JSON.parse(o[0].castToText(!0));const e=q(l,"layerdefinition");if(null!==e){f.layerDefinition.geometryType=q(e,"geometrytype",""),f.featureSet.geometryType=f.layerDefinition.geometryType,f.layerDefinition.globalIdField=q(e,"globalidfield",""),f.layerDefinition.objectIdField=q(e,"objectidfield",""),f.layerDefinition.typeIdField=q(e,"typeidfield","");const t=q(e,"spatialreference",null);t&&(f.layerDefinition.spatialReference=X(t));for(const i of q(e,"fields",[])){const e={name:q(i,"name",""),alias:q(i,"alias",""),type:q(i,"type",""),nullable:q(i,"nullable",!0),editable:q(i,"editable",!0),length:q(i,"length",null),domain:K(q(i,"domain"))};f.layerDefinition.fields.push(e);}const n=q(l,"featureset",null);if(n){const e={};for(const t of f.layerDefinition.fields)e[t.name.toLowerCase()]=t.name;for(const t of q(n,"features",[])){const n={},i=q(t,"attributes",{});for(const t in i)n[e[t.toLowerCase()]]=i[t];f.featureSet.features.push({attributes:n,geometry:Y(q(t,"geometry",null))});}}}else {f.layerDefinition.geometryType=q(l,"geometrytype",""),f.featureSet.geometryType=f.layerDefinition.geometryType,f.layerDefinition.objectIdField=q(l,"objectidfieldname",""),f.layerDefinition.typeIdField=q(l,"typeidfieldname","");const e=q(l,"spatialreference",null);e&&(f.layerDefinition.spatialReference=X(e));for(const n of q(l,"fields",[])){const e={name:q(n,"name",""),alias:q(n,"alias",""),type:q(n,"type",""),nullable:q(n,"nullable",!0),editable:q(n,"editable",!0),length:q(n,"length",null),domain:K(q(n,"domain"))};f.layerDefinition.fields.push(e);}const t={};for(const n of f.layerDefinition.fields)t[n.name.toLowerCase()]=n.name;for(const n of q(l,"features",[])){const e={},i=q(n,"attributes",{});for(const n in i)e[t[n.toLowerCase()]]=i[n];f.featureSet.features.push({attributes:e,geometry:Y(q(n,"geometry",null))});}}}}if(!1===Q(f))throw new t$1(e$1,e.InvalidParameter,a);return d.create(f,e$1.spatialReference)}))},G$1.signatures.push({name:"featureset",min:1,max:1}),G$1.functions.filter=function(e$1,t){return G$1.standardFunctionAsync(e$1,t,(async(a,r,s)=>{if(V$1(s,2,2,e$1,t),Y$1(s[0])||E(s[0])){const a=[];let r=s[0];r instanceof t$2&&(r=r.toArray());let o=null;if(!F(s[1]))throw new t$1(e$1,e.InvalidParameter,t);o=s[1].createFunction(e$1);for(const e of r){const t=o(e);C(t)?!0===await t&&a.push(e):!0===t&&a.push(e);}return a}if(P(s[0])){const t=await s[0].load(),n=f.create(s[1],t.getFieldsIndex()),i=n.getVariables();if(i.length>0){const t=[];for(let n=0;n<i.length;n++){const a={name:i[n]};t.push(await G$1.evaluateIdentifier(e$1,a));}const a={};for(let e=0;e<i.length;e++)a[i[e]]=t[e];return n.parameters=a,new c({parentfeatureset:s[0],whereclause:n})}return new c({parentfeatureset:s[0],whereclause:n})}throw new t$1(e$1,e.InvalidParameter,t)}))},G$1.signatures.push({name:"filter",min:2,max:2}),G$1.functions.orderby=function(e$1,t){return G$1.standardFunctionAsync(e$1,t,(async(a$1,r,s)=>{if(V$1(s,2,2,e$1,t),P(s[0])){const e=new e$2(s[1]);return new a({parentfeatureset:s[0],orderbyclause:e})}throw new t$1(e$1,e.InvalidParameter,t)}))},G$1.signatures.push({name:"orderby",min:2,max:2}),G$1.functions.top=function(e$1,t){return G$1.standardFunctionAsync(e$1,t,(async(a,r,s)=>{if(V$1(s,2,2,e$1,t),P(s[0]))return new a$1({parentfeatureset:s[0],topnum:s[1]});if(Y$1(s[0]))return re(s[1])>=s[0].length?s[0].slice(0):s[0].slice(0,re(s[1]));if(E(s[0]))return re(s[1])>=s[0].length()?s[0].slice(0):s[0].slice(0,re(s[1]));throw new t$1(e$1,e.InvalidParameter,t)}))},G$1.signatures.push({name:"top",min:2,max:2}),G$1.functions.first=function(e,t){return G$1.standardFunctionAsync(e,t,(async(n,i,r)=>{if(V$1(r,1,1,e,t),P(r[0])){const e=await r[0].first(n.abortSignal);if(null!==e){const t=g.createFromGraphicLikeObject(e.geometry,e.attributes,r[0]);return t._underlyingGraphic=e,t}return e}return Y$1(r[0])?0===r[0].length?null:r[0][0]:E(r[0])?0===r[0].length()?null:r[0].get(0):null}))},G$1.signatures.push({name:"first",min:1,max:1}),G$1.functions.attachments=function(e$1,a){return G$1.standardFunctionAsync(e$1,a,(async(r,s,o)=>{V$1(o,1,2,e$1,a);const l={minsize:-1,maxsize:-1,types:null,returnMetadata:!1};if(o.length>1)if(o[1]instanceof J$1){if(o[1].hasField("minsize")&&(l.minsize=re(o[1].field("minsize"))),o[1].hasField("metadata")&&(l.returnMetadata=le(o[1].field("metadata"))),o[1].hasField("maxsize")&&(l.maxsize=re(o[1].field("maxsize"))),o[1].hasField("types")){const e=xe(o[1].field("types"),!1);e.length>0&&(l.types=e);}}else if(null!==o[1])throw new t$1(e$1,e.InvalidParameter,a);if(J$2(o[0])){let t=o[0]._layer;return t instanceof Ze&&(t=F$1(t,e$1.spatialReference,["*"],!0,e$1.lrucache,e$1.interceptor)),null===t?[]:!1===P(t)?[]:(await t.load(),t.queryAttachments(o[0].field(t.objectIdField),l.minsize,l.maxsize,l.types,l.returnMetadata))}if(null===o[0])return [];throw new t$1(e$1,e.InvalidParameter,a)}))},G$1.signatures.push({name:"attachments",min:1,max:2}),G$1.functions.featuresetbyrelationshipname=function(e$1,t){return G$1.standardFunctionAsync(e$1,t,(async(a,r,s)=>{V$1(s,2,4,e$1,t);const o=s[0],l=K$1(s[1]);let f$1=v(s[2],null);const m=le(v(s[3],!0));if(null===f$1&&(f$1=["*"]),!1===Y$1(f$1))throw new t$1(e$1,e.InvalidParameter,t);if(null===s[0])return null;if(!J$2(s[0]))throw new t$1(e$1,e.InvalidParameter,t);let p=o._layer;if(p instanceof Ze&&(p=F$1(p,e$1.spatialReference,["*"],!0,e$1.lrucache,e$1.interceptor)),null===p)return null;if(!1===P(p))return null;p=await p.load();const D=p.relationshipMetaData().filter((e=>e.name===l));if(0===D.length)return null;if(void 0!==D[0].relationshipTableId&&null!==D[0].relationshipTableId&&D[0].relationshipTableId>-1)return k(p,D[0],o.field(p.objectIdField),p.spatialReference,f$1,m,e$1.lrucache,e$1.interceptor);let b=p.serviceUrl();if(!b)return null;b="/"===b.charAt(b.length-1)?b+D[0].relatedTableId.toString():b+"/"+D[0].relatedTableId.toString();const A=await N(b,p.spatialReference,f$1,m,e$1.lrucache,e$1.interceptor);await A.load();let N$1=A.relationshipMetaData();if(N$1=N$1.filter((e=>e.id===D[0].id)),!1===o.hasField(D[0].keyField)||null===o.field(D[0].keyField)){const e=await p.getFeatureByObjectId(o.field(p.objectIdField),[D[0].keyField]);if(e){const t=f.create(N$1[0].keyField+"= @id",A.getFieldsIndex());return t.parameters={id:e.attributes[D[0].keyField]},A.filter(t)}return new u({parentfeatureset:A})}const x=f.create(N$1[0].keyField+"= @id",A.getFieldsIndex());return x.parameters={id:o.field(D[0].keyField)},A.filter(x)}))},G$1.signatures.push({name:"featuresetbyrelationshipname",min:2,max:4}),G$1.functions.featuresetbyassociation=function(e$1,t){return G$1.standardFunctionAsync(e$1,t,(async(a,r,s)=>{V$1(s,2,3,e$1,t);const o=s[0],l=K$1(v(s[1],"")).toLowerCase(),f$1=w(s[2])?K$1(s[2]):null;if(null===s[0])return null;if(!J$2(s[0]))throw new t$1(e$1,e.InvalidParameter,t);let u=o._layer;if(u instanceof Ze&&(u=F$1(u,e$1.spatialReference,["*"],!0,e$1.lrucache,e$1.interceptor)),null===u)return null;if(!1===P(u))return null;await u.load();const d=u.serviceUrl(),p=await C$1(d,e$1.spatialReference);let I=null,F=null,b=!1;if(null!==f$1&&""!==f$1&&void 0!==f$1){for(const e of p.terminals)e.terminalName===f$1&&(F=e.terminalId);null===F&&(b=!0);}const A$1=p.associations.getFieldsIndex(),N=A$1.get("TOGLOBALID").name,x$1=A$1.get("FROMGLOBALID").name,P$1=A$1.get("TOTERMINALID").name,R$1=A$1.get("FROMTERMINALID").name,O=A$1.get("FROMNETWORKSOURCEID").name,C=A$1.get("TONETWORKSOURCEID").name,M=A$1.get("ASSOCIATIONTYPE").name,k=A$1.get("ISCONTENTVISIBLE").name,z=A$1.get("OBJECTID").name;for(const e of u.fields)if("global-id"===e.type){I=o.field(e.name);break}let G=null,U=new x(new y({name:"percentalong",alias:"percentalong",type:"double"}),f.create("0",p.associations.getFieldsIndex())),J=new x(new y({name:"side",alias:"side",type:"string"}),f.create("''",p.associations.getFieldsIndex()));const V="globalid",q="globalId",K={};for(const e in p.lkp)K[e]=p.lkp[e].sourceId;const X=new E$1(new y({name:"classname",alias:"classname",type:"string"}),null,K);let Y="";switch(l){case"midspan":{Y=`((${N}='${I}') OR ( ${x$1}='${I}')) AND (${M} IN (5))`,X.codefield=f.create(`CASE WHEN (${N}='${I}') THEN ${O} ELSE ${C} END`,p.associations.getFieldsIndex());const e=n(A.findField(p.associations.fields,x$1));e.name=V,e.alias=V,G=new x(e,f.create(`CASE WHEN (${x$1}='${I}') THEN ${N} ELSE ${x$1} END`,p.associations.getFieldsIndex())),U=p.unVersion>=4?new F$2(A.findField(p.associations.fields,A$1.get("PERCENTALONG").name)):new x(new y({name:"percentalong",alias:"percentalong",type:"double"}),f.create("0",p.associations.getFieldsIndex()));break}case"junctionedge":{Y=`((${N}='${I}') OR ( ${x$1}='${I}')) AND (${M} IN (4,6))`,X.codefield=f.create(`CASE WHEN (${N}='${I}') THEN ${O} ELSE ${C} END`,p.associations.getFieldsIndex());const e=n(A.findField(p.associations.fields,x$1));e.name=V,e.alias=V,G=new x(e,f.create(`CASE WHEN (${x$1}='${I}') THEN ${N} ELSE ${x$1} END`,p.associations.getFieldsIndex())),J=new x(new y({name:"side",alias:"side",type:"string"}),f.create(`CASE WHEN (${M}=4) THEN 'from' ELSE 'to' END`,p.associations.getFieldsIndex()));break}case"connected":{let e=`${N}='@T'`,t=`${x$1}='@T'`;null!==F&&(e+=` AND ${P$1}=@A`,t+=` AND ${R$1}=@A`),Y="(("+e+") OR ("+t+"))",Y=R(Y,"@T",I??""),e=R(e,"@T",I??""),null!==F&&(e=R(e,"@A",F.toString()),Y=R(Y,"@A",F.toString())),X.codefield=f.create("CASE WHEN "+e+` THEN ${O} ELSE ${C} END`,p.associations.getFieldsIndex());const n$1=n(A.findField(p.associations.fields,x$1));n$1.name=V,n$1.alias=V,G=new x(n$1,f.create("CASE WHEN "+e+` THEN ${x$1} ELSE ${N} END`,p.associations.getFieldsIndex()));break}case"container":Y=`${N}='${I}' AND ${M} = 2`,null!==F&&(Y+=` AND ${P$1} = `+F.toString()),X.codefield=O,Y="( "+Y+" )",G=new W(A.findField(p.associations.fields,x$1),V,V);case"content":Y=`(${x$1}='${I}' AND ${M} = 2)`,null!==F&&(Y+=` AND ${R$1} = `+F.toString()),X.codefield=C,Y="( "+Y+" )",G=new W(A.findField(p.associations.fields,N),V,V);break;case"structure":Y=`(${N}='${I}' AND ${M} = 3)`,null!==F&&(Y+=` AND ${P$1} = `+F.toString()),X.codefield=O,Y="( "+Y+" )",G=new W(A.findField(p.associations.fields,x$1),V,q);break;case"attached":Y=`(${x$1}='${I}' AND ${M} = 3)`,null!==F&&(Y+=` AND ${R$1} = `+F.toString()),X.codefield=C,Y="( "+Y+" )",G=new W(A.findField(p.associations.fields,N),V,q);break;default:throw new t$1(e$1,e.InvalidParameter,t)}b&&(Y="1 <> 1");return new A({parentfeatureset:p.associations,adaptedFields:[new F$2(A.findField(p.associations.fields,z)),new F$2(A.findField(p.associations.fields,k)),G,J,X,U],extraFilter:Y?f.create(Y,p.associations.getFieldsIndex()):null})}))},G$1.signatures.push({name:"featuresetbyassociation",min:2,max:6}),G$1.functions.groupby=function(e$1,a){return G$1.standardFunctionAsync(e$1,a,(async(r,s,o)=>{if(V$1(o,3,3,e$1,a),!P(o[0]))throw new t$1(e$1,e.InvalidParameter,a);const l=await o[0].load(),f$1=[],c=[];let u=!1,d=[];if(w(o[1]))d.push(o[1]);else if(o[1]instanceof J$1)d.push(o[1]);else if(Y$1(o[1]))d=o[1];else {if(!E(o[1]))throw new t$1(e$1,e.InvalidParameter,a);d=o[1].toArray();}for(const m of d)if(w(m)){const e=f.create(K$1(m),l.getFieldsIndex()),t=!0===w$1(e)?K$1(m):"%%%%FIELDNAME";f$1.push({name:t,expression:e}),"%%%%FIELDNAME"===t&&(u=!0);}else {if(!(m instanceof J$1))throw new t$1(e$1,e.InvalidParameter,a);{const t=m.hasField("name")?m.field("name"):"%%%%FIELDNAME",r=m.hasField("expression")?m.field("expression"):"";if("%%%%FIELDNAME"===t&&(u=!0),!t)throw new t$1(e$1,e.InvalidParameter,a);f$1.push({name:t,expression:f.create(r||t,l.getFieldsIndex())});}}if(d=[],w(o[2]))d.push(o[2]);else if(Y$1(o[2]))d=o[2];else if(E(o[2]))d=o[2].toArray();else {if(!(o[2]instanceof J$1))throw new t$1(e$1,e.InvalidParameter,a);d.push(o[2]);}for(const m of d){if(!(m instanceof J$1))throw new t$1(e$1,e.InvalidParameter,a);{const t=m.hasField("name")?m.field("name"):"",r=m.hasField("statistic")?m.field("statistic"):"",s=m.hasField("expression")?m.field("expression"):"";if(!t||!r||!s)throw new t$1(e$1,e.InvalidParameter,a);c.push({name:t,statistic:r.toLowerCase(),expression:f.create(s,l.getFieldsIndex())});}}if(u){const e={};for(const n of l.fields)e[n.name.toLowerCase()]=1;for(const n of f$1)"%%%%FIELDNAME"!==n.name&&(e[n.name.toLowerCase()]=1);for(const n of c)"%%%%FIELDNAME"!==n.name&&(e[n.name.toLowerCase()]=1);let t=0;for(const n of f$1)if("%%%%FIELDNAME"===n.name){for(;1===e["field_"+t.toString()];)t++;e["field_"+t.toString()]=1,n.name="FIELD_"+t.toString();}}for(const t of f$1)await V(t.expression,G$1,e$1);for(const t of c)await V(t.expression,G$1,e$1);return o[0].groupby(f$1,c)}))},G$1.signatures.push({name:"groupby",min:3,max:3}),G$1.functions.distinct=function(e$1,a){return G$1.standardFunctionAsync(e$1,a,(async(r,s,o)=>{if(P(o[0])){V$1(o,2,2,e$1,a);const r=await o[0].load(),s=[];let l=[];if(w(o[1]))l.push(o[1]);else if(o[1]instanceof J$1)l.push(o[1]);else if(Y$1(o[1]))l=o[1];else {if(!E(o[1]))throw new t$1(e$1,e.InvalidParameter,a);l=o[1].toArray();}let f$1=!1;for(const o of l)if(w(o)){const e=f.create(K$1(o),r.getFieldsIndex()),t=!0===w$1(e)?K$1(o):"%%%%FIELDNAME";s.push({name:t,expression:e}),"%%%%FIELDNAME"===t&&(f$1=!0);}else {if(!(o instanceof J$1))throw new t$1(e$1,e.InvalidParameter,a);{const t=o.hasField("name")?o.field("name"):"%%%%FIELDNAME",l=o.hasField("expression")?o.field("expression"):"";if("%%%%FIELDNAME"===t&&(f$1=!0),!t)throw new t$1(e$1,e.InvalidParameter,a);s.push({name:t,expression:f.create(l||t,r.getFieldsIndex())});}}if(f$1){const e={};for(const n of r.fields)e[n.name.toLowerCase()]=1;for(const n of s)"%%%%FIELDNAME"!==n.name&&(e[n.name.toLowerCase()]=1);let t=0;for(const n of s)if("%%%%FIELDNAME"===n.name){for(;1===e["field_"+t.toString()];)t++;e["field_"+t.toString()]=1,n.name="FIELD_"+t.toString();}}for(const t of s)await V(t.expression,G$1,e$1);return o[0].groupby(s,[])}return J("distinct",r,s,o)}))});}

export { ee as registerFunctions };
