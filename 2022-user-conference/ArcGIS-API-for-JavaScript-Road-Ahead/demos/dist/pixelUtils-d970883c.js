import { a as e, d as d$1, cw as s$1, n, i as l$1, s as s$2, G as r$1, O as t, bo as y$1, C as s$3, e as e$1 } from './_virtual_index-64b818a8.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
var c$1;let p$1=c$1=class extends l$1{constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.pixels=null,this.statistics=null;}static createEmptyBand(t,e){return new(c$1.getPixelArrayConstructor(t))(e)}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array;}return e}castPixelType(t){if(!t)return "f32";let e=t.toLowerCase();return ["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels&&this.pixels.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new s$2("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics||{minValue:null,maxValue:null});}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t);}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){this.statistics=this.pixels.map((t=>this._calculateBandStatistics(t,this.mask)));const t=this.mask;let e=0;if(r$1(t))for(let s=0;s<t.length;s++)t[s]&&e++;else e=this.width*this.height;this.validPixelCount=e;}clamp(t){if(!t||"f64"===t||"f32"===t)return;let e;switch(t){case"u8":e=[0,255];break;case"u16":e=[0,65535];break;case"u32":e=[0,4294967295];break;case"s8":e=[-128,127];break;case"s16":e=[-32768,32767];break;case"s32":e=[-2147483648,2147483647];break;default:e=[-34e38,34e38];}const[s,i]=e,l=this.pixels,r=this.width*this.height,a=l.length;let o,h,n;const p=[];for(let u=0;u<a;u++){n=c$1.createEmptyBand(t,r),o=l[u];for(let t=0;t<r;t++)h=o[t],n[t]=h>i?i:h<s?s:h;p.push(n);}this.pixels=p,this.pixelType=t;}extractBands(t$1){if(t(t$1)||0===t$1.length||null==this.pixels||0===this.pixels.length)return this;const e=this.pixels.length,s=t$1.some((t=>t>=this.pixels.length)),i=e===t$1.length&&!t$1.some(((t,e)=>t!==e));return s||i?this:new c$1({pixelType:this.pixelType,width:this.width,height:this.height,mask:this.mask,validPixelCount:this.validPixelCount,maskIsAlpha:this.maskIsAlpha,pixels:t$1.map((t=>this.pixels[t])),statistics:this.statistics&&t$1.map((t=>this.statistics[t]))})}clone(){const t=new c$1({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;r$1(this.mask)&&(this.mask instanceof Uint8Array?t.mask=new Uint8Array(this.mask):t.mask=this.mask.slice(0));const s=c$1.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const i=this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=i?this.pixels[e].slice(0,this.pixels[e].length):new s(this.pixels[e]);}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=y$1(this.statistics[e]);return t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:s,pixels:i}=this;if(!t||!i||!i.length)return void s$3.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let a,o,h,n;a=o=h=i[0],i.length>=3?(o=i[1],h=i[2]):2===i.length&&(o=i[1]);const c=new Uint32Array(t),p=this.width*this.height;if(a.length===p)if(r$1(e)&&e.length===p)if(s)for(n=0;n<p;n++)e[n]&&(c[n]=e[n]<<24|h[n]<<16|o[n]<<8|a[n]);else for(n=0;n<p;n++)e[n]&&(c[n]=255<<24|h[n]<<16|o[n]<<8|a[n]);else for(n=0;n<p;n++)c[n]=255<<24|h[n]<<16|o[n]<<8|a[n];else s$3.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");}_fillFromNon8Bit(t){const{pixels:e,mask:s,statistics:i}=this;if(!t||!e||!e.length)return void s$3.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const a=this.pixelType;let o=1,h=0,n=1;if(i&&i.length>0)h=i.map((t=>t.minValue)).reduce(((t,e)=>Math.min(t,e))),n=i.map((t=>t.maxValue-t.minValue)).reduce(((t,e)=>Math.max(t,e))),o=255/n;else {let t=255;"s8"===a?(h=-128,t=127):"u16"===a?t=65535:"s16"===a?(h=-32768,t=32767):"u32"===a?t=4294967295:"s32"===a?(h=-2147483648,t=2147483647):"f32"===a?(h=-34e38,t=34e38):"f64"===a&&(h=-Number.MAX_VALUE,t=Number.MAX_VALUE),o=255/(t-h);}const c=new Uint32Array(t),p=this.width*this.height;let u,g,m,d,f;if(u=g=m=e[0],u.length!==p)return s$3.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(g=e[1],e.length>=3&&(m=e[2]),r$1(s)&&s.length===p)for(d=0;d<p;d++)s[d]&&(c[d]=255<<24|(m[d]-h)*o<<16|(g[d]-h)*o<<8|(u[d]-h)*o);else for(d=0;d<p;d++)c[d]=255<<24|(m[d]-h)*o<<16|(g[d]-h)*o<<8|(u[d]-h)*o;else if(r$1(s)&&s.length===p)for(d=0;d<p;d++)f=(u[d]-h)*o,s[d]&&(c[d]=255<<24|f<<16|f<<8|f);else for(d=0;d<p;d++)f=(u[d]-h)*o,c[d]=255<<24|f<<16|f<<8|f;}_fillFrom32Bit(t){const{pixels:e,mask:s}=this;if(!t||!e||!e.length)return s$3.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,a,o,h;i=a=o=e[0],e.length>=3?(a=e[1],o=e[2]):2===e.length&&(a=e[1]);const n=this.width*this.height;if(i.length!==n)return s$3.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let c=0;if(r$1(s)&&s.length===n)for(h=0;h<n;h++)t[c++]=i[h],t[c++]=a[h],t[c++]=o[h],t[c++]=1&s[h];else for(h=0;h<n;h++)t[c++]=i[h],t[c++]=a[h],t[c++]=o[h],t[c++]=1;}_calculateBandStatistics(t,e){let s=1/0,i=-1/0;const l=t.length;let a,o=0;if(r$1(e))for(a=0;a<l;a++)e[a]&&(o=t[a],s=o<s?o:s,i=o>i?o:i);else for(a=0;a<l;a++)o=t[a],s=o<s?o:s,i=o>i?o:i;return {minValue:s,maxValue:i}}};e([d$1({json:{write:!0}})],p$1.prototype,"width",void 0),e([d$1({json:{write:!0}})],p$1.prototype,"height",void 0),e([d$1({json:{write:!0}})],p$1.prototype,"pixelType",void 0),e([s$1("pixelType")],p$1.prototype,"castPixelType",null),e([d$1({json:{write:!0}})],p$1.prototype,"validPixelCount",void 0),e([d$1({json:{write:!0}})],p$1.prototype,"mask",void 0),e([d$1({json:{write:!0}})],p$1.prototype,"maskIsAlpha",void 0),e([d$1({json:{write:!0}})],p$1.prototype,"pixels",void 0),e([d$1({json:{write:!0}})],p$1.prototype,"statistics",void 0),p$1=c$1=e([n("esri.layers.support.PixelBlock")],p$1);const u$1=p$1;

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
function l(e){return r$1(e)&&"esri.layers.support.PixelBlock"===e.declaredClass&&e.pixels&&e.pixels.length>0}function o(t,e){if(!e?.length||!l(t))return t;const n=t.pixels.length;return e&&e.some((t=>t>=n))||1===n&&1===e.length&&0===e[0]?t:n!==e.length||e.some(((t,e)=>t!==e))?new u$1({pixelType:t.pixelType,width:t.width,height:t.height,mask:t.mask,validPixelCount:t.validPixelCount,maskIsAlpha:t.maskIsAlpha,pixels:e.map((e=>t.pixels[e])),statistics:t.statistics&&e.map((e=>t.statistics[e]))}):t}function r(t){if(!t)return;const e=t.colormap;if(!e||0===e.length)return;const n=e.sort(((t,e)=>t[0]-e[0]));let i=0;n[0][0]<0&&(i=n[0][0]);const l=Math.max(256,n[n.length-1][0]-i+1),o=new Uint8Array(4*l),r=[];let s,a=0,h=0;const f=5===n[0].length;if(l>65536)return n.forEach((t=>{r[t[0]-i]=f?t.slice(1):t.slice(1).concat([255]);})),{indexed2DColormap:r,offset:i,alphaSpecified:f};if(t.fillUnspecified)for(s=n[h],a=s[0]-i;a<l;a++)o[4*a]=s[1],o[4*a+1]=s[2],o[4*a+2]=s[3],o[4*a+3]=f?s[4]:255,a===s[0]-i&&(s=h===n.length-1?s:n[++h]);else for(a=0;a<n.length;a++)s=n[a],h=4*(s[0]-i),o[h]=s[1],o[h+1]=s[2],o[h+2]=s[3],o[h+3]=f?s[4]:255;return {indexedColormap:o,offset:i,alphaSpecified:f}}function s(e,n){if(!l(e))return e;if(!n&&(n.indexedColormap||n.indexed2DColormap))return e;const i=e.clone(),o=i.pixels;let r=i.mask;const s=i.width*i.height;if(1!==o.length)return e;const{indexedColormap:a,indexed2DColormap:h,offset:f,alphaSpecified:c}=n,u=a.length-1;let p=0;const x=o[0],m=new Uint8Array(x.length),d=new Uint8Array(x.length),y=new Uint8Array(x.length);let g,w=0;if(a)if(r$1(r))for(p=0;p<s;p++)r[p]&&(w=4*(x[p]-f),w<f||w>u?r[p]=0:(m[p]=a[w],d[p]=a[w+1],y[p]=a[w+2],r[p]=a[w+3]));else {for(r=new Uint8Array(s),p=0;p<s;p++)w=4*(x[p]-f),w<f||w>u?r[p]=0:(m[p]=a[w],d[p]=a[w+1],y[p]=a[w+2],r[p]=a[w+3]);i.mask=r;}else if(r$1(r))for(p=0;p<s;p++)r[p]&&(g=h[x[p]],m[p]=g[0],d[p]=g[1],y[p]=g[2],r[p]=g[3]);else {for(r=new Uint8Array(s),p=0;p<s;p++)g=h[x[p]],m[p]=g[0],d[p]=g[1],y[p]=g[2],r[p]=g[3];i.mask=r;}return i.pixels=[m,d,y],i.statistics=null,i.pixelType="u8",i.maskIsAlpha=c,i}function a(t,e){if(!l(t))return null;const{pixels:n,mask:o}=t,r=t.width*t.height,s=n.length;let a=e.lut;const{offset:h}=e;let f,c;a&&1===a[0].length&&(a=n.map((()=>a)));const u=[];let p,x,m;if(h)if(null==o)for(f=0;f<s;f++){for(p=n[f],x=a[f],m=new Uint8Array(r),c=0;c<r;c++)m[c]=x[p[c]-h];u.push(m);}else for(f=0;f<s;f++){for(p=n[f],x=a[f],m=new Uint8Array(r),c=0;c<r;c++)o[c]&&(m[c]=x[p[c]-h]);u.push(m);}else if(null==o)for(f=0;f<s;f++){for(p=n[f],x=a[f],m=new Uint8Array(r),c=0;c<r;c++)m[c]=x[p[c]];u.push(m);}else for(f=0;f<s;f++){for(p=n[f],x=a[f],m=new Uint8Array(r),c=0;c<r;c++)o[c]&&(m[c]=x[p[c]]);u.push(m);}const d=new u$1({width:t.width,height:t.height,pixels:u,mask:o,pixelType:"u8"});return d.updateStatistics(),d}function h(t,e){if(!l(t))return null;const n=t.clone(),{pixels:i}=n,o=n.width*n.height,r=e.length,s=Math.floor(r/2),a=e[Math.floor(s)],h=i[0];let f,c,u,p,x,m,d=!1;const y=new Uint8Array(o),g=new Uint8Array(o),w=new Uint8Array(o);let k=n.mask;const M=4===e[0].mappedColor.length;for(k||(k=new Uint8Array(o),k.fill(M?255:1),n.mask=k),x=0;x<o;x++)if(k[x]){for(f=h[x],d=!1,m=s,c=a,u=0,p=r-1;p-u>1;){if(f===c.value){d=!0;break}f>c.value?u=m:p=m,m=Math.floor((u+p)/2),c=e[Math.floor(m)];}d||(f===e[u].value?(c=e[u],d=!0):f===e[p].value?(c=e[p],d=!0):f<e[u].value?(d=!1,c=null):f>e[u].value&&(f<e[p].value?(c=e[u],d=!0):p===r-1?(d=!1,c=null):(c=e[p],d=!0))),d?(y[x]=c.mappedColor[0],g[x]=c.mappedColor[1],w[x]=c.mappedColor[2],k[x]=c.mappedColor[3]):y[x]=g[x]=w[x]=k[x]=0;}return n.pixels=[y,g,w],n.mask=k,n.pixelType="u8",n.maskIsAlpha=M,n}function f(t,e,n,i,l,o,r,s){return {xmin:l<=n*t?0:l<n*t+t?l-n*t:t,ymin:o<=i*e?0:o<i*e+e?o-i*e:e,xmax:l+r<=n*t?0:l+r<n*t+t?l+r-n*t:t,ymax:o+s<=i*e?0:o+s<i*e+e?o+s-i*e:e}}function c(t$1,n){if(!t$1||0===t$1.length)return null;const i=t$1.find((t=>t.pixelBlock));if(!i||t(i.pixelBlock))return null;const l=(i.extent.xmax-i.extent.xmin)/i.pixelBlock.width,o=(i.extent.ymax-i.extent.ymin)/i.pixelBlock.height,r=.01*Math.min(l,o),s=t$1.sort(((t,e)=>Math.abs(t.extent.ymax-e.extent.ymax)>r?e.extent.ymax-t.extent.ymax:Math.abs(t.extent.xmin-e.extent.xmin)>r?t.extent.xmin-e.extent.xmin:0)),a=Math.min.apply(null,s.map((t=>t.extent.xmin))),h=Math.min.apply(null,s.map((t=>t.extent.ymin))),f=Math.max.apply(null,s.map((t=>t.extent.xmax))),c=Math.max.apply(null,s.map((t=>t.extent.ymax))),u={x:Math.round((n.xmin-a)/l),y:Math.round((c-n.ymax)/o)},x={width:Math.round((f-a)/l),height:Math.round((c-h)/o)},m={width:Math.round((n.xmax-n.xmin)/l),height:Math.round((n.ymax-n.ymin)/o)};if(Math.round(x.width/i.pixelBlock.width)*Math.round(x.height/i.pixelBlock.height)!==s.length||u.x<0||u.y<0||x.width<m.width||x.height<m.height)return null;return {extent:n,pixelBlock:p(s.map((t=>t.pixelBlock)),x,{clipOffset:u,clipSize:m})}}function u(t,e,n,i,l,o){const{width:r,height:s}=n.block,{x:a,y:h}=n.offset,{width:c,height:u}=n.mosaic,p=f(r,s,i,l,a,h,c,u);let x=0,m=0;if(o){const t=o.hasGCSSShiftTransform?360:o.halfWorldWidth,e=r*o.resolutionX,n=o.startX+i*e,l=n+e;n<t&&l>t?m=o.rightPadding:n>=t&&(x=o.leftMargin-o.rightPadding,m=0);}if(p.xmax-=m,"number"!=typeof e)for(let f=p.ymin;f<p.ymax;f++){const n=(l*s+f-h)*c+(i*r-a)+x,o=f*r;for(let i=p.xmin;i<p.xmax;i++)t[n+i]=e[o+i];}else for(let f=p.ymin;f<p.ymax;f++){const n=(l*s+f-h)*c+(i*r-a)+x;for(let i=p.xmin;i<p.xmax;i++)t[n+i]=e;}}function p(n,o,r={}){const{clipOffset:s,clipSize:a,alignmentInfo:h,blockWidths:f}=r;if(f)return x(n,o,{blockWidths:f});const c=n.find((t=>l(t)));if(t(c))return null;const p=a?a.width:o.width,m=a?a.height:o.height,d=c.width,y=c.height,g=o.width/d,w=o.height/y,k={offset:s||{x:0,y:0},mosaic:a||o,block:{width:d,height:y}},M=c.pixelType,A=u$1.getPixelArrayConstructor(M),U=c.pixels.length,C=[];let T,S;for(let t=0;t<U;t++){S=new A(p*m);for(let e=0;e<w;e++)for(let i=0;i<g;i++){const o=n[e*g+i];l(o)&&(T=o.pixels[t],u(S,T,k,i,e,h));}C.push(S);}let B;if(n.some((n=>t(n)||r$1(n.mask)&&n.mask.length>0))){B=new Uint8Array(p*m);for(let e=0;e<w;e++)for(let i=0;i<g;i++){const l=n[e*g+i],o=r$1(l)?l.mask:null;r$1(o)?u(B,o,k,i,e,h):u(B,l?1:0,k,i,e,h);}}const v=new u$1({width:p,height:m,pixels:C,pixelType:M,mask:B});return v.updateStatistics(),v}function x(o,r,s){const a=o.find((e=>r$1(e)));if(t(a))return null;const h=o.some((e=>!r$1(e)||!!e.mask)),{width:f,height:c}=r,u=h?new Uint8Array(f*c):null,{blockWidths:p}=s,x=[],m=a.getPlaneCount(),d=u$1.getPixelArrayConstructor(a.pixelType);if(h)for(let t=0,e=0;t<o.length;e+=p[t],t++){const i=o[t];if(!l(i))continue;const r=e$1(i.mask);for(let n=0;n<c;n++)for(let l=0;l<p[t];l++)u[n*f+l+e]=null==r?255:r[n*i.width+l];}for(let t=0;t<m;t++){const e=new d(f*c);for(let n=0,i=0;n<o.length;i+=p[n],n++){const r=o[n];if(!l(r))continue;const s=r.pixels[t];if(null!=s)for(let t=0;t<c;t++)for(let l=0;l<p[n];l++)e[t*f+l+i]=s[t*r.width+l];}x.push(e);}const y=new u$1({width:f,height:c,mask:u,pixels:x,pixelType:a.pixelType});return y.updateStatistics(),y}function m(t,e,n){if(!l(t))return null;const{width:i,height:o}=t,r=e.x,s=e.y,a=n.width+r,h=n.height+s;if(r<0||s<0||a>i||h>o)return t;if(0===r&&0===s&&a===i&&h===o)return t;t.mask||(t.mask=new Uint8Array(i*o));const f=t.mask;for(let l=0;l<o;l++){const t=l*i;for(let e=0;e<i;e++)f[t+e]=l<s||l>=h||e<r||e>=a?0:1;}return t.updateStatistics(),t}function d(t){if(!l(t))return null;const e=t.clone(),{width:i,height:o,pixels:r}=t,s=r[0],a=e.pixels[0],h=e$1(t.mask);for(let n=2;n<o-1;n++){const t=new Map;for(let l=n-2;l<n+2;l++)for(let e=0;e<4;e++){const n=l*i+e;w(t,s[n],h?h[n]:1);}a[n*i]=y(t),a[n*i+1]=a[n*i+2]=a[n*i];let e=3;for(;e<i-1;e++){let l=(n-2)*i+e+1;w(t,s[l],h?h[l]:1),l=(n-1)*i+e+1,w(t,s[l],h?h[l]:1),l=n*i+e+1,w(t,s[l],h?h[l]:1),l=(n+1)*i+e+1,w(t,s[l],h?h[l]:1),l=(n-2)*i+e-3,g(t,s[l],h?h[l]:1),l=(n-1)*i+e-3,g(t,s[l],h?h[l]:1),l=n*i+e-3,g(t,s[l],h?h[l]:1),l=(n+1)*i+e-3,g(t,s[l],h?h[l]:1),a[n*i+e]=y(t);}a[n*i+e+1]=a[n*i+e];}for(let n=0;n<i;n++)a[n]=a[i+n]=a[2*i+n],a[(o-1)*i+n]=a[(o-2)*i+n];return e.updateStatistics(),e}function y(t){if(0===t.size)return 0;let e=0,n=-1,i=0;const l=t.keys();let o=l.next();for(;!o.done;)i=t.get(o.value),i>e&&(n=o.value,e=i),o=l.next();return n}function g(t,e,n){if(0===n)return;const i=t.get(e);1===i?t.delete(e):t.set(e,i-1);}function w(t,e,n){0!==n&&t.set(e,t.has(e)?t.get(e)+1:1);}function k(t,e,o){let{x:r,y:s}=e;const{width:a,height:h}=o;if(0===r&&0===s&&h===t.height&&a===t.width)return t;const{width:f,height:c}=t,u=Math.max(0,s),p=Math.max(0,r),x=Math.min(r+a,f),m=Math.min(s+h,c);if(x<0||m<0||!l(t))return null;r=Math.max(0,-r),s=Math.max(0,-s);const{pixels:d}=t,y=a*h,g=d.length,w=[];for(let n=0;n<g;n++){const e=d[n],l=u$1.createEmptyBand(t.pixelType,y);for(let t=u;t<m;t++){const n=t*f;let i=(t+s-u)*a+r;for(let t=p;t<x;t++)l[i++]=e[n+t];}w.push(l);}const k=new Uint8Array(y),M=e$1(t.mask);for(let n=u;n<m;n++){const t=n*f;let e=(n+s-u)*a+r;for(let n=p;n<x;n++)k[e++]=M?M[t+n]:1;}const A=new u$1({width:o.width,height:o.height,pixelType:t.pixelType,pixels:w,mask:k});return A.updateStatistics(),A}function M(e,n=!0){if(!l(e))return null;const{pixels:o,width:r,height:s,mask:a,pixelType:h}=e,f=[],c=Math.round(r/2),u=Math.round(s/2),p=s-1,x=r-1;for(let t=0;t<o.length;t++){const e=o[t],l=u$1.createEmptyBand(h,c*u);let a=0;for(let t=0;t<s;t+=2)for(let i=0;i<r;i+=2){const o=e[t*r+i];if(n){const n=i===x?o:e[t*r+i+1],s=t===p?o:e[t*r+i+r],h=i===x?s:t===p?n:e[t*r+i+r+1];l[a++]=(o+n+s+h)/4;}else l[a++]=o;}f.push(l);}let m=null;if(r$1(a)){m=new Uint8Array(c*u);let t=0;for(let e=0;e<s;e+=2)for(let i=0;i<r;i+=2){const l=a[e*r+i];if(n){const n=i===x?l:a[e*r+i+1],o=e===p?l:a[e*r+i+r],s=i===x?o:e===p?n:a[e*r+i+r+1];m[t++]=l*n*o*s?1:0;}else m[t++]=l;}}return new u$1({width:c,height:u,pixelType:h,pixels:f,mask:m})}function A(t,e,n){if(!l(t))return null;const{width:i,height:o}=e;let{width:r,height:s}=t;const a=new Map,h={x:0,y:0},f=null==n?1:1+n;let c=t;for(let l=0;l<f;l++){const t=Math.ceil(r/i),n=Math.ceil(s/o);for(let r=0;r<n;r++){h.y=r*o;for(let n=0;n<t;n++){h.x=n*i;const t=k(c,h,e);a.set(`${l}/${r}/${n}`,t);}}l<f-1&&(c=M(c)),r=Math.round(r/2),s=Math.round(s/2);}return a}function U(t,e,n,i,l=.5){const{width:o,height:r}=t,{width:s,height:a}=e,h=i.cols,f=i.rows,c=Math.ceil(s/h-.1/h),u=Math.ceil(a/f-.1/f);let p,x,m,d,y,g,w;const k=c*h,M=k*u*f,A=new Float32Array(M),U=new Float32Array(M),C=new Uint32Array(M),T=new Uint32Array(M);let S,B,v=0;for(let P=0;P<u;P++)for(let t=0;t<c;t++){p=12*(P*c+t),x=n[p],m=n[p+1],d=n[p+2],y=n[p+3],g=n[p+4],w=n[p+5];for(let e=0;e<f;e++){v=(P*f+e)*k+t*h,B=(e+.5)/f;for(let t=0;t<e;t++)S=(t+.5)/h,A[v+t]=(x*S+m*B+d)*o-l,U[v+t]=(y*S+g*B+w)*r-l,C[v+t]=Math.round(A[v+t]),T[v+t]=Math.round(U[v+t]);}p+=6,x=n[p],m=n[p+1],d=n[p+2],y=n[p+3],g=n[p+4],w=n[p+5];for(let e=0;e<f;e++){v=(P*f+e)*k+t*h,B=(e+.5)/f;for(let t=e;t<h;t++)S=(t+.5)/h,A[v+t]=(x*S+m*B+d)*o-l,U[v+t]=(y*S+g*B+w)*r-l,C[v+t]=Math.round(A[v+t]),T[v+t]=Math.round(U[v+t]);}}return {offsets_x:A,offsets_y:U,offsets_xi:C,offsets_yi:T,gridWidth:k}}function C(t,e){const{coefficients:n,spacing:i}=e,{offsets_x:l,offsets_y:o,gridWidth:r}=U(t,t,n,{rows:i[0],cols:i[1]},.5),{width:s,height:a}=t,h=new Float32Array(s*a),f=180/Math.PI;for(let c=0;c<a;c++)for(let t=0;t<s;t++){const e=c*r+t,n=0===c?e:e-r,i=c===a-1?e:e+r,u=l[n]-l[i],p=o[i]-o[n];if(isNaN(u)||isNaN(p))h[c*s+t]=90;else {let e=Math.atan2(p,u)*f;e=(360+e)%360,h[c*s+t]=e;}}return h}function T(e,n,o,r,s="nearest"){if(!l(e))return null;"majority"===s&&(e=d(e));const{pixels:a,mask:h,pixelType:f}=e,c=e.width,u=e.height,p=u$1.getPixelArrayConstructor(f),x=a.length,{width:m,height:y}=n;let g=!1;for(let t=0;t<o.length;t+=3)-1===o[t]&&-1===o[t+1]&&-1===o[t+2]&&(g=!0);const{offsets_x:w,offsets_y:k,offsets_xi:M,offsets_yi:A,gridWidth:C}=U({width:c,height:u},n,o,r,"majority"===s?0:.5);let T;const S=(t,e,n)=>{const i=t instanceof Float32Array||t instanceof Float64Array?0:.5;for(let l=0;l<y;l++){T=l*C;for(let o=0;o<m;o++){if(w[T]<0||k[T]<0)t[l*m+o]=0;else if(n)t[l*m+o]=e[M[T]+A[T]*c];else {const n=Math.floor(w[T]),r=Math.floor(k[T]),s=Math.ceil(w[T]),a=Math.ceil(k[T]),f=w[T]-n,u=k[T]-r;if(!h||h[n+r*c]&&h[n+r*c]&&h[n+a*c]&&h[s+a*c]){const h=(1-f)*e[n+r*c]+f*e[s+r*c],p=(1-f)*e[n+a*c]+f*e[s+a*c];t[l*m+o]=(1-u)*h+u*p+i;}else t[l*m+o]=e[M[T]+A[T]*c];}T++;}}},B=[];let v;for(let t=0;t<x;t++)v=new p(m*y),S(v,a[t],"nearest"===s||"majority"===s),B.push(v);const P=new u$1({width:m,height:y,pixelType:f,pixels:B});if(r$1(h))P.mask=new Uint8Array(m*y),S(P.mask,h,!0);else if(g){P.mask=new Uint8Array(m*y);for(let t=0;t<m*y;t++)P.mask[t]=w[t]<0||k[t]<0?0:1;}return P.updateStatistics(),P}

export { A, C, T, a, c, h, l, m, o, p, r, s, u$1 as u };
