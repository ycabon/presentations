import { J as s, gC as l, L, T as d, t, gI as X, gJ as o, c4 as k, gn as c, bu as t$1, r, bp as fe, bq as ie, gK as ye, gL as G$1, br as L$1, gM as C, gN as _ } from './_virtual_index-4b72c57d.js';
import { f, g } from './projectionSupport-8e09cd0f.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
const j=new s({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),U=Object.freeze({}),M=new t$1,F=new t$1,G=new t$1,N={esriGeometryPoint:G$1,esriGeometryPolyline:L$1,esriGeometryPolygon:C,esriGeometryMultipoint:_};function O(e,r,i,o=e.hasZ,n=e.hasM){if(t(r))return null;const s=e.hasZ&&o,l=e.hasM&&n;if(i){const t=ie(G,r,e.hasZ,e.hasM,"esriGeometryPoint",i,o,n);return G$1(t,s,l)}return G$1(r,s,l)}function J(e,i,o,n,s,l,a=i,m=o){const c=i&&a,f=o&&m,g=r(n)?"coords"in n?n:n.geometry:null;if(t(g))return null;if(s){let t=fe(F,g,i,o,e,s,a,m);return l&&(t=ie(G,t,c,f,e,l)),N[e](t,c,f)}if(l){const t=ie(G,g,i,o,e,l,a,m);return N[e](t,c,f)}return ye(M,g,i,o,a,m),N[e](M,c,f)}async function P(e,t,r){const{outFields:i,orderByFields:o,groupByFieldsForStatistics:n,outStatistics:s}=e;if(i)for(let l=0;l<i.length;l++)i[l]=i[l].trim();if(o)for(let l=0;l<o.length;l++)o[l]=o[l].trim();if(n)for(let l=0;l<n.length;l++)n[l]=n[l].trim();if(s)for(let l=0;l<s.length;l++)s[l].onStatisticField&&(s[l].onStatisticField=s[l].onStatisticField.trim());return e.geometry&&!e.outSR&&(e.outSR=e.geometry.spatialReference),v(e,t,r)}async function v(e,r,i){if(!e)return null;let{where:l$1}=e;if(e.where=l$1=l$1&&l$1.trim(),(!l$1||/^1 *= *1$/.test(l$1)||r&&r===l$1)&&(e.where=null),!e.geometry)return e;let a=await Z(e);if(e.distance=0,e.units=null,"esriSpatialRelEnvelopeIntersects"===e.spatialRel){const{spatialReference:t}=e.geometry;a=l(a),a.spatialReference=t;}e.geometry=a,await f(a.spatialReference,i);const m=(await L(d(a)))[0];if(t(m))throw U;const c=m.toJSON(),u=await g(c,c.spatialReference,i);if(!u)throw U;return u.spatialReference=i,e.geometry=u,e}async function Z(e){const{geometry:t,distance:r,units:o$1}=e;if(null==r||"vertexAttributes"in t)return t;const n=t.spatialReference,s=o$1?j.fromJSON(o$1):X(n),c$1=n&&(o(n)||k(n))?t:await f(n,c).then((()=>g(t,c)));return (await b())(c$1.spatialReference,c$1,r,s)}async function b(){return (await import('./geometryEngineJSON-c7445cad.js')).geodesicBuffer}function x(e){return e&&z in e?JSON.parse(JSON.stringify(e,B)):e}const z="_geVersion",B=(e,t)=>e!==z?t:void 0;

export { J, O, P, U, v, x };
