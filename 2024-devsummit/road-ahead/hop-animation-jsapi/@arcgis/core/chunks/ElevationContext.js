/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{c as e}from"./mat4.js";import{c as t}from"./mat4f64.js";import{c as n}from"./vec3f64.js";import{c as r}from"./computeTranslationToOriginAndRotation.js";import{p as o}from"./projectBuffer.js";import{i as s,a as i,g as a}from"./ElevationProvider.js";import{V as u}from"./VertexAttribute.js";import{g as l,a as f}from"./unitConversionUtils.js";import{L as c}from"./Logger.js";import{throwIfAborted as d}from"../core/promiseUtils.js";import{b as m}from"./hydratedFeatures.js";import{l as p}from"../layers/support/fieldUtils.js";function h(e,t,n,r,s,i,a,u,l,f,c){const d=C[c.mode];let m,p,h=0;if(o(e,t,n,r,l.spatialReference,s,u))return d.requiresAlignment(c)?(h=d.applyElevationAlignmentBuffer(r,s,i,a,u,l,f,c),m=i,p=a):(m=r,p=s),o(m,l.spatialReference,p,i,f.spatialReference,a,u)?h:void 0}function E(e,t,n,r,o){const u=(s(e)?e.z:i(e)?e.array[e.offset+2]:e[2])||0;switch(n.mode){case"on-the-ground":{const n=a(t,e,"ground")??0;return o.verticalDistanceToGround=0,o.sampledElevation=n,void(o.z=n)}case"relative-to-ground":{const s=a(t,e,"ground")??0,i=n.geometryZWithOffset(u,r);return o.verticalDistanceToGround=i,o.sampledElevation=s,void(o.z=i+s)}case"relative-to-scene":{const s=a(t,e,"scene")??0,i=n.geometryZWithOffset(u,r);return o.verticalDistanceToGround=i,o.sampledElevation=s,void(o.z=i+s)}case"absolute-height":{const s=n.geometryZWithOffset(u,r),i=a(t,e,"ground")??0;return o.verticalDistanceToGround=s-i,o.sampledElevation=i,void(o.z=s)}default:return void(o.z=0)}}function g(e,t,n,r){return E(e,t,n,r,A),A.z}function v(e,t,n){return null==t||null==n?e.definedChanged:"on-the-ground"===t&&"on-the-ground"===n?e.staysOnTheGround:t===n||"on-the-ground"!==t&&"on-the-ground"!==n?_.UPDATE:e.onTheGroundChanged}function x(e){return"relative-to-ground"===e||"relative-to-scene"===e}function U(e){return"absolute-height"!==e}function I(t,n,o,s,i){E(n,o,i,s,A),O(t,A.verticalDistanceToGround);const a=A.sampledElevation,u=e(y,t.transformation);return T[0]=n.x,T[1]=n.y,T[2]=A.z,r(n.spatialReference,T,u,s.spatialReference)?t.transformation=u:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function O(e,t){for(let n=0;n<e.geometries.length;++n){const r=e.geometries[n].getMutableAttribute(u.CENTEROFFSETANDDISTANCE);r&&r.data[3]!==t&&(r.data[3]=t,e.geometryVertexAttributeUpdated(e.geometries[n],u.CENTEROFFSETANDDISTANCE))}}class R{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var _;!function(e){e[e.NONE=0]="NONE",e[e.UPDATE=1]="UPDATE",e[e.RECREATE=2]="RECREATE"}(_||(_={}));const C={"absolute-height":{applyElevationAlignmentBuffer:function(e,t,n,r,o,s,i,a){const u=a.calculateOffsetRenderUnits(i),l=a.featureExpressionInfoContext;t*=3,r*=3;for(let s=0;s<o;++s){const o=e[t],s=e[t+1],i=e[t+2];n[r]=o,n[r+1]=s,n[r+2]=null==l?i+u:u,t+=3,r+=3}return 0},requiresAlignment:function(e){const t=e.meterUnitOffset,n=e.featureExpressionInfoContext;return 0!==t||null!=n}},"on-the-ground":{applyElevationAlignmentBuffer:function(e,t,n,r,o,s){let i=0;const a=s.spatialReference;t*=3,r*=3;for(let u=0;u<o;++u){const o=e[t],u=e[t+1],l=e[t+2],f=s.getElevation(o,u,l,a,"ground")??0;i+=f,n[r]=o,n[r+1]=u,n[r+2]=f,t+=3,r+=3}return i/o},requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:function(e,t,n,r,o,s,i,a){let u=0;const l=a.calculateOffsetRenderUnits(i),f=a.featureExpressionInfoContext,c=s.spatialReference;t*=3,r*=3;for(let i=0;i<o;++i){const o=e[t],i=e[t+1],a=e[t+2],d=s.getElevation(o,i,a,c,"ground")??0;u+=d,n[r]=o,n[r+1]=i,n[r+2]=null==f?a+d+l:d+l,t+=3,r+=3}return u/o},requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:function(e,t,n,r,o,s,i,a){let u=0;const l=a.calculateOffsetRenderUnits(i),f=a.featureExpressionInfoContext,c=s.spatialReference;t*=3,r*=3;for(let i=0;i<o;++i){const o=e[t],i=e[t+1],a=e[t+2],d=s.getElevation(o,i,a,c,"scene")??0;u+=d,n[r]=o,n[r+1]=i,n[r+2]=null==f?a+d+l:d+l,t+=3,r+=3}return u/o},requiresAlignment:()=>!0}},y=t(),A=new R,T=n();function b(e){const t=e?.expression;if("string"==typeof t){const e=w(t);if(null!=e)return{cachedResult:e}}return null}async function j(e,t,n,r){const o=e?.expression;if("string"!=typeof o)return null;const s=w(o);if(null!=s)return{cachedResult:s};const i=await p();d(n);const a=i.arcadeUtils,u=a.createSyntaxTree(o);return a.dependsOnView(u)?(null!=r&&r.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:a.createFunction(u),context:a.createExecContext(null,{sr:t}),modules:i}}}function D(e,t,n){return e.arcadeUtils.createFeature(t.attributes,t.geometry,n)}function F(e,t){if(null!=e&&!P(e)){if(!t||!e.arcade)return void c.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils").errorOncePerTick("Arcade support required but not provided");const n=t;n._geometry&&(n._geometry=m(n._geometry)),e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context,t)}}function z(e,t=!1){let n=e?.featureExpressionInfo;const r=n?.expression;return t||"0"===r||(n=null),n??null}const N={cachedResult:0};function P(e){return null!=e.cachedResult}function w(e){return"0"===e?0:null}class G{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=l(e)}get requiresSampledElevationInfo(){return"absolute-height"!==this.mode}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,t){const n=this.calculateOffsetRenderUnits(t);return null!=this.featureExpressionInfoContext?n:e+n}calculateOffsetRenderUnits(e){let t=this._meterUnitOffset;const n=this.featureExpressionInfoContext;return null!=n&&(t+=function(e){if(null!=e){if(P(e))return e.cachedResult;const t=e.arcade;let n=t?.modules.arcadeUtils.executeFunction(t.func,t.context);return"number"!=typeof n&&(e.cachedResult=0,n=0),n}return 0}(n)*this._metersPerElevationInfoUnit),t/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=f(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=e.offset??0}updateFeatureExpressionInfoContext(e,t,n){if(null==e)return void(this._featureExpressionInfoContext=null);const r=e?.arcade;var o;r&&null!=t&&null!=n?(this._featureExpressionInfoContext={cachedResult:(o=e).cachedResult,arcade:o.arcade?{func:o.arcade.func,context:o.arcade.modules.arcadeUtils.createExecContext(null,{sr:o.arcade.context.spatialReference}),modules:o.arcade.modules}:null},F(this._featureExpressionInfoContext,D(r.modules,t,n))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const t=new G;return null!=e&&t.setFromElevationInfo(e),t}}export{G as E,R as S,h as a,z as b,j as c,E as d,g as e,b as f,_ as g,I as h,v as i,D as j,U as k,x as n,F as s,O as u,N as z};
