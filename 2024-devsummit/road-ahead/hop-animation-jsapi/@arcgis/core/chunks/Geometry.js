/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{I as t,a as i}from"./mat4f64.js";import{a as e,k as s,s as n,h as r,b as a,G as o,g as h}from"./vec3.js";import{c as u,a as c}from"./Indices.js";import{n as l,c as m,g as d}from"../core/lang.js";import{O as g}from"./basicInterfaces.js";import{P as f}from"../core/scheduling.js";import{f as b,a as _,c as I}from"./vec3f64.js";import{a as p}from"./Util.js";import{a as P,C as x}from"./ContentObject.js";import{b as v}from"./triangle.js";import{g as A}from"../core/Accessor.js";import{V as M}from"./VertexAttribute.js";import{e as y}from"./doublePrecisionUtils.js";function O(t){if(t.length<l)return Array.from(t);if(m(t))return Float64Array.from(t);if(!("BYTES_PER_ELEMENT"in t))return Array.from(t);switch(t.BYTES_PER_ELEMENT){case 1:return Uint8Array.from(t);case 2:return d(t)?Uint16Array.from(t):Int16Array.from(t);case 4:return Float32Array.from(t);default:return Float64Array.from(t)}}class j{constructor(t,i,s){this.primitiveIndices=t,this._numIndexPerPrimitive=i,this.position=s,this._children=void 0,p(t.length>=1),p(3===s.size||4===s.size);const{data:n,size:r,indices:a}=s;p(a.length%this._numIndexPerPrimitive==0),p(a.length>=t.length*this._numIndexPerPrimitive);const o=t.length;let h=r*a[this._numIndexPerPrimitive*t[0]];w.clear(),w.push(h);const u=b(n[h],n[h+1],n[h+2]),c=_(u);for(let i=0;i<o;++i){const e=this._numIndexPerPrimitive*t[i];for(let t=0;t<this._numIndexPerPrimitive;++t){h=r*a[e+t],w.push(h);let i=n[h];u[0]=Math.min(i,u[0]),c[0]=Math.max(i,c[0]),i=n[h+1],u[1]=Math.min(i,u[1]),c[1]=Math.max(i,c[1]),i=n[h+2],u[2]=Math.min(i,u[2]),c[2]=Math.max(i,c[2])}}this.bbMin=u,this.bbMax=c;const l=e(I(),this.bbMin,this.bbMax,.5);this.radius=.5*Math.max(Math.max(c[0]-u[0],c[1]-u[1]),c[2]-u[2]);let m=this.radius*this.radius;for(let t=0;t<w.length;++t){h=w.at(t);const i=n[h]-l[0],e=n[h+1]-l[1],s=n[h+2]-l[2],r=i*i+e*e+s*s;if(r<=m)continue;const a=Math.sqrt(r),o=.5*(a-this.radius);this.radius=this.radius+o,m=this.radius*this.radius;const u=o/a;l[0]+=i*u,l[1]+=e*u,l[2]+=s*u}this.center=l,w.clear()}getChildren(){if(this._children||s(this.bbMin,this.bbMax)<=1)return this._children;const t=e(I(),this.bbMin,this.bbMax,.5),i=this.primitiveIndices.length,n=new Uint8Array(i),r=new Array(8);for(let t=0;t<8;++t)r[t]=0;const{data:a,size:o,indices:h}=this.position;for(let e=0;e<i;++e){let i=0;const s=this._numIndexPerPrimitive*this.primitiveIndices[e];let u=o*h[s],c=a[u],l=a[u+1],m=a[u+2];for(let t=1;t<this._numIndexPerPrimitive;++t){u=o*h[s+t];const i=a[u],e=a[u+1],n=a[u+2];i<c&&(c=i),e<l&&(l=e),n<m&&(m=n)}c<t[0]&&(i|=1),l<t[1]&&(i|=2),m<t[2]&&(i|=4),n[e]=i,++r[i]}let u=0;for(let t=0;t<8;++t)r[t]>0&&++u;if(u<2)return;const c=new Array(8);for(let t=0;t<8;++t)c[t]=r[t]>0?new Uint32Array(r[t]):void 0;for(let t=0;t<8;++t)r[t]=0;for(let t=0;t<i;++t){const i=n[t];c[i][r[i]++]=this.primitiveIndices[t]}this._children=new Array;for(let t=0;t<8;++t)void 0!==c[t]&&this._children.push(new j(c[t],this._numIndexPerPrimitive,this.position));return this._children}static prune(){w.prune()}}const w=new f({deallocator:null}),L=I(),E=I(),T=I(),C=I();class z{constructor(t){this.channel=t,this.id=A()}}function N(t,i){return null==t&&(t=[]),t.push(i),t}function S(t,i){if(null==t)return null;const e=t.filter((t=>t!==i));return 0===e.length?null:e}function B(t,i,e,s,n){U[0]=t.get(i,0),U[1]=t.get(i,1),U[2]=t.get(i,2),y(U,F,3),e.set(n,0,F[0]),s.set(n,0,F[1]),e.set(n,1,F[2]),s.set(n,1,F[3]),e.set(n,2,F[4]),s.set(n,2,F[5])}const U=I(),F=new Float32Array(6);class H extends P{constructor(t,i,e=null,s=x.Mesh,n=null,r=-1){super(),this.material=t,this.mapPositions=e,this.type=s,this.objectAndLayerIdColor=n,this.edgeIndicesLength=r,this.visible=!0,this._attributes=new Map,this._boundingInfo=null;for(const[t,e]of i)this._attributes.set(t,{...e,indices:u(e.indices)}),t===M.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._attributes.get(t).indices.length:this.edgeIndicesLength)}instantiate(t={}){const i=new H(t.material||this.material,[],this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._attributes.forEach(((t,e)=>{t.exclusive=!1,i._attributes.set(e,t)})),i._boundingInfo=this._boundingInfo,i.transformation=t.transformation||this.transformation,i}get attributes(){return this._attributes}getMutableAttribute(t){let i=this._attributes.get(t);return i&&!i.exclusive&&(i={...i,exclusive:!0,data:O(i.data)},this._attributes.set(t,i)),i}setAttributeData(t,i){const e=this._attributes.get(t);e&&this._attributes.set(t,{...e,exclusive:!0,data:i})}get indexCount(){const t=this._attributes.values().next().value.indices;return t?.length??0}get faceCount(){return this.indexCount/3}get boundingInfo(){return null==this._boundingInfo&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(t){return!!(this.type===x.Mesh?this._computeAttachmentOriginTriangles(t):this.type===x.Line?this._computeAttachmentOriginLines(t):this._computeAttachmentOriginPoints(t))&&(null!=this._transformation&&h(t,t,this._transformation),!0)}_computeAttachmentOriginTriangles(t){return function(t,i){if(!t)return!1;const{size:e,data:s,indices:o}=t;n(i,0,0,0),n(C,0,0,0);let h=0,u=0;for(let t=0;t<o.length-2;t+=3){const c=o[t]*e,l=o[t+1]*e,m=o[t+2]*e;n(L,s[c],s[c+1],s[c+2]),n(E,s[l],s[l+1],s[l+2]),n(T,s[m],s[m+1],s[m+2]);const d=v(L,E,T);d?(r(L,L,E),r(L,L,T),a(L,L,1/3*d),r(i,i,L),h+=d):(r(C,C,L),r(C,C,E),r(C,C,T),u+=3)}return!(0===u&&0===h||(0!==h?(a(i,i,1/h),0):0===u||(a(i,C,1/u),0)))}(this.attributes.get(M.POSITION),t)}_computeAttachmentOriginLines(t){const i=this.attributes.get(M.POSITION);return function(t,i,e){if(!t)return!1;n(e,0,0,0),n(C,0,0,0);let s=0,h=0;const{size:u,data:c,indices:l}=t,m=l.length-1,d=m+(i?2:0);for(let t=0;t<d;t+=2){const i=t<m?t+1:0,n=l[t<m?t:m]*u,d=l[i]*u;L[0]=c[n],L[1]=c[n+1],L[2]=c[n+2],E[0]=c[d],E[1]=c[d+1],E[2]=c[d+2],a(L,r(L,L,E),.5);const g=o(L,E);g>0?(r(e,e,a(L,L,g)),s+=g):0===s&&(r(C,C,L),h++)}return 0!==s?(a(e,e,1/s),!0):0!==h&&(a(e,C,1/h),!0)}(i,function(t,i){return!(!("isClosed"in t)||!t.isClosed)&&i.indices.length>2}(this.material.parameters,i),t)}_computeAttachmentOriginPoints(t){return function(t,i){if(!t)return!1;const{size:e,data:s,indices:r}=t;n(i,0,0,0);let o=-1,h=0;for(let t=0;t<r.length;t++){const n=r[t]*e;o!==n&&(i[0]+=s[n],i[1]+=s[n+1],i[2]+=s[n+2],h++),o=n}return h>1&&a(i,i,1/h),h>0}(this.attributes.get(M.POSITION),t)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const t=this.attributes.get(M.POSITION);if(!t||0===t.indices.length)return null;const i=this.type===x.Mesh?3:1;p(t.indices.length%i==0,"Indexing error: "+t.indices.length+" not divisible by "+i);const e=c(t.indices.length/i);return new j(e,i,t)}get transformation(){return this._transformation??t}set transformation(e){this._transformation=e&&e!==t?i(e):null}addHighlight(){const t=new z(g.Highlight);return this.highlights=N(this.highlights,t),t}removeHighlight(t){this.highlights=S(this.highlights,t)}}export{j as B,H as G,z as O,N as a,B as e,S as r};
