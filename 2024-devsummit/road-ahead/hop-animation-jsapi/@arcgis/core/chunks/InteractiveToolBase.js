/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import"../geometry.js";import{i as t,clone as e}from"../core/lang.js";import{c as n}from"./mathUtils.js";import{c as a}from"./screenUtils.js";import{f as r,a as i}from"./vec3f64.js";import{project as o}from"../geometry/projection.js";import{i as s,v as l}from"./meshVertexSpaceUtils.js";import{a as c,c as u}from"./hydratedFeatures.js";import{M as p}from"./interfaces.js";import{h}from"./elevationInfoUtils.js";import{V as d}from"./ViewingMode.js";import{m}from"./drawUtils.js";import f from"../geometry/Point.js";import{_ as y}from"./tslib.es6.js";import v from"../core/Accessor.js";import{L as g}from"./Logger.js";import{createResolver as E}from"../core/promiseUtils.js";import{property as b}from"../core/accessorSupport/decorators/property.js";import{subclass as _}from"../core/accessorSupport/decorators/subclass.js";import{E as M}from"./interfaces2.js";import x from"../core/Collection.js";function S(t,e){return t.events.on("drag",function(t,e){let n=null,a=null;return r=>{if("cancel"===r.action)return void(null!=a&&(a.execute({action:"cancel"}),n=null,a=null));const i={action:r.action,screenStart:r.start,screenEnd:r.screenPoint};"start"===r.action&&null==n&&(n=new O,a=new O,e(t,n,a,r.pointerType,i)),null!=n&&n.execute(i),"end"===r.action&&null!=n&&(n=null,a=null)}}(t,e))}function w(t,e){const n=[t.x,t.y,t.z??0],a=e,r=[Math.cos(a),Math.sin(a)],i=Math.sqrt(r[0]*r[0]+r[1]*r[1]);if(0===i)return null;r[0]/=i,r[1]/=i;const o=t=>{const e=(t.x-n[0])*r[0]+(t.y-n[1])*r[1];t.x=n[0]+e*r[0],t.y=n[1]+e*r[1]};return t=>(o(t.mapStart),o(t.mapEnd),{...t,axis:r})}function A(t,e){let n=null;return a=>{if("start"===a.action&&(n=function(t,e,n){const a=t.geometry,i=c(e);if(null==a)return null;if("mesh"===a.type)return function(t,e,n,a){if(s(e.vertexSpace))return function(t,e,n,a){const i=j(l(e.vertexSpace,e.spatialReference),a),s=e.spatialReference;return null==i?null:{move:(e,a,l,c)=>{const u=m(i.clone(),e,a,l);if(u.spatialReference.equals(s))n.origin=r(u.x,u.y,u.z??0);else{const t=o(u,s);null!=t&&(n.origin=r(t.x,t.y,t.z??0))}if("georeferenced"===n.type)t.notifyGeometryChanged();else{const e="end"===c;t.notifyMeshTransformChanged(e?{action:p.UpdateFastLocalOrigin}:{})}}}}(t,e,e.vertexSpace,n);if(!e.spatialReference.equals(n))return null;let i=0,c=0,u=0;return{move:(n,r,o)=>{const l=n-i,p=r-c,h=o-u;if(l||p||h){const m=new f(e.origin.x+l,e.origin.y+p,(e.origin.z??0)+h,e.origin.spatialReference);e.centerAt(m,{geographic:s(e.vertexSpace)?void 0:a===d.Global}),t.notifyGeometryChanged(),i=n,c=r,u=o}}}}(t,a,i,n);const u=j(a,i),h=a.spatialReference;return null==u?null:{move:(e,n,a)=>{const r=m(u.clone(),e,n,a);r.spatialReference.equals(h)?t.geometry=r:t.geometry=o(r,h)}}}(t,a.mapStart.spatialReference,e)),null==n)return null;const i=a.mapEnd.x-a.mapStart.x,u=a.mapEnd.y-a.mapStart.y,h=a.mapEnd.z-a.mapStart.z;return n.move(i,u,h,a.action),{...a,translationX:i,translationY:u,translationZ:h}}}function j(t,e){return null==t?null:t.spatialReference.equals(e)?t.clone():o(t,e)}function R(t,e=null,n){let a=null;const r=null==e||t.spatialReference?.equals(e)?t=>t:t=>null!=t?o(t,e):t,i={exclude:[],...n};return e=>{if("start"===e.action&&(a=r(t.toMap(e.screenStart,i))),null==a)return null;const n=r(t.toMap(e.screenEnd,i));return null!=n?{...e,mapStart:a,mapEnd:n}:null}}function C(e,n){const a=e.map((t=>A(t,n))).filter(t);return t=>{const e=t.mapEnd.x-t.mapStart.x,n=t.mapEnd.y-t.mapStart.y,r=t.mapEnd.z-t.mapStart.z;return a.forEach((e=>e(t))),{...t,translationX:e,translationY:n,translationZ:r}}}function T(t,n){const a=new Map;for(const r of n)a.set(r,e(t[r]));return e=>(a.forEach(((e,n)=>{t[n]=e})),e)}function z(t){return null!=t.geometry&&"mesh"===t.geometry.type?function(t,e){const{vertexSpace:n}=e;if("georeferenced"===n.type){const n=e.vertexAttributes.clonePositional();return a=>(e.vertexAttributes=n,t.notifyGeometryChanged(),a)}const a=i(n.origin),r=e.transform?.clone();return n=>(e.transform=r,e.vertexSpace.origin=a,t.notifyMeshTransformChanged(),n)}(t,t.geometry):T(t,["geometry"])}function F(t){const e=t.map((t=>z(t))).filter((t=>null!=t));return t=>(e.forEach((e=>e(t))),t)}function I(){let t=0,e=0,n=0;return a=>{"start"===a.action&&(t=a.mapStart.x,e=a.mapStart.y,n=a.mapStart.z);const r=a.mapEnd.x-t,i=a.mapEnd.y-e,o=a.mapEnd.z-n;return t=a.mapEnd.x,e=a.mapEnd.y,n=a.mapEnd.z,{...a,mapDeltaX:r,mapDeltaY:i,mapDeltaZ:o,mapDeltaSpatialReference:a.mapStart.spatialReference}}}function U(){let t=0,e=0;return n=>{"start"===n.action&&(t=n.screenStart.x,e=n.screenStart.y);const a=n.screenEnd.x-t,r=n.screenEnd.y-e;return t=n.screenEnd.x,e=n.screenEnd.y,{...n,screenDeltaX:a,screenDeltaY:r}}}function G(t,e){let r=null,i=0,o=0;return s=>{if("start"===s.action&&(r=t.toScreen?.(e),null!=r&&(r.x<0||r.x>t.width||r.y<0||r.y>t.height?r=null:(i=s.screenStart.x-r.x,o=s.screenStart.y-r.y))),null==r)return null;const l=n(s.screenEnd.x-i,0,t.width),c=n(s.screenEnd.y-o,0,t.height),u=a(l,c);return s.screenStart=r,s.screenEnd=u,s}}const D=()=>{};class O{constructor(){this.execute=D}next(t,e=new O){return null!=t&&(this.execute=n=>{const a=t(n);null!=a&&e.execute(a)}),e}}function P(t,e,n=[]){if("2d"===t.type)return t=>t;let a=null;return r=>{"start"===r.action&&(a=t.toMap(r.screenStart,{exclude:n}),null!=a&&(a.z=h(a,t,e)));const i=t.toMap(r.screenEnd,{exclude:n});null!=i&&(i.z=h(i,t,e));const o=null!=a&&null!=i?{sceneStart:a,sceneEnd:i}:null;return{...r,scenePoints:o}}}function V(t,e,n){const a=e.elevationProvider.getElevation(t.x,t.y,t.z??0,t.spatialReference,"scene")??0,r=u(t);return r.z=a,r.hasZ=!0,r.z=h(r,e,n),r}function W(t,e){if("2d"===t.type)return t=>t;let n=null;return a=>{"start"===a.action&&(n=V(a.mapStart,t,e));const r=V(a.mapEnd,t,e),i=null!=n&&null!=r?{sceneStart:n,sceneEnd:r}:null;return{...a,scenePoints:i}}}var q;!function(t){t[t.WhenToolEditable=0]="WhenToolEditable",t[t.WhenToolNotEditable=1]="WhenToolNotEditable",t[t.Always=2]="Always"}(q||(q={}));class N{constructor(){this._isToolEditable=!0,this._manipulators=new x,this._resourceContexts={manipulator3D:{}},this._attached=!1}set isToolEditable(t){this._isToolEditable=t}get length(){return this._manipulators.length}add(t,e=q.WhenToolEditable){this.addMany([t],e)}addMany(t,e=q.WhenToolEditable){for(const n of t){const t={manipulator:n,visibilityPredicate:e,attached:!1};this._manipulators.add(t),this._attached&&this._updateManipulatorAttachment(t)}}remove(t){for(let e=0;e<this._manipulators.length;e++)if(this._manipulators.at(e).manipulator===t){const t=this._manipulators.splice(e,1)[0];this._detachManipulator(t);break}}removeAll(){this._manipulators.forEach((t=>{this._detachManipulator(t)})),this._manipulators.removeAll()}attach(){this._manipulators.forEach((t=>{this._updateManipulatorAttachment(t)})),this._attached=!0}detach(){this._manipulators.forEach((t=>{this._detachManipulator(t)})),this._attached=!1}destroy(){this.detach(),this._manipulators.forEach((({manipulator:t})=>t.destroy())),this._manipulators.destroy(),this._resourceContexts=null}on(t,e){return this._manipulators.on(t,(t=>{e(t)}))}forEach(t){for(const e of this._manipulators.items)t(e)}some(t){return this._manipulators.items.some(t)}toArray(){const t=[];return this.forEach((e=>t.push(e.manipulator))),t}intersect(t,e){let n=null,a=Number.MAX_VALUE;return this._manipulators.forEach((({manipulator:r,attached:i})=>{if(!i||!r.interactive)return;const o=r.intersectionDistance(t,e);null!=o&&o<a&&(a=o,n=r)})),n}_updateManipulatorAttachment(t){this._isManipulatorItemVisible(t)?this._attachManipulator(t):this._detachManipulator(t)}_attachManipulator(t){t.attached||(t.manipulator.attach&&t.manipulator.attach(this._resourceContexts),t.attached=!0)}_detachManipulator(t){if(!t.attached)return;const e=t.manipulator;e.grabbing=!1,e.dragging=!1,e.hovering=!1,e.selected=!1,e.detach&&e.detach(this._resourceContexts),t.attached=!1}_isManipulatorItemVisible(t){return t.visibilityPredicate===q.Always||(this._isToolEditable?t.visibilityPredicate===q.WhenToolEditable:t.visibilityPredicate===q.WhenToolNotEditable)}}let H=class extends v{constructor(t){super(t),this.manipulators=new N,this.automaticManipulatorSelection=!0,this.hasGrabbedManipulators=!1,this.hasHoveredManipulators=!1,this.firstGrabbedManipulator=null,this.created=!1,this.removeIncompleteOnCancel=!0,this._editableFlags=new Map([[M.MANAGER,!0],[M.USER,!0]]),this._creationFinishedResolver=E()}get active(){return null!=this.view&&this.view.activeTool===this}set visible(t){this._get("visible")!==t&&(this._set("visible",t),this._syncVisible())}get editable(){return this.getEditableFlag(M.USER)}set editable(t){this.setEditableFlag(M.USER,t)}get updating(){return!1}get cursor(){return null}get hasFocusedManipulators(){return this.hasGrabbedManipulators||this.hasHoveredManipulators}destroy(){this.manipulators.destroy(),this._set("view",null)}onAdd(){this._syncVisible()}activate(){null!=this.view?(this.view.focus(),this.onActivate()):g.getLogger(this).error("Can't activate tool if view is not defined.")}deactivate(){this.onDeactivate()}handleInputEvent(t){this.onInputEvent(t)}handleInputEventAfter(t){this.onInputEventAfter(t)}setEditableFlag(t,e){this._editableFlags.set(t,e),this.manipulators.isToolEditable=this.internallyEditable,this._updateManipulatorAttachment(),t===M.USER&&this.notifyChange("editable"),this.onEditableChange(),this.onManipulatorSelectionChanged()}getEditableFlag(t){return this._editableFlags.get(t)??!1}whenCreated(){return this._creationFinishedResolver.promise}onManipulatorSelectionChanged(){}onActivate(){}onDeactivate(){}onShow(){}onHide(){}onEditableChange(){}onInputEvent(t){}onInputEventAfter(t){}get internallyEditable(){return this.getEditableFlag(M.USER)&&this.getEditableFlag(M.MANAGER)}finishToolCreation(){this.created||this._creationFinishedResolver.resolve(this),this._set("created",!0)}_syncVisible(){if(this.initialized)if(this.visible)this._show();else if(this._hide(),this.active)return void(this.view.activeTool=null)}_show(){this._updateManipulatorAttachment(),this.onShow()}_hide(){this._updateManipulatorAttachment(),this.onHide()}_updateManipulatorAttachment(){this.visible?this.manipulators.attach():this.manipulators.detach()}};y([b({constructOnly:!0})],H.prototype,"view",void 0),y([b({readOnly:!0})],H.prototype,"active",null),y([b({value:!0})],H.prototype,"visible",null),y([b({value:!0})],H.prototype,"editable",null),y([b({readOnly:!0})],H.prototype,"manipulators",void 0),y([b({readOnly:!0})],H.prototype,"updating",null),y([b()],H.prototype,"cursor",null),y([b({readOnly:!0})],H.prototype,"automaticManipulatorSelection",void 0),y([b()],H.prototype,"hasFocusedManipulators",null),y([b()],H.prototype,"hasGrabbedManipulators",void 0),y([b()],H.prototype,"hasHoveredManipulators",void 0),y([b()],H.prototype,"firstGrabbedManipulator",void 0),y([b({readOnly:!0})],H.prototype,"created",void 0),y([b({readOnly:!0})],H.prototype,"removeIncompleteOnCancel",void 0),H=y([_("esri.views.interactive.InteractiveToolBase")],H);export{O as E,H as I,N as M,P as a,z as b,S as c,A as d,G as e,w as f,U as g,I as h,C as i,F as j,W as k,T as r,R as s};
