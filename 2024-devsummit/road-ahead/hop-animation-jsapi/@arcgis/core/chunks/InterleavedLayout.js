/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{B as t,a as e,b as s,c as i,d as r,e as n,f as a,g as h,h as d,i as u,j as f,k as l,l as o,m as p,n as c,o as _,p as y,q as F,r as m,s as w,t as g,u as b,v,w as E,x as A,y as T,z as B,A as M,C,D as U,E as j,F as x,G as z,H as L,I as $,J as k}from"./BufferView.js";import{e as I}from"./types.js";import{a as V}from"./Util.js";class q{constructor(t,e){this.layout=t,this.buffer="number"==typeof e?new ArrayBuffer(e*t.stride):e;for(const e of t.fields.keys()){const s=t.fields.get(e);this[e]=new s.constructor(this.buffer,s.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const s=this[t];return s&&s.elementCount===e.ElementCount&&s.elementType===e.ElementType?s:null}slice(t,e){return new q(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,s=0,i=t.count){const r=this.stride;if(r%4==0){const n=new Uint32Array(t.buffer,e*r,i*r/4);new Uint32Array(this.buffer,s*r,i*r/4).set(n)}else{const n=new Uint8Array(t.buffer,e*r,i*r);new Uint8Array(this.buffer,s*r,i*r).set(n)}return this}get usedMemory(){return this.byteLength}dispose(){}}class D{constructor(t=null){this._stride=0,this._lastAligned=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach((t=>{return this._fields.set(t[0],{...t[1],constructor:(e=t[1].constructor,K.get(e))});var e})))}vec2f(t,s){return this._appendField(t,e,s),this}vec2f64(t,e){return this._appendField(t,h,e),this}vec3f(t,e){return this._appendField(t,s,e),this}vec3f64(t,e){return this._appendField(t,d,e),this}vec4f(t,e){return this._appendField(t,i,e),this}vec4f64(t,e){return this._appendField(t,u,e),this}mat3f(t,e){return this._appendField(t,r,e),this}mat3f64(t,e){return this._appendField(t,f,e),this}mat4f(t,e){return this._appendField(t,n,e),this}mat4f64(t,e){return this._appendField(t,l,e),this}vec4u8(t,e){return this._appendField(t,_,e),this}f32(e,s){return this._appendField(e,t,s),this}f64(t,e){return this._appendField(t,a,e),this}u8(t,e){return this._appendField(t,o,e),this}u16(t,e){return this._appendField(t,y,e),this}i8(t,e){return this._appendField(t,A,e),this}vec2i8(t,e){return this._appendField(t,T,e),this}vec2i16(t,e){return this._appendField(t,U,e),this}vec2u8(t,e){return this._appendField(t,p,e),this}vec4u16(t,e){return this._appendField(t,w,e),this}u32(t,e){return this._appendField(t,g,e),this}_appendField(t,e,s){if(this._fields.has(t))return void V(!1,`${t} already added to vertex buffer layout`);const i=e.ElementCount*I(e.ElementType),r=this._stride;this._stride+=i,this._fields.set(t,{size:i,constructor:e,offset:r,optional:s})}createBuffer(t){return new q(this,t)}createView(t){return new q(this,t)}clone(){const t=new D;return t._stride=this._stride,t._fields=new Map,this._fields.forEach(((e,s)=>t._fields.set(s,e))),t.BufferType=this.BufferType,t}get stride(){if(this._lastAligned!==this._fields.size){let t=1;this._fields.forEach((e=>t=Math.max(t,I(e.constructor.ElementType)))),this._stride=Math.floor((this._stride+t-1)/t)*t,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function G(){return new D}class H{constructor(t){this.fields=new Array,t.fields.forEach(((t,e)=>{const s={...t,constructor:P(t.constructor)};this.fields.push([e,s])})),this.stride=t.stride}}const J=[t,e,s,i,r,n,a,h,d,u,f,l,o,p,c,_,y,F,m,w,g,b,v,E,A,T,B,M,C,U,j,x,z,L,$,k];function P(t){return`${t.ElementType}_${t.ElementCount}`}const K=new Map;J.forEach((t=>K.set(P(t),t)));export{D as I,H as P,G as n};
