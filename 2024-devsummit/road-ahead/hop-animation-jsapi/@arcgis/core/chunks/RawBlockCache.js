/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import"../geometry.js";import{b as e,c as t,s as n}from"./rasterProjectionHelper.js";import r from"../geometry/Point.js";const l=new Map,o=new class{constructor(e=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const n=e+"/"+t,r=this._cachedBlocks;if(r.has(n)){const e=r.get(n);return e.refCount--,e.refCount<=0&&(r.delete(n),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const n=e+"/"+t,r=this._cachedBlocks;if(r.has(n)){const e=r.get(n);return e.ts=Date.now(),e.refCount++,r.delete(n),r.set(n,e),e.block}return null}putBlock(e,t,n,r){const l=this._cachedBlocks,o=e+"/"+t;if(l.has(o)){const e=l.get(o);e.ts=Date.now(),e.refCount++}else l.set(o,{block:n,ts:Date.now(),refCount:1,controller:r});this._trim(),this._updateTimer()}deleteBlock(e,t){const n=this._cachedBlocks,r=e+"/"+t;n.has(r)&&n.delete(r)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval((()=>{const t=Array.from(e),n=Date.now();for(let r=0;r<t.length&&t[r][1].ts<=n-this._duration;r++)e.delete(t[r][0]);0===e.size&&this._clearTimer()}),this._interval)}_trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let n=0;n<t.length-this._size;n++)e.delete(t[n][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function c(e,t){return null==t?e:`${e}?sliceId=${t}`}function s(e,t){const n={extent:null,rasterInfo:t,cache:new Map},r=l.get(e);return r?(r.push(n),r.length-1):(l.set(e,[n]),0)}function i(e,t){const n=l.get(e);n&&(n[t]=null,n.some((e=>null!=e))||l.delete(e))}function a(e,t,n){const r=l.get(e);if(!r)return null==t?o.decreaseRefCount(e,n):0;if(null==t||null==r[t])return o.decreaseRefCount(e,n);const c=r[t]?.cache,s=c?.get(n);if(c&&s){if(s.refCount--,0===s.refCount){c.delete(n);for(let e=0;e<r.length;e++)r[e]?.cache.delete(n);s.controller&&s.controller.abort()}return s.refCount}return 0}function u(e,t,n){const r=l.get(e);if(!r)return null==t?o.getBlock(e,n):null;if(null==t||null==r[t]){for(let e=0;e<r.length;e++){const t=r[e]?.cache.get(n);if(t)return t.refCount++,t.block}return o.getBlock(e,n)}const c=r[t]?.cache.get(n);if(c)return c.refCount++,c.block;for(let e=0;e<r.length;e++){if(e===t||!r[e])continue;const l=r[e]?.cache,o=l?.get(n);if(l&&o)return o.refCount++,l.set(n,o),o.block}return null}function h(e,t,n,r,c=null){const s=l.get(e);if(!s)return void(null==t&&o.putBlock(e,n,r,c));if(null==t||null==s[t])return void o.putBlock(e,n,r,c);const i={refCount:1,block:r,isResolved:!1,isRejected:!1,controller:c};r.then((()=>i.isResolved=!0)).catch((()=>i.isRejected=!0)),s[t]?.cache.set(n,i)}function f(e,t,n){const r=l.get(e);r?null!=t&&null!=r[t]?r[t]?.cache.delete(n):o.deleteBlock(e,n):null==t&&o.deleteBlock(e,n)}function m(o,c,s,i,a,u,h=null){const f=function(e,t){const n=l.get(e);return n?n[t]??null:null}(o,c);if(!f)return;const m=f.extent,{cache:d,rasterInfo:x}=f;if(m&&m.xmin===s.xmin&&m.xmax===s.xmax&&m.ymin===s.ymin&&m.ymax===s.ymax)return;i=i??0;const g=s.clone().normalize(),{spatialReference:_,transform:y}=x,k=new Set;for(let l=0;l<g.length;l++){const o=g[l];if(o.xmax-o.xmin<=i||o.ymax-o.ymin<=i)continue;let c=e(o,_,h);null!=y&&(c=y.inverseTransform(c));const s=new r({x:i,y:i,spatialReference:o.spatialReference});if(null==a&&!(a=t(s,_,o,h)))return;const{pyramidLevel:f,pyramidResolution:m,excessiveReading:d}=n(a,x,u||"closest");if(d)return;const{storageInfo:p}=x,{origin:B}=p,C={x:Math.max(0,Math.floor((c.xmin-B.x)/m.x)),y:Math.max(0,Math.floor((B.y-c.ymax)/m.y))},M=Math.ceil((c.xmax-c.xmin)/m.x-.1),R=Math.ceil((c.ymax-c.ymin)/m.y-.1),b=f>0?p.pyramidBlockWidth:p.blockWidth,v=f>0?p.pyramidBlockHeight:p.blockHeight,z=1,w=Math.max(0,Math.floor(C.x/b)-z),j=Math.max(0,Math.floor(C.y/v)-z),I=Math.floor((C.x+M-1)/b)+z,T=Math.floor((C.y+R-1)/v)+z;for(let e=j;e<=T;e++)for(let t=w;t<=I;t++)k.add(`${f}/${e}/${t}`)}d.forEach(((e,t)=>{if(!k.has(t)){const e=d.get(t);(null==e||e.isResolved||e.isRejected)&&d.delete(t)}})),f.extent={xmin:s.xmin,ymin:s.ymin,xmax:s.xmax,ymax:s.ymax}}export{u as a,a as b,i as c,f as d,c as g,h as p,s as r,m as u};
