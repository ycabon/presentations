/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Evented.js";import{s as r}from"./ensureType.js";import{c as s,f as a,d as i}from"./maybe.js";import{M as o,P as n}from"../core/scheduling.js";import{watch as d,syncAndInitial as c,on as l}from"../core/reactiveUtils.js";import h,{g as u,s as m}from"../core/Accessor.js";import{property as p}from"../core/accessorSupport/decorators/property.js";import{h as f,r as g,Q as _}from"../core/lang.js";import{L as y}from"./Logger.js";import{subclass as v}from"../core/accessorSupport/decorators/subclass.js";import{z as C,v as w,m as x,i as R,q as S,t as b,C as M,f as D,c as T}from"./mat4.js";import{l as O,n as E,b as A,c as I,p as P,o as F,y as N,g as H,s as L}from"./vec3.js";import{f as j,c as G}from"./vec3f64.js";import{V}from"./ViewingMode.js";import{d as z}from"./debugFlags2.js";import{c as W,C as U,h as B,D as k,w as q,o as Z}from"./aaBoundingRect.js";import{ColorFormat as Q,DepthFormat as Y}from"../views/3d/webgl/ManagedFBO.js";import{S as K,R as X,a as $,d as J,M as ee,j as te,U as re,b as se,g as ae,r as ie,ai as oe,aj as ne,ak as de,o as ce,P as le,l as he}from"./StencilUtils.js";import{c as ue,f as me}from"./vec4f64.js";import{k as pe,g as fe,h as ge,l as _e,P as ye,S as ve,j as Ce,I as we,A as xe}from"./IntegerPassUniform.js";import{g as Re,N as Se}from"./interfaces5.js";import{c as be,l as Me,a as De,n as Te}from"./mathUtils.js";import{h as Oe}from"./unitUtils.js";import{I as Ee,c as Ae}from"./mat4f64.js";import{d as Ie,h as Pe,a as Fe}from"./axisAngleDegrees.js";import{b as Ne,c as He}from"./weather.js";import{R as Le}from"./RenderState.js";import{B as je,a as Ge,b as Ve,S as ze}from"./RenderPlugin.js";import{B as We}from"./BindType.js";import{N as Ue}from"./NestedMap.js";import{S as Be,p as ke}from"./ShaderTechniqueConfiguration.js";import{C as qe}from"./Camera.js";import{a as Ze,l as Qe,v as Ye,b as Ke,s as Xe}from"./Util.js";import{p as $e}from"./projectBuffer.js";import{A as Je}from"./Attribute.js";import{C as et}from"./ContentObject.js";import{G as tt}from"./Geometry.js";import{R as rt,W as st,O as at,U as it}from"./RibbonLineMaterial.js";import{V as ot}from"./VertexAttribute.js";import{R as nt,D as dt}from"./Material.js";import{c as ct}from"./vec2f64.js";import{M as lt,H as ht,V as ut}from"./VertexArrayObject2.js";import{D as mt,R as pt}from"./basicInterfaces.js";import{T as ft,m as gt,i as _t,e as yt,s as vt}from"./OrderIndependentTransparency.js";import{c as Ct}from"./mat3f64.js";import{g as wt,b as xt,e as Rt,h as St,o as bt,s as Mt,d as Dt,q as Tt,n as Ot,j as Et}from"./vec2.js";import{s as At,t as It}from"./vec4.js";import{e as Pt,l as Ft,U as Nt,j as Ht,T as Lt}from"./enums.js";import{T as jt,a as Gt}from"./Texture.js";import{g as Vt,N as zt,b as Wt}from"./sphere.js";import{O as Ut}from"./Intersector.js";import{S as Bt,c as kt,I as qt}from"./Intersector2.js";import{g as Zt}from"./glUtil.js";import{N as Qt,R as Yt}from"./MemCache.js";import{B as Kt}from"./BufferObject.js";import{T as Xt,n as $t}from"./Scheduler.js";import{d as Jt}from"./mathUtils2.js";var er,tr,rr,sr,ar,ir,or,nr,dr,cr,lr,hr,ur,mr;!function(e){e[e.RasterImage=0]="RasterImage",e[e.Features=1]="Features"}(er||(er={})),function(e){e[e.MapLayer=0]="MapLayer",e[e.ViewLayer=1]="ViewLayer",e[e.Outline=2]="Outline",e[e.SnappingHint=3]="SnappingHint"}(tr||(tr={})),function(e){e[e.WithRasterImage=0]="WithRasterImage",e[e.WithoutRasterImage=1]="WithoutRasterImage"}(rr||(rr={})),function(e){e[e.ADD=0]="ADD",e[e.UPDATE=1]="UPDATE",e[e.REMOVE=2]="REMOVE"}(sr||(sr={})),function(e){e[e.NONE=0]="NONE",e[e.VISIBILITY=1]="VISIBILITY",e[e.GEOMETRY=2]="GEOMETRY",e[e.TRANSFORMATION=4]="TRANSFORMATION",e[e.HIGHLIGHT=8]="HIGHLIGHT",e[e.OCCLUDEE=16]="OCCLUDEE"}(ar||(ar={})),function(e){e[e.INNER=0]="INNER",e[e.OUTER=1]="OUTER"}(ir||(ir={})),function(e){e[e.REGULAR=0]="REGULAR",e[e.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",e[e.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",e[e.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}(or||(or={})),function(e){e[e.OFF=0]="OFF",e[e.ON=1]="ON"}(nr||(nr={})),function(e){e[e.FADING=0]="FADING",e[e.IMMEDIATE=1]="IMMEDIATE",e[e.UNFADED=2]="UNFADED"}(dr||(dr={}));class pr{constructor(e,t){this.vec3=e,this.id=t}}function fr(e,t,r,s){return new pr(j(e,t,r),s)}class gr{constructor(){this._extent=W(),this.resolution=0,this.renderLocalOrigin=fr(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new _r}get extent(){return this._extent}setupGeometryViewsCyclical(e){this.setupGeometryViewsDirect();const t=.001*e.range;if(this._extent[0]-t<=e.min){const t=this.canvasGeometries.extents[this.canvasGeometries.numViews++];U(this._extent,e.range,0,t)}if(this._extent[2]+t>=e.max){const t=this.canvasGeometries.extents[this.canvasGeometries.numViews++];U(this._extent,-e.range,0,t)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,B(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let e=0;e<this.canvasGeometries.numViews;e++){const t=this.canvasGeometries.extents[e];if(t[0]!==t[2]&&t[1]!==t[3])return!0}return!1}}class _r{constructor(){this.extents=[W(),W(),W()],this.numViews=0}}!function(e){e[e.Color=0]="Color",e[e.ColorNoRasterImage=1]="ColorNoRasterImage",e[e.Highlight=2]="Highlight",e[e.WaterNormal=3]="WaterNormal",e[e.Occluded=4]="Occluded",e[e.ObjectAndLayerIdColor=5]="ObjectAndLayerIdColor"}(cr||(cr={}));class yr{constructor(e,t,r){this._fbos=e,this._format=t,this._name=r}get valid(){return null!=this._handle?.getTexture()}dispose(){this._handle=s(this._handle)}get texture(){return this._handle?.getTexture()}bind(e,t,r){this._handle&&this._handle.fbo.width===t&&this._handle.fbo.height===r?e.bindFramebuffer(this._handle?.fbo):(this._handle?.release(),this._handle=this._fbos.acquire(t,r,this._name,this._format))}generateMipMap(){this._handle?.getTexture()?.descriptor?.hasMipmap&&this._handle?.getTexture()?.generateMipmap()}}class vr{constructor(e,t,r,s,a=Q.RGBA_MIPMAP){this.output=r,this.content=s,this.fbo=new yr(e,a,t)}get valid(){return this.fbo.valid}}class Cr{constructor(e){this.targets=[new vr(e,"overlay color",K.Color,cr.Color),new vr(e,"overlay IM color",K.Color,cr.ColorNoRasterImage),new vr(e,"overlay highlight",K.Highlight,cr.Highlight,Q.RGBA4),new vr(e,"overlay water",K.Normal,cr.WaterNormal),new vr(e,"overlay occluded",K.Color,cr.Occluded)],f("enable-feature:objectAndLayerId-rendering")&&this.targets.push(new vr(e,"overlay oid",K.ObjectAndLayerIdColor,cr.ObjectAndLayerIdColor))}getTexture(e){return this.targets[e]?.fbo.texture}dispose(){for(const e of this.targets)e.fbo.dispose()}computeValidity(){return this.targets.reduce(((e,t,r)=>t.valid?e|=1<<r:e),0)}}class wr extends pe{constructor(){super(...arguments),this.slicePlaneLocalOrigin=G(),this.origin=this.slicePlaneLocalOrigin,this.modelTransformation=null}}!function(e){e[e.Material=0]="Material",e[e.ShadowMap=1]="ShadowMap",e[e.Highlight=2]="Highlight"}(lr||(lr={}));class xr extends wr{constructor(){super(...arguments),this.identifier=lr.Material,this.output=K.Color,this.transparent=!1}}class Rr extends wr{constructor(){super(...arguments),this.identifier=lr.ShadowMap}}class Sr extends wr{constructor(){super(...arguments),this.identifier=lr.Highlight}}function br(e){e.fragment.code.add(Re`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function Mr(e){e.fragment.code.add(Re`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function Dr(e){e.fragment.code.add(Re`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}function Tr(e,t){const r=e.fragment;r.include(X),r.uniforms.add(new $("nearFar",((e,t)=>t.camera.nearFar))),r.uniforms.add(new J("depthMap",((e,t)=>t.linearDepth?.getTexture()))),r.uniforms.add(new ee("proj",((e,t)=>t.camera.projectionMatrix))),r.uniforms.add(new te("invResolutionHeight",((e,t)=>1/t.camera.height))),r.uniforms.add(new ee("reprojectionMatrix",((e,t)=>t.ssr.reprojectionMatrix))),r.code.add(Re`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${t.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P = clamp(P + dP, vec2(0.0), vec2(0.999));
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}function Or(e){return null!=e?.cubeMap}!function(e){e[e.RENDERING=0]="RENDERING",e[e.FADING=1]="FADING",e[e.FINISHED=2]="FINISHED"}(hr||(hr={})),function(e){e[e.RG=0]="RG",e[e.BA=1]="BA"}(ur||(ur={}));class Er{constructor(){this.readChannels=ur.RG,this.renderingStage=hr.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=G(),this.parallax=new Ar,this.parallaxNew=new Ar,this.pointOnGround=G(),this.fadeMode=mr.HIDE,this.fadeFactor=0,this.opacity=0}updateParallax(e){const t=this.parallax,r=O(e.eye);if(t.radiusCurvatureCorrectionFactor=.84*Math.sqrt(Math.max(r*r-Oe.radius*Oe.radius,0))/r,Pe(Ir,t.anchorPointClouds,Pr),C(t.transform,Ee,Pr[3],Fe(Pr)),this.fadeMode===mr.CROSS_FADE){const e=this.parallaxNew;Pe(Ir,e.anchorPointClouds,Pr),C(e.transform,Ee,Pr[3],Fe(Pr))}}updateFading(e,t,r,s){this.isFading&&this._advanceFading(r,s),this._evaluateFading(e,t,r)}_evaluateFading(e,t,r){const s=e.relativeElevation,a=this._calculateDistanceToAnchorPoint(e);var i;if((s>1.7*Ne||s<-Ne||a>jr)&&this.opacity>0)this._setFade(mr.HIDE,r);else if(!this.isFading)if((s>Ne||s<-.35*Ne||a>Lr)&&this.opacity>0)this._setFade(mr.FADE_OUT,r);else if(s<=Ne&&s>=-.35*Ne&&t===Le.IDLE&&null!=(i=this.data)&&!i.running){if(0===this.opacity)return void this._setFade(mr.FADE_IN,r);(a>Hr||this.renderingStage===hr.FADING)&&this._setFade(mr.CROSS_FADE,r)}}_advanceFading(e,t){this._switchReadChannels(),this._updateAnchorPoint(),this._advanceFadingFactorAndOpacity(e,t)}_advanceFadingFactorAndOpacity(e,t){if(this.fadeFactor<1)return this.fadeFactor=t?be((e-this.startTime)/(Nr*t),0,1):1,this.fadeMode===mr.FADE_OUT&&(this.opacity=1-this.fadeFactor),this.fadeMode===mr.FADE_IN&&(this.opacity=this.fadeFactor),void(this.fadeMode===mr.CROSS_FADE&&(this.opacity=1));this.fadeFactor=0,this.fadeMode===mr.FADE_OUT&&(this.opacity=0),this.fadeMode===mr.FADE_IN&&(this.opacity=1),this.fadeMode===mr.CROSS_FADE&&(this.opacity=1),this.fadeMode=mr.NONE}_switchReadChannels(){const e=this.fadeMode===mr.CROSS_FADE&&1===this.fadeFactor,t=this.fadeMode===mr.FADE_IN&&0===this.fadeFactor;this.renderingStage===hr.FADING&&(e||t)&&(this.readChannels=1-this.readChannels,this.renderingStage=hr.FINISHED)}_calculateDistanceToAnchorPoint(e){return E(this.pointOnGround,e.eye),A(this.pointOnGround,this.pointOnGround,Oe.radius),O(I(Fr,this.parallax.anchorPointClouds,this.pointOnGround))}_updateAnchorPoint(){this.fadeMode===mr.CROSS_FADE&&(0===this.fadeFactor&&P(this.parallaxNew.anchorPointClouds,this.pointOnGround),1===this.fadeFactor&&P(this.parallax.anchorPointClouds,this.parallaxNew.anchorPointClouds)),this.fadeMode===mr.FADE_IN&&0===this.fadeFactor&&P(this.parallax.anchorPointClouds,this.pointOnGround)}_setFade(e,t){switch(e){case mr.HIDE:this.opacity=0;break;case mr.FADE_OUT:this.opacity=1;break;case mr.FADE_IN:this.opacity=0;break;case mr.CROSS_FADE:this.opacity=1}this.fadeMode=e,this.fadeFactor=0,this.startTime=t}get isFading(){return this.fadeMode===mr.FADE_OUT||this.fadeMode===mr.FADE_IN||this.fadeMode===mr.CROSS_FADE}}!function(e){e[e.NONE=0]="NONE",e[e.HIDE=1]="HIDE",e[e.FADE_OUT=2]="FADE_OUT",e[e.FADE_IN=3]="FADE_IN",e[e.CROSS_FADE=4]="CROSS_FADE"}(mr||(mr={}));class Ar{constructor(){this.anchorPointClouds=G(),this.radiusCurvatureCorrectionFactor=0,this.transform=Ae()}}const Ir=j(0,0,1),Pr=Ie(),Fr=G(),Nr=1.25,Hr=34e3,Lr=64e3,jr=2e5;class Gr extends re{constructor(e,t){super(e,"samplerCube",We.Pass,((r,s,a)=>r.bindTexture(e,t(s,a))))}}function Vr(e){const t=e.fragment;t.uniforms.add(new ee("rotationMatrixClouds",((e,t)=>t.cloudsFade.parallax.transform)),new ee("rotationMatrixCloudsCrossFade",((e,t)=>t.cloudsFade.parallaxNew.transform)),new se("anchorPosition",((e,t)=>t.cloudsFade.parallax.anchorPointClouds)),new se("anchorPositionCrossFade",((e,t)=>t.cloudsFade.parallaxNew.anchorPointClouds)),new te("cloudsHeight",(()=>He)),new te("radiusCurvatureCorrectionFactor",((e,t)=>t.cloudsFade.parallax.radiusCurvatureCorrectionFactor)),new te("totalFadeInOut",((e,t)=>1-t.cloudsFade.opacity)),new te("crossFadeAnchorFactor",((e,t)=>be(t.cloudsFade.fadeFactor,0,1))),new Gr("cubeMap",((e,t)=>t.cloudsFade.data?.cubeMap?.colorTexture??null)),new je("crossFade",((e,t)=>t.cloudsFade.fadeMode===mr.CROSS_FADE)),new je("readChannelsRG",((e,t)=>t.cloudsFade.readChannels===ur.RG)),new je("fadeTextureChannels",((e,t)=>t.cloudsFade.renderingStage===hr.FADING))),t.constants.add("planetRadius","float",Oe.radius),t.code.add(Re`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),t.code.add(Re`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),t.code.add(Re`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),fe(t),ge(t),t.code.add(Re`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),t.code.add(Re`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = texture(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),t.code.add(Re`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),t.code.add(Re`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),t.code.add(Re`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}function zr(e,t){e.include(_e,t),e.include(Dr),e.include(Mr),t.hasCloudsReflections&&e.include(Vr,t),t.hasScreenSpaceReflections&&e.include(Tr,t);const r=e.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(Re`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add(new te("lightingSpecularStrength",((e,t)=>t.lighting.mainLight.specularStrength)),new te("lightingEnvironmentStrength",((e,t)=>t.lighting.mainLight.environmentStrength))),r.code.add(Re`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),t.hasCloudsReflections&&r.code.add(Re`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),t.hasScreenSpaceReflections?(r.uniforms.add(new ee("view",((e,t)=>t.camera.viewMatrix)),new J("lastFrameColorTexture",((e,t)=>t.ssr.lastFrameColor?.getTexture())),new te("fadeFactorSSR",((e,t)=>t.ssr.fadeFactor))),r.code.add(Re`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *
reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +
reflSea * seaColorMod + specular + foam);`)):r.code.add(Re`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),t.hasCloudsReflections?t.hasScreenSpaceReflections?r.code.add(Re`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(Re`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(Re`return waterRenderedColor;
}`)}class Wr extends re{constructor(e,t){super(e,"vec4",We.Draw,((r,s,a)=>r.setUniform4fv(e,t(s,a))))}}var Ur;function Br(e,t){const{vertex:r,fragment:s}=e;r.uniforms.add(new Wr("overlayTexOffset",((e,t)=>function(e,t){const r=t.overlay?.overlays[ir.INNER]?.extent;k(r)&&(Yr[0]=e.toMapSpace[0]/q(r)-r[0]/q(r),Yr[1]=e.toMapSpace[1]/Z(r)-r[1]/Z(r));const s=t.overlay?.overlays[ir.OUTER]?.extent;return k(s)&&(Yr[2]=e.toMapSpace[0]/q(s)-s[0]/q(s),Yr[3]=e.toMapSpace[1]/Z(s)-s[1]/Z(s)),Yr}(e,t))),new Wr("overlayTexScale",((e,t)=>function(e,t){const r=t.overlay?.overlays[ir.INNER]?.extent;k(r)&&(Yr[0]=e.toMapSpace[2]/q(r),Yr[1]=e.toMapSpace[3]/Z(r));const s=t.overlay?.overlays[ir.OUTER]?.extent;return k(s)&&(Yr[2]=e.toMapSpace[2]/q(s),Yr[3]=e.toMapSpace[3]/Z(s)),Yr}(e,t)))),s.constants.add("overlayOpacity","float",1),s.uniforms.add(new J("ovColorTex",((e,t)=>Qr(e,t)))),Zr(e,t)}function kr(e,t){const{vertex:r,fragment:s}=e;r.uniforms.add(new qr("overlayTexOffset"),new qr("overlayTexScale")),s.uniforms.add(new te("overlayOpacity",(e=>e.overlayOpacity)),new J("ovColorTex",((e,t)=>t.overlay?.getTexture(e.overlayContent)))),Zr(e,t)}!function(e){e[e.Disabled=0]="Disabled",e[e.Enabled=1]="Enabled",e[e.EnabledWithWater=2]="EnabledWithWater",e[e.COUNT=3]="COUNT"}(Ur||(Ur={}));class qr extends re{constructor(e){super(e,"vec4")}}function Zr(e,t){t.pbrMode!==ye.Water&&t.pbrMode!==ye.WaterOnIntegratedMesh&&t.pbrMode!==ye.TerrainWithWater||e.include(zr,t);const{vertex:r,fragment:s}=e;e.varyings.add("vtcOverlay","vec4"),r.code.add(Re`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`),s.code.add(Re`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),s.code.add(Re`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`),s.code.add(Re`vec4 getOverlayColorTexel(vec4 texCoords) {
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec4 color0 = texelFetch(ovColorTex, ivec2(vec2(texCoords.x * 0.5, texCoords.y) * texDim), 0);
vec4 color1 = texelFetch(ovColorTex, ivec2(vec2(texCoords.z * 0.5 + 0.5, texCoords.w) * texDim), 0);
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),t.pbrMode!==ye.Water&&t.pbrMode!==ye.WaterOnIntegratedMesh&&t.pbrMode!==ye.TerrainWithWater||(fe(s),ge(s),s.code.add(Re`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position, vec3 positionWorld) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, mainLightDirection, colorInput.rgb, mainLightIntensity, localUp, 1.0 - shadow, maskInput.w, position, positionWorld);
return vec4(final, colorInput.w);
}`))}function Qr(e,t){return e.identifier===lr.Material&&e.output===K.Color?t.overlay?.getTexture(cr.ColorNoRasterImage):e.identifier===lr.Material&&e.output===K.ObjectAndLayerIdColor?t.overlay?.getTexture(cr.ObjectAndLayerIdColor):e.identifier===lr.Highlight?t.overlay?.getTexture(cr.Highlight):null}const Yr=ue();class Kr extends Se{constructor(){super(...arguments),this.color=j(1,1,1)}}const Xr=Object.freeze(Object.defineProperty({__proto__:null,TextureOnlyPassParameters:Kr,build:function(){const e=new ae;return e.include(Ge),e.fragment.uniforms.add(new J("tex",(e=>e.texture)),new se("uColor",(e=>e.color))),e.fragment.code.add(Re`void main() {
vec4 texColor = texture(tex, uv);
fragColor = texColor * vec4(uColor, 1.0);
}`),e}},Symbol.toStringTag,{value:"Module"}));class $r{constructor(e){this._context=e,this._perConstructorInstances=new Ue,this._frameCounter=0,this._keepAliveFrameCount=es}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach((e=>e.forEach((e=>e.technique.destroy())))),this._perConstructorInstances.clear()}acquire(e,t=ts){const r=t.key;let s=this._perConstructorInstances.get(e,r);if(null==s){const a=new e(this._context,t,(()=>this.release(a)));s=new Jr(a),this._perConstructorInstances.set(e,r,s)}return++s.refCount,s.technique}releaseAndAcquire(e,t,r){if(null!=r){if(t.key===r.key)return r;this.release(r)}return this.acquire(e,t)}release(e){if(null==e||this._perConstructorInstances.empty)return;const t=this._perConstructorInstances.get(e.constructor,e.key);null!=t&&(--t.refCount,0===t.refCount&&(t.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==es&&this._perConstructorInstances.forEach(((e,t)=>{e.forEach(((e,r)=>{0===e.refCount&&e.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(e.technique.destroy(),this._perConstructorInstances.delete(t,r))}))}))}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach(((t,r)=>{e.push((async(e,t)=>{const r=t.shader;r&&(await r.reload(),e.forEach((e=>e.technique.reload(this._context))))})(t,r))})),await Promise.all(e)}}class Jr{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}}const es=-1,ts=new Be;class rs{constructor(e,t,r,s){this._textureRepository=e,this._techniqueRepository=t,this.materialChanged=r,this.requestRender=s,this._id2glMaterialRef=new Ue}dispose(){this._textureRepository.destroy()}acquire(e,t,r){this._ownMaterial(e);const s=e.produces.get(t);if(!s||!s(r))return null;let a=this._id2glMaterialRef.get(r,e.id);if(null==a){const t=e.createGLMaterial({material:e,techniqueRep:this._techniqueRepository,textureRepository:this._textureRepository,output:r});a=new ss(t),this._id2glMaterialRef.set(r,e.id,a)}return a.ref(),a.glMaterial}release(e,t){const r=this._id2glMaterialRef.get(t,e.id);null!=r&&(r.unref(),r.referenced||(a(r.glMaterial),this._id2glMaterialRef.delete(t,e.id)))}_ownMaterial(e){e.repository&&e.repository!==this&&y.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),e.repository=this}}class ss{constructor(e){this.glMaterial=e,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,Ze(this._refCnt>=0)}get referenced(){return this._refCnt>0}}class as{constructor(e){this._originSR=e,this._rootOriginId="root/"+u(),this._origins=new Map,this._objects=new Map,this._gridSize=5e5}getOrigin(e){const t=this._origins.get(this._rootOriginId);if(null==t){const t=fr(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,t),t}const r=this._gridSize,s=Math.round(e[0]/r),a=Math.round(e[1]/r),i=Math.round(e[2]/r),o=`${s}/${a}/${i}`;let n=this._origins.get(o);const d=.5*r;if(I(is,e,t.vec3),is[0]=Math.abs(is[0]),is[1]=Math.abs(is[1]),is[2]=Math.abs(is[2]),is[0]<d&&is[1]<d&&is[2]<d){if(n){const t=Math.max(...is);if(I(is,e,n.vec3),is[0]=Math.abs(is[0]),is[1]=Math.abs(is[1]),is[2]=Math.abs(is[2]),Math.max(...is)<t)return n}return t}return n||(n=fr(s*r,a*r,i*r,o),this._origins.set(o,n)),n}_drawOriginBox(e,t=me(1,1,0,1)){const r=window.view,s=r._stage,a=t.toString();if(!this._objects.has(a)){this._material=new rt({width:2,color:t}),s.add(this._material);const e=new st(s,{pickable:!1}),r=new at({castShadow:!1});s.add(r),e.add(r),this._objects.set(a,r)}const i=this._objects.get(a),o=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],n=o.length,d=new Array(3*n),c=new Array,l=.5*this._gridSize;for(let t=0;t<n;t++)d[3*t]=e[0]+(1&o[t]?l:-l),d[3*t+1]=e[1]+(2&o[t]?l:-l),d[3*t+2]=e[2]+(4&o[t]?l:-l),t>0&&c.push(t-1,t);$e(d,this._originSR,0,d,r.renderSpatialReference,0,n);const h=new tt(this._material,[[ot.POSITION,new Je(d,c,3,!0)]],null,et.Line);s.add(h),i.addGeometry(h)}get test(){const e=this;return{set gridSize(t){e._gridSize=t}}}}const is=G();class os{constructor(e,t){this.shadowMap=e,this.slicePlane=t,this.slot=ie.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=ft.NONE,this.alignPixelEnabled=!1,this.decorations=mt.ON,this.overlayStretch=1,this._camera=new qe,this._inverseViewport=ct(),this.oldLighting=new ve,this.newLighting=new ve,this._fadedLighting=new ve,this._lighting=this.newLighting,this.ssr=new ns,this.multipassEnabled=!1,this.multipassTerrain=new oe,this.multipassGeometry=new lt,this.hudRenderStyle=ht.Occluded,this.cloudsFade=new Er}get camera(){return this._camera}set camera(e){this._camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(e){const{oldLighting:t,newLighting:r}=this;e>=1?this._lighting=r:(this._fadedLighting.lerpLighting(t,r,e),this._lighting=this._fadedLighting)}}class ns{constructor(){this.fadeFactor=1,this.reprojectionMatrix=Ae()}}class ds{constructor(e,t,r=null){this.rctx=e,this.sliceHelper=r,this.lastFrameCamera=new qe,this.output=K.Color,this.renderOccludedMask=ls,this.bindParameters=new os(t,null!=r?r.plane:null),this.bindParameters.alignPixelEnabled=!0}}class cs extends ds{constructor(e,t,r,s){super(e,r,s),this.offscreenRenderingHelper=t,this.sliceHelper=s,this.time=o(0)}}const ls=nt.Occlude|nt.OccludeAndTransparent|nt.OccludeAndTransparentStencil;let hs=class extends qe{constructor(){super(...arguments),this._projectionMatrix=Ae()}get projectionMatrix(){return this._projectionMatrix}};var us;e([p()],hs.prototype,"_projectionMatrix",void 0),e([p({readOnly:!0})],hs.prototype,"projectionMatrix",null),hs=e([v("esri.views.3d.webgl-engine.lib.CascadeCamera")],hs),function(e){e[e.Highlight=0]="Highlight",e[e.ExcludeHighlight=1]="ExcludeHighlight"}(us||(us={}));class ms{constructor(){this.camera=new hs,this.lightMat=Ae()}}class ps{constructor(){this.maxNumCascadesHighQuality=4,this.maxNumCascadesLowQuality=4,this.textureSizeModHighQuality=1.3,this.textureSizeModLowQuality=.9,this.splitSchemeLambda=0}}class fs{constructor(e,t){this._fbos=e,this._viewingMode=t,this._enabled=!1,this._snapshots=new Array,this._textureHeight=0,this._numCascades=1,this.settings=new ps,this._projectionView=Ae(),this._projectionViewInverse=Ae(),this._modelViewLight=Ae(),this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=ue(),this._cascades=[new ms,new ms,new ms,new ms],this._lastOrigin=null,this._maxTextureWidth=Math.min(f("esri-mobile")?4096:16384,e.rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}get depthTexture(){return this._handle?.getTexture()}get _textureWidth(){return this._textureHeight*this._numCascades}get numCascades(){return this._numCascades}get cascadeDistances(){return At(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}disposeOffscreenBuffers(){this._handle=s(this._handle),this._discardSnapshots()}set maxCascades(e){this.settings.maxNumCascadesHighQuality=be(Math.floor(e),1,4)}get maxCascades(){return this.settings.maxNumCascadesHighQuality}set enabled(e){this._enabled=e,e||this.disposeOffscreenBuffers()}get enabled(){return this._enabled}get ready(){return this._enabled&&null!=this.depthTexture}get cascades(){for(let e=0;e<this._numCascades;++e)bs[e]=this._cascades[e];return bs.length=this._numCascades,bs}start(e,t,r,s,a){Ze(this.enabled);const{near:i,far:o}=this._clampNearFar(r);this._computeCascadeDistances(i,o,s),this._textureHeight=this._computeTextureHeight(e,a,s),this._setupMatrices(e,t);const{viewMatrix:n,projectionMatrix:d}=e;for(let e=0;e<this._numCascades;++e)this._constructCascade(e,d,n,t);this._lastOrigin=null,this.clear()}finish(){Ze(this.enabled),this._handle?.detachDepth()}getShadowMapMatrices(e){if(!this._lastOrigin||!F(e,this._lastOrigin)){this._lastOrigin=this._lastOrigin||G(),P(this._lastOrigin,e);for(let t=0;t<this._numCascades;++t){w(Ms,this._cascades[t].lightMat,e);for(let e=0;e<16;++e)Ds[16*t+e]=Ms[e]}}return Ds}moveSnapshot(e){Ze(this.enabled),this._handle?.detachDepth(),this._snapshots[e]?.release(),this._snapshots[e]=this._handle,this._handle=null,this.clear()}copySnapshot(e){const t=this._handle?.getTexture()?.descriptor;if(!this.enabled||!t)return;this._snapshots[e]?.release();const{width:r,height:s}=t,a=e===us.Highlight?"shadow highlight snapshot":"shadow no highlight snapshot";this._snapshots[e]=this._fbos.acquire(r,s,a,Q.RGBA4);const i=this._fbos.rctx;this._bindFbo();const o=i.bindTexture(this._snapshots[e]?.getTexture(),jt.TEXTURE_UNIT_FOR_UPDATES);i.gl.copyTexSubImage2D(Pt.TEXTURE_2D,0,0,0,0,0,r,s),i.bindTexture(o,jt.TEXTURE_UNIT_FOR_UPDATES)}getSnapshot(e){return this.enabled?this._snapshots[e]?.getTexture():null}clear(){const e=this._fbos.rctx;this._ensureFbo(),this._bindFbo(),e.setClearColor(1,1,1,1),e.clearSafe(Ft.COLOR_BUFFER_BIT|Ft.DEPTH_BUFFER_BIT)}_computeTextureHeight(e,t,r){const s=Math.min(window.devicePixelRatio,t)/e.pixelRatio,a=r?this.settings.textureSizeModHighQuality:this.settings.textureSizeModLowQuality,i=ne(Math.floor(Math.max(e.fullWidth,e.fullHeight)*s*a)),o=Math.min(this._maxTextureWidth,this._numCascades*i);return de(o/this._numCascades)}_ensureFbo(){this._handle?.fbo.width===this._textureWidth&&this._handle?.fbo.height===this._textureHeight||(this._handle?.release(),this._handle=this._fbos.acquire(this._textureWidth,this._textureHeight,"shadow map",Q.RGBA4)),this._handle?.acquireDepth(Y.DEPTH16_BUFFER)}_discardSnapshot(e){this._snapshots[e]=s(this._snapshots[e])}_discardSnapshots(){for(let e=0;e<this._snapshots.length;++e)this._discardSnapshot(e);this._snapshots.length=0}_bindFbo(){const e=this._fbos.rctx;e.unbindTexture(this.depthTexture),e.bindFramebuffer(this._handle?.fbo)}_constructCascade(e,t,r,s){const a=this._cascades[e],i=-this._cascadeDistances[e],o=-this._cascadeDistances[e+1],n=(t[10]*i+t[14])/Math.abs(t[11]*i+t[15]),d=(t[10]*o+t[14])/Math.abs(t[11]*o+t[15]);Ze(n<d);for(let e=0;e<8;++e){At(_s,e%4==0||e%4==3?-1:1,e%4==0||e%4==1?-1:1,e<4?n:d,1);const t=ys[e];It(t,_s,this._projectionViewInverse),t[0]/=t[3],t[1]/=t[3],t[2]/=t[3]}N(Ss,ys[0]),a.camera.viewMatrix=w(gs,this._modelViewLight,Ss);for(let e=0;e<8;++e)H(ys[e],ys[e],a.camera.viewMatrix);let c=ys[0][2],l=ys[0][2];for(let e=1;e<8;++e)c=Math.min(c,ys[e][2]),l=Math.max(l,ys[e][2]);c-=200,l+=200,a.camera.near=-l,a.camera.far=-c,function(e,t,r,s,a){const i=1/ys[0][3],o=1/ys[4][3];Ze(i<o);let n=i+Math.sqrt(i*o);const d=Math.sin(De(e[2]*t[0]+e[6]*t[1]+e[10]*t[2]));n/=d,function(e,t,r,s,a,i,o,n){wt(Ts,0,0);for(let t=0;t<4;++t)xt(Ts,Ts,e[t]);Rt(Ts,Ts,.25),wt(Os,0,0);for(let t=4;t<8;++t)xt(Os,Os,e[t]);Rt(Os,Os,.25),St(Es[0],e[4],e[5],.5),St(Es[1],e[5],e[6],.5),St(Es[2],e[6],e[7],.5),St(Es[3],e[7],e[4],.5);let d=0,c=bt(Es[0],Ts);for(let e=1;e<4;++e){const t=bt(Es[e],Ts);t<c&&(c=t,d=e)}Mt(As,Es[d],e[d+4]);const l=As[0];let h,u;As[0]=-As[1],As[1]=l,Mt(Is,Os,Ts),Dt(Is,As)<0&&Tt(As,As),St(As,As,Is,r),Ot(As,As),h=u=Dt(Mt(Ps,e[0],Ts),As);for(let t=1;t<8;++t){const r=Dt(Mt(Ps,e[t],Ts),As);r<h?h=r:r>u&&(u=r)}Et(s,Ts),Rt(Ps,As,h-t),xt(s,s,Ps);let m=-1,p=1,f=0,g=0;for(let t=0;t<8;++t){Mt(Fs,e[t],s),Ot(Fs,Fs);const r=As[0]*Fs[1]-As[1]*Fs[0];r>0?r>m&&(m=r,f=t):r<p&&(p=r,g=t)}Ye(m>0,"leftArea"),Ye(p<0,"rightArea"),Rt(Ns,As,h),xt(Ns,Ns,Ts),Rt(Hs,As,u),xt(Hs,Hs,Ts),Ls[0]=-As[1],Ls[1]=As[0];const _=Ke(s,e[g],Hs,xt(Ps,Hs,Ls),1,a),y=Ke(s,e[f],Hs,Ps,1,i),v=Ke(s,e[f],Ns,xt(Ps,Ns,Ls),1,o),C=Ke(s,e[g],Ns,Ps,1,n);Ye(_,"rayRay"),Ye(y,"rayRay"),Ye(v,"rayRay"),Ye(C,"rayRay")}(ys,n,d,vs,Cs,ws,xs,Rs),function(e,t,r,s,a){Mt(zs,r,s),Rt(zs,zs,.5),Ws[0]=zs[0],Ws[1]=zs[1],Ws[2]=0,Ws[3]=zs[1],Ws[4]=-zs[0],Ws[5]=0,Ws[6]=zs[0]*zs[0]+zs[1]*zs[1],Ws[7]=zs[0]*zs[1]-zs[1]*zs[0],Ws[8]=1,Ws[js(0,2)]=-Dt(Vs(Ws,0),e),Ws[js(1,2)]=-Dt(Vs(Ws,1),e);let i=Dt(Vs(Ws,0),r)+Ws[js(0,2)],o=Dt(Vs(Ws,1),r)+Ws[js(1,2)],n=Dt(Vs(Ws,0),s)+Ws[js(0,2)],d=Dt(Vs(Ws,1),s)+Ws[js(1,2)];i=-(i+n)/(o+d),Ws[js(0,0)]+=Ws[js(1,0)]*i,Ws[js(0,1)]+=Ws[js(1,1)]*i,Ws[js(0,2)]+=Ws[js(1,2)]*i,i=1/(Dt(Vs(Ws,0),r)+Ws[js(0,2)]),o=1/(Dt(Vs(Ws,1),r)+Ws[js(1,2)]),Ws[js(0,0)]*=i,Ws[js(0,1)]*=i,Ws[js(0,2)]*=i,Ws[js(1,0)]*=o,Ws[js(1,1)]*=o,Ws[js(1,2)]*=o,Ws[js(2,0)]=Ws[js(1,0)],Ws[js(2,1)]=Ws[js(1,1)],Ws[js(2,2)]=Ws[js(1,2)],Ws[js(1,2)]+=1,i=Dt(Vs(Ws,1),t)+Ws[js(1,2)],o=Dt(Vs(Ws,2),t)+Ws[js(2,2)],n=Dt(Vs(Ws,1),r)+Ws[js(1,2)],d=Dt(Vs(Ws,2),r)+Ws[js(2,2)],i=-.5*(i/o+n/d),Ws[js(1,0)]+=Ws[js(2,0)]*i,Ws[js(1,1)]+=Ws[js(2,1)]*i,Ws[js(1,2)]+=Ws[js(2,2)]*i,i=Dt(Vs(Ws,1),t)+Ws[js(1,2)],o=Dt(Vs(Ws,2),t)+Ws[js(2,2)],n=-o/i,Ws[js(1,0)]*=n,Ws[js(1,1)]*=n,Ws[js(1,2)]*=n,a[0]=Ws[0],a[1]=Ws[1],a[2]=0,a[3]=Ws[2],a[4]=Ws[3],a[5]=Ws[4],a[6]=0,a[7]=Ws[5],a[8]=0,a[9]=0,a[10]=1,a[11]=0,a[12]=Ws[6],a[13]=Ws[7],a[14]=0,a[15]=Ws[8]}(vs,Cs,xs,Rs,a.projectionMatrix),a.projectionMatrix[10]=2/(r-s),a.projectionMatrix[14]=-(r+s)/(r-s)}(r,s,c,l,a.camera),x(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const h=this._textureHeight;a.camera.viewport=[e*h,0,h,h]}_setupMatrices(e,t){x(this._projectionView,e.projectionMatrix,e.viewMatrix),R(this._projectionViewInverse,this._projectionView);const r=this._viewingMode===V.Global?e.eye:L(Ss,0,0,1);S(this._modelViewLight,[0,0,0],[-t[0],-t[1],-t[2]],r)}_clampNearFar(e){let{near:t,far:r}=e;return t<2&&(t=2),r<2&&(r=2),t>=r&&(t=2,r=4),{near:t,far:r}}_computeCascadeDistances(e,t,r){const s=r?this.settings.maxNumCascadesHighQuality:this.settings.maxNumCascadesLowQuality;this._numCascades=Math.min(1+Math.floor(Qe(t/e,4)),s);const a=(t-e)/this._numCascades,i=(t/e)**(1/this._numCascades);let o=e,n=e;for(let e=0;e<this._numCascades+1;++e)this._cascadeDistances[e]=Me(o,n,this.settings.splitSchemeLambda),o*=i,n+=a}get test(){return{cascades:this._cascades,textureHeight:this._textureHeight}}}const gs=Ae(),_s=ue(),ys=[];for(let e=0;e<8;++e)ys.push(ue());const vs=ct(),Cs=ct(),ws=ct(),xs=ct(),Rs=ct(),Ss=G(),bs=[],Ms=Ae(),Ds=Ee.concat(Ee,Ee,Ee,Ee),Ts=ct(),Os=ct(),Es=[ct(),ct(),ct(),ct()],As=ct(),Is=ct(),Ps=ct(),Fs=ct(),Ns=ct(),Hs=ct(),Ls=ct();function js(e,t){return 3*t+e}const Gs=ct();function Vs(e,t){return wt(Gs,e[t],e[t+3]),Gs}const zs=ct(),Ws=Ct();class Us{constructor(){this.adds=new n,this.removes=new n,this.updates=new n({allocator:e=>e||new Bs,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return 0===this.adds.length&&0===this.removes.length&&0===this.updates.length}}class Bs{}class ks{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}}var qs;function Zs(e){const t=new Map,r=e=>{let r=t.get(e);return r||(r=new ks,t.set(e,r)),r};return e.removes.forAll((e=>{Qs(e)&&r(e.material).removes.push(e)})),e.adds.forAll((e=>{Qs(e)&&r(e.material).adds.push(e)})),e.updates.forAll((e=>{Qs(e.renderGeometry)&&r(e.renderGeometry.material).updates.push(e)})),t}function Qs(e){return e.geometry.indexCount>=1}!function(e){e[e.Default=0]="Default",e[e.Screenshot=1]="Screenshot",e[e.ObjectAndLayerID=2]="ObjectAndLayerID"}(qs||(qs={}));class Ys{constructor(e,t){this._material=e,this._repository=t,this._map=new Map}dispose(){this._map.forEach(((e,t)=>{null!=e&&this._repository.release(this._material,t)}))}load(e,t,r){const s=this._material.produces.get(t);if(!s||!s(r))return null;this._map.has(r)||this._map.set(r,this._repository.acquire(this._material,t,r));const a=this._map.get(r);if(null!=a){if(a.ensureResources(e)===pt.LOADED)return a;this._repository.requestRender()}return null}}class Ks extends Ce{constructor(e=G()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}}class Xs{constructor(e=0,t=0){this.from=e,this.to=t}get numElements(){return this.to-this.from}}function $s(e){const t=new Map;e.forAll((e=>t.set(e.from,e)));let r=!0;for(;r;){r=!1;for(let s=0;s<e.length;++s){const a=e.data[s],i=t.get(a.to);if(!i)return;a.to=i.to,t.delete(i.from),e.removeUnordered(i),r=!0}}}class Js extends Xs{constructor(e,t,r){super(t,r),this.geometry=e}get isVisible(){return this.geometry.visible}get hasHighlights(){return null!=this.geometry.highlights&&this.isVisible}get hasOccludees(){return null!=this.geometry.occludees}}class ea{constructor(){this.first=0,this.count=0}}class ta{constructor(){this._numElements=0,this._instances=new Map,this.holes=new n({allocator:e=>e||new Xs,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=ra(),this.drawCommandsHighlight=ra(),this.drawCommandsOccludees=ra(),this.drawCommandsShadowHighlightRest=ra()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(e,t){this.deleteInstance(e),this._instances.set(e,t),this._numElements+=t.numElements}deleteInstance(e){const t=this._instances.get(e);t&&(this._numElements-=t.numElements,this._instances.delete(e))}updateInstance(e,t,r){const s=this._instances.get(e);s&&(this._numElements-=s.numElements,s.from=t,s.to=r,this._numElements+=s.numElements)}updateDrawState(e){e.isVisible?(e.hasHighlights&&(this.hasHighlights=!0),e.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(e){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,0===this._instances.size)return;if(!this.needsMultipleCommands()){const t=this.drawCommandsDefault.pushNew(),r=this.holes.front();return null!=this.vao&&1===this.holes.length&&r.to===Math.floor(this.vao.byteSize/e)?(t.first=0,void(t.count=r.from)):(t.first=1/0,t.count=0,this._instances.forEach((e=>{t.first=Math.min(t.first,e.from),t.count=Math.max(t.count,e.to)})),void(t.count-=t.first))}const t=Array.from(this._instances.values()).sort(((e,t)=>e.from===t.from?e.to-t.to:e.from-t.from));for(const e of t)e.isVisible&&(sa(e.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,e),sa(e.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,e))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}}function ra(){return new n({allocator:e=>e||new ea,deallocator:e=>e})}function sa(e,t){const r=e.back();if(null==r){const r=e.pushNew();return r.first=t.from,void(r.count=t.numElements)}if(a=t,(s=r).first+s.count>=a.from){const e=t.from-r.first+t.numElements;r.count=e}else{const r=e.pushNew();r.first=t.from,r.count=t.numElements}var s,a}class aa{constructor(e){this.origin=e,this.buffers=new Array}dispose(){this.buffers.forEach((e=>e.vao.dispose())),this.buffers.length=0}findBuffer(e){return this.buffers.find((t=>t.instances.has(e)))}}class ia{constructor(e,t){this._cache=e(t,((e,t,r)=>this._remove(e,t,r)))}hitrate(){return this._cache.hitRate}destroy(){this._cache.destroy()}clear(){this._cache.clear()}getSize(e){return this._cache.getSize(e)}pop(e){const t=this._cache.peek(e);if(!t)return;const r=t.pop();if(t.length>0){if(r){const s=this._cache.getSize(e)-Math.round(r.usedMemory);this._cache.updateSize(e,t,s)}}else this._cache.pop(e);return r}put(e,t,r=Qt){const s=this._cache.peek(e);if(!s)return void this._cache.put(e,[t],t.usedMemory,r);s.push(t);const a=this._cache.getSize(e)+Math.round(t.usedMemory);this._cache.updateSize(e,s,a)}_remove(e,t,r){switch(t){case Yt.ALL:return e.forEach((e=>e.dispose())),0;case Yt.SOME:{const t=e.shift();return t&&(r-=Math.round(t.usedMemory),t.dispose()),r}}}}class oa{constructor(e,t,r){this._rctx=e,this._locations=t,this._layout=r,this._cache=new ia(e.newCache,"VAOCache")}dispose(){this._cache.destroy()}newVao(e){const t=e.toString();let r=this._cache.pop(t);return r||(r=new ut(this._rctx,this._locations,{geometry:this._layout},{geometry:Kt.createVertex(this._rctx,Nt.STATIC_DRAW)}),r.vertexBuffers.geometry.setSize(e),r)}deleteVao(e){if(null==e)return;const t=e.byteSize.toString();this._cache.put(t,e)}}let na=class extends Ve{constructor(e){super(e),this._vaoCache=null,this._glMaterials=null,this._bufferWriter=null,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._produces=new Map,this.drapedPriority=0}destroy(){this._glMaterials=a(this._glMaterials),this._dataByOrigin.forEach((e=>e.dispose())),this._dataByOrigin.clear(),this._vaoCache=a(this._vaoCache)}initialize(){this.material.produces.forEach(((e,t)=>{this._produces.set(t,(t=>!(0===this._dataByOrigin.size||t===K.Highlight&&!this._hasHighlights)&&e(t)))}))}get produces(){return this._produces}initializeRenderContext(e,t){const{rctx:r}=e.renderContext;this._glMaterials=new Ys(this.material,t??e.materialRepository),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=new oa(r,this.material.vertexAttributeLocations,Zt(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get hasOccludees(){return this._hasOccludees}get isDecoration(){return this.material.parameters.isDecoration}queryRenderOccludedState(e){return this.material.queryRenderOccludedState(e)}get materialReference(){return this.material}get numGeometries(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.instances.size),0))),e}get usedMemory(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.vao.usedMemory),0))),e}forEachGeometry(e){this._dataByOrigin.forEach((t=>t.buffers.forEach((t=>t.instances.forEach((t=>e(t.geometry)))))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const t=this._bufferWriter;if(null===t)return;const r=t.vertexBufferLayout.stride/4;for(const s of e){const e=s.renderGeometry,a=this._dataByOrigin.get(e.localOrigin.id),i=a?.findBuffer(e.id);if(null==i)return;const o=i.instances.get(e.id);if(s.updateType&(ar.GEOMETRY|ar.TRANSFORMATION)){const s=Ca(t.elementCount(o.geometry.geometry)*r),a=t.vertexBufferLayout.createView(s.buffer);this._writeGeometry(e,a,0),i.vao.vertexBuffers.geometry.setSubData(s,o.from*r,0,o.numElements*r)}s.updateType&(ar.HIGHLIGHT|ar.OCCLUDEE|ar.VISIBILITY)&&(i.drawCommandsDirty=!0)}}_computeDeltas(e,t){const r=new Ue;for(const t of e){const e=t.localOrigin;if(null==e)continue;let s=r.get(e.id,null);null==s&&(s=new da(e.vec3),r.set(e.id,null,s)),s.changes.push(t)}for(const e of t){const t=e.localOrigin;if(null==t)continue;const s=this._dataByOrigin.get(t.id),a=s?.findBuffer(e.id);if(null==a)continue;let i=r.get(t.id,a);null==i&&(i=new da(t.vec3),r.set(t.id,a,i)),i.changes.push(e)}return r}_addAndRemoveGeometries(e,t){if(null===this._bufferWriter||null===this._vaoCache)return;const{_bufferWriter:r,_dataByOrigin:s}=this,a=r.vertexBufferLayout.stride/4,i=this._computeDeltas(e,t);i.forEach(((e,t)=>{const o=e.get(null),n=null!=o?o.changes:[];i.delete(t,null);let d=s.get(t);if(e.forEach(((e,o)=>{if(i.delete(t,o),null==o)return void Ze(!1,"No VAO for removed geometries");if(o.instances.size===e.changes.length)return this._vaoCache.deleteVao(o.vao),g(d.buffers,o),void(0===d.buffers.length&&0===n.length&&s.delete(t));const c=o.numElements,l=o.vao.byteSize/4,h=n.reduce(((e,t)=>e+r.elementCount(t.geometry)),0),u=e.changes.reduce(((e,t)=>e+r.elementCount(t.geometry)),0),m=Math.min((c+h-u)*a,ya),p=m>l;m>pa&&m<l/2?(e.changes.forEach((({id:e})=>o.deleteInstance(e))),o.instances.forEach((({geometry:e})=>n.push(e))),this._vaoCache.deleteVao(o.vao),g(d.buffers,o)):p?this._applyAndRebuild(o,n,e):this._applyRemoves(o,e)})),n.length>0)for(null==d&&(d=new aa(o.origin),s.set(t,d)),d.buffers.forEach((e=>this._applyAdds(e,n)));n.length>0;)d.buffers.push(this._applyAndRebuild(new ta,n,null))}))}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((e=>{e.buffers.forEach((e=>{e.drawCommandsDirty&&(e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,r(e.instances,(t=>(e.updateDrawState(t),e.hasHiddenInstances&&e.hasHighlights&&e.hasOccludees))),e.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||e.hasHighlights,this._hasOccludees=this._hasOccludees||e.hasOccludees}))}))}_applyAndRebuild(e,t,r){if(null!=r)for(const t of r.changes)e.deleteInstance(t.id);const s=this._bufferWriter,a=s.vertexBufferLayout.stride,i=a/4,o=Math.floor(ya/i);let n=e.numElements;for(;t.length>0;){const r=t.pop(),a=s.elementCount(r.geometry);if(n+a>o&&n>0){t.push(r);break}n+=a;const i=new Js(r,0,0);Ze(null==e.instances.get(r.id)),e.addInstance(r.id,i)}const d=n*i,c=Ca(d),l=s.vertexBufferLayout.createView(c.buffer);let h=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach(((t,r)=>{this._writeGeometry(t.geometry,l,h);const a=h;h+=s.elementCount(t.geometry.geometry),e.updateInstance(r,a,h),e.updateDrawState(t)})),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(wa(d)),e.vao.vertexBuffers.geometry.setSubData(c,0,0,h*i),e.holes.clear();const u=e.holes.pushNew();return u.from=h,u.to=Math.floor(e.vao.byteSize/a),e.updateDrawCommands(a),e}_applyRemoves(e,t){if(0===t.changes.length||null===this._bufferWriter)return;for(const r of t.changes){const t=r.id,s=e.instances.get(t);if(!s)continue;e.deleteInstance(t);const a=ma.back();if(a){if(a.to===s.from){a.to=s.to;continue}if(a.from===s.to){a.from=s.from;continue}}const i=ma.pushNew();i.from=s.from,i.to=s.to}$s(ma);const r=this._bufferWriter.vertexBufferLayout.stride/4,s=ma.reduce(((e,t)=>Math.max(e,t.numElements)),0)*r,a=Ca(s);a.fill(0,0,s);const i=e.vao.vertexBuffers.geometry;ma.forAll((e=>i.setSubData(a,e.from*r,0,e.numElements*r))),e.holes.pushArray(ma.data,ma.length),ma.forAll(((e,t)=>ma.data[t]=null)),ma.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t){if(0===t.length||null===this._bufferWriter)return;if(!function(e){return null!=e.vao}(e))return void this._applyAndRebuild(e,t,null);const r=this._bufferWriter,s=r.vertexBufferLayout.stride/4,a=e.numElements,i=t.reduce(((e,t)=>e+r.elementCount(t.geometry)),0),o=Math.min((a+i)*s,ya),n=4*o;if(e.vao.byteSize<wa(ya-pa)&&n>e.vao.byteSize)return void this._applyAndRebuild(e,t,null);$s(e.holes);const d=new Array;for(const s of t){const t=r.elementCount(s.geometry),a=ca(e.holes,t);d.push(a)}const c=e.vao.vertexBuffers.geometry;let l=0,h=0,u=0;const m=Ca(o),p=r.vertexBufferLayout.createView(m.buffer);t.forEach(((t,a)=>{const i=d[a];if(null==i)return;if(u!==i){const e=u-h;e>0&&c.setSubData(m,h*s,0,e*s),h=i,l=0}const o=r.elementCount(t.geometry);this._writeGeometry(t,p,l),l+=o,u=i+o;const n=new Js(t,i,i+o);Ze(null==e.instances.get(t.id)),e.addInstance(t.id,n),e.drawCommandsDirty=!0}));const f=u-h;f>0&&c.setSubData(m,h*s,0,f*s),_(t,((e,t)=>null==d[t]))}_writeGeometry(e,t,r){if(null===this._bufferWriter)return;const s=e.localOrigin.vec3;Xe(la,-s[0],-s[1],-s[2]);const a=x(ha,la,e.transformation);R(ua,a),b(ua,ua),this._bufferWriter.write(a,ua,e.geometry,t,r)}updateAnimation(e){return this.material.update(e)}prepareTechnique(e){if(!this.material.shouldRender(e))return null;const{output:t,bindParameters:r}=e,s=this.material.produces.get(r.slot);if(!s||!s(t))return null;const a=t===K.Highlight||t===K.ShadowHighlight;if(a&&!this._hasHighlights)return null;const i=t===K.ShadowExcludeHighlight,o=!(a||i);for(const s of this._dataByOrigin.values())for(const n of s.buffers){if(a&&!n.hasHighlights)continue;const s=(a?n.drawCommandsHighlight:i&&n.needsMultipleCommands()?n.drawCommandsShadowHighlightRest:n.drawCommandsDefault)||null,d=o&&n.drawCommandsOccludees||null;if(s?.length||d?.length){const s=this._glMaterials.load(e.rctx,r.slot,t),a=null!=s?s.beginSlot(r):null;if(null!=a)return a}}return null}renderNode(e,t){const{output:r,bindParameters:s}=e,a=r===K.Highlight||r===K.ShadowHighlight,i=r===K.ShadowExcludeHighlight,o=!(a||i),n=e.rctx,d=e.bindParameters.slot===ie.OCCLUDER_MATERIAL,c=e.bindParameters.slot===ie.TRANSPARENT_OCCLUDER_MATERIAL;n.runAppleAmdDriverHelper(),n.bindTechnique(t,s,this.material.parameters);for(const e of this._dataByOrigin.values())for(const r of e.buffers){if(a&&!r.hasHighlights)continue;const l=(a?r.drawCommandsHighlight:i&&r.needsMultipleCommands()?r.drawCommandsShadowHighlightRest:r.drawCommandsDefault)||null,h=o&&r.drawCommandsOccludees||null;(l?.length||h?.length)&&(t.program.bindDraw(new Ks(e.origin),s,this.material.parameters),t.ensureAttributeLocations(r.vao),n.bindVAO(r.vao),l?.length&&(n.setPipelineState(t.getPipeline(!1,d,c)),l.forAll((e=>n.drawArrays(t.primitiveType,e.first,e.count)))),h?.length&&(n.setPipelineState(t.getPipeline(!0,d,c)),h.forAll((e=>n.drawArrays(t.primitiveType,e.first,e.count)))))}}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}};e([p({constructOnly:!0})],na.prototype,"material",void 0),na=e([v("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],na);class da{constructor(e){this.origin=e,this.changes=new Array}}function ca(e,t){let r;if(!e.some((e=>!(e.numElements<t||(r=e,0)))))return null;const s=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),s}const la=Ae(),ha=Ae(),ua=Ae(),ma=new n({allocator:e=>e||new Xs,deallocator:null}),pa=65536,fa=4*pa,ga=1024,_a=16777216,ya=_a/4;let va=new Float32Array(pa);function Ca(e){return va.length<e&&(va=new Float32Array(e)),va}function wa(e){const t=4*e;return t<=ga?ga:t<fa?Te(t):Math.max(Math.min(Math.ceil(1.5*t/fa)*fa,_a),t)}let xa=class extends h{constructor(e){super(e),this._pending=new Ra,this._changes=new Us,this._materialRenderers=new n,this._sortedMaterialRenderers=new n,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forAll((e=>e.destroy())),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear(),this._pending.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccludedDraped(){return this._materialRenderers.some((e=>0!==e.numGeometries&&!e.queryRenderOccludedState(nt.Occlude)))}get isEmpty(){return!this.updating&&0===this._materialRenderers.length&&0===this._geometries.size}getMemoryForMaterial(e){if(null==e)return 0;const t=this._materialRenderers.find((t=>t.materialReference===e));return t?.usedMemory??0}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const e=Zs(this._changes);let t=!1;return e.forEach(((e,r)=>{let s=this._materialRenderers.find((e=>e.materialReference===r));if(!s&&e.adds.length>0){const e=new na({material:r});e.initializeRenderContext(this.rendererContext.pluginContext,this._materialRepository),s=e,this._materialRenderers.push(s),t=!0}s&&(s.modify(e),0===s.numGeometries&&(this._materialRenderers.removeUnordered(s),s.destroy(),t=!0))})),this._changes.clear(),t&&this._updateSortedMaterialRenderers(),this._hasHighlights=this._materialRenderers.some((e=>{const t=e.produces.get(ie.DRAPED_MATERIAL);return!!t&&t(K.Highlight)})),this._hasWater=this._materialRenderers.some((e=>{const t=e.produces.get(ie.DRAPED_WATER);return!!t&&t(K.Normal)})),this.notifyChange("updating"),!0}addGeometries(e,t){if(0===e.length)return;const r=this._validateRenderGeometries(e);for(const e of r)this._geometries.set(e.id,e);const s=this._pending.empty;for(const e of r)this._pending.adds.add(e);s&&this.notifyChange("updating"),t===sr.UPDATE&&this._notifyGraphicGeometryChanged(e)}removeGeometries(e,t){const r=this._pending.empty,s=this._pending.adds;for(const t of e)s.has(t)?(this._pending.removed.add(t),s.delete(t)):this._pending.removed.has(t)||this._pending.removes.add(t),this._geometries.delete(t.id);r&&!this._pending.empty&&this.notifyChange("updating"),t===sr.UPDATE&&this._notifyGraphicGeometryChanged(e)}modifyGeometries(e,t){const r=0===this._changes.updates.length;for(const r of e){const e=this._changes.updates.pushNew();e.renderGeometry=this._validateRenderGeometry(r),e.updateType=t}switch(r&&this._changes.updates.length>0&&this.notifyChange("updating"),t){case ar.TRANSFORMATION:case ar.GEOMETRY:return this._notifyGraphicGeometryChanged(e);case ar.VISIBILITY:return this._notifyGraphicVisibilityChanged(e)}}updateAnimation(e){let t=!1;return this._sortedMaterialRenderers.forAll((r=>t=!!r.updateAnimation&&r.updateAnimation(e)||t)),t}shouldRender(e){return this._sortedMaterialRenderers.some((t=>t.prepareTechnique(e)))}render(e){this._sortedMaterialRenderers.forAll((t=>{const r=t.prepareTechnique(e);null!=r&&t.renderNode(e,r)}))}intersect(e,t,r,s,a){return this._geometries.forEach((i=>{if(s&&!s(i))return;this._intersectRenderGeometry(i,r,t,0,e,a);const o=this.rendererContext.longitudeCyclical;o&&(i.boundingSphere[0]-i.boundingSphere[3]<o.min&&this._intersectRenderGeometry(i,r,t,o.range,e,a),i.boundingSphere[0]+i.boundingSphere[3]>o.max&&this._intersectRenderGeometry(i,r,t,-o.range,e,a)),a++})),a}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear(),this._materialRenderers.forAll(((e,t)=>{e.drapedPriority=t,this._sortedMaterialRenderers.push(e)})),this._sortedMaterialRenderers.sort(((e,t)=>t.materialReference?.renderPriority===e.materialReference?.renderPriority?e.drapedPriority-t.drapedPriority:(t.materialReference?.renderPriority||0)-(e.materialReference?.renderPriority||0)))}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let e=0;e<this._changes.updates.length;){const t=this._changes.updates.data[e];this._pending.has(t.renderGeometry)?this._changes.updates.removeUnorderedIndex(e):e++}this._pending.clear()}_intersectRenderGeometry(e,t,r,s,a,i){if(!e.visible)return;let o=0;s+=e.transformation[12],o=e.transformation[13],Sa[0]=r[0]-s,Sa[1]=r[1]-o,e.screenToWorldRatio=this.rendererContext.screenToWorldRatio,e.material.intersectDraped(e,null,a,Sa,((r,s,o)=>{!function(e,t,r,s,a,i,o){const n=new Ut(i,o,t),d=t=>{t.set(qt.OVERLAY,n,e.dist,e.normal,e.transformation,r,s)};if((null==a.results.min.drapedLayerOrder||r>=a.results.min.drapedLayerOrder)&&(null==a.results.min.dist||a.results.ground.dist<=a.results.min.dist)&&d(a.results.min),a.options.store!==Bt.MIN&&(null==a.results.max.drapedLayerOrder||r<a.results.max.drapedLayerOrder)&&(null==a.results.max.dist||a.results.ground.dist>a.results.max.dist)&&d(a.results.max),a.options.store===Bt.ALL){const e=kt(a.ray);d(e),a.results.all.push(e)}}(t,o,i,e.material.renderPriority,a,e.layerUid,e.graphicUid)}),t)}_notifyGraphicGeometryChanged(e){if(null==this.drapeSource.notifyGraphicGeometryChanged)return;let t;for(const r of e){const e=r.graphicUid;null!=e&&e!==t&&(this.drapeSource.notifyGraphicGeometryChanged(e),t=e)}}_notifyGraphicVisibilityChanged(e){if(null==this.drapeSource.notifyGraphicVisibilityChanged)return;let t;for(const r of e){const e=r.graphicUid;null!=e&&e!==t&&(this.drapeSource.notifyGraphicVisibilityChanged(e),t=e)}}_validateRenderGeometries(e){for(const t of e)this._validateRenderGeometry(t);return e}_validateRenderGeometry(e){return null==e.localOrigin&&(e.localOrigin=this._localOriginFactory.getOrigin(Vt(e.boundingSphere))),e}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};e([p()],xa.prototype,"drapeSource",void 0),e([p()],xa.prototype,"updating",null),e([p()],xa.prototype,"rctx",null),e([p({constructOnly:!0})],xa.prototype,"rendererContext",void 0),e([p()],xa.prototype,"_materialRepository",null),e([p()],xa.prototype,"_localOriginFactory",null),e([p({readOnly:!0})],xa.prototype,"isEmpty",null),e([p()],xa.prototype,"_materialRenderers",void 0),e([p()],xa.prototype,"_geometries",void 0),xa=e([v("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],xa);class Ra{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return 0===this.adds.size&&0===this.removes.size&&0===this.removed.size}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}const Sa=ct();class ba extends ce{initializeProgram(e){return new le(e.rctx,ba.shader.get().build(),dt)}initializePipeline(){return this.configuration.hasAlpha?gt({blending:_t(Ht.SRC_ALPHA,Ht.ONE,Ht.ONE_MINUS_SRC_ALPHA,Ht.ONE_MINUS_SRC_ALPHA),colorWrite:yt}):gt({colorWrite:yt})}}ba.shader=new he(Xr,(()=>Promise.resolve().then((()=>Xr))));class Ma extends Be{constructor(){super(...arguments),this.hasAlpha=!1}}e([ke()],Ma.prototype,"hasAlpha",void 0);class Da extends Se{constructor(){super(...arguments),this.overlayIndex=ir.INNER,this.opacity=1}}const Ta=Object.freeze(Object.defineProperty({__proto__:null,OverlayCompositingPassParameters:Da,build:function(){const e=new ae;return e.include(Ge),e.fragment.uniforms.add(new J("tex",(e=>e.texture))),e.fragment.uniforms.add(new we("overlayIdx",(e=>e.overlayIndex))),e.fragment.uniforms.add(new te("opacity",(e=>e.opacity))),e.fragment.code.add(Re`void main() {
vec2 overlayUV = overlayIdx == 0 ? vec2(uv.x * 0.5, uv.y) : vec2(uv.x * 0.5 + 0.5, uv.y);
fragColor = texture(tex, overlayUV) * opacity;
}`),e}},Symbol.toStringTag,{value:"Module"}));class Oa extends ce{initializeProgram(e){return new le(e.rctx,Oa.shader.get().build(),dt)}initializePipeline(){return gt({blending:vt(Ht.ONE,Ht.ONE_MINUS_SRC_ALPHA),colorWrite:yt})}}Oa.shader=new he(Ta,(()=>Promise.resolve().then((()=>Ta))));let Ea=class extends ze{constructor(e){super(e),this._overlays=null,this._renderTargets=null,this._overlayParameters=new Da,this.hasHighlights=!1,this._hasWater=!1,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new n,this._passParameters=new Kr,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this.unloadedMemory=0,this.ignoresMemoryFactor=!1,this._camera=new qe,this.worldToPCSRatio=1,this.events=new t,this.longitudeCyclical=null,this.produces=new Map([[ie.DRAPED_MATERIAL,e=>e!==K.Highlight||this.hasHighlights],[ie.DRAPED_WATER,()=>this._hasWater]]),this._hasTargetWithoutRasterImage=!1,this._hasDrapedFeatureSource=!1,this._hasDrapedRasterSource=!1}initialize(){const e=this.view._stage.renderer.fboCache,t=this.view._stage.renderView,{waterTextures:r,stippleTextures:s,markerTextures:a}=t;this._shaderTechniques=new $r({rctx:this._rctx,viewingMode:V.Local,stippleTextureRepository:s,markerTextureRepository:a,waterTextureRepository:r}),this._renderContext=new ds(this._rctx,new fs(e,this.view.state.viewingMode),null),this.addHandles([d((()=>r.updating),(()=>this.events.emit("content-changed")),c),d((()=>this.spatialReference),(e=>this._localOriginFactory=new as(e)),c),l((()=>this.view.allLayerViews),"after-changes",(()=>this._sortedDrapeSourceRenderersDirty=!0))]),this._materialRepository=new rs(t.textureRepository,this._shaderTechniques,(()=>{this.notifyChange("rendersOccludedDraped"),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")}),(()=>this.events.emit("content-changed"))),this._bindParameters.slot=ie.DRAPED_MATERIAL,this._bindParameters.mainDepth=null,this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=ft.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new xe(j(1,1,1))]),this.addHandles(this.view.resourceController.scheduler.registerTask(Xt.STAGE,this))}destroy(){this._renderers.forEach((e=>e.destroy())),this._renderers.clear(),this._debugTextureTechnique=s(this._debugTextureTechnique),this._passParameters.texture=a(this._passParameters.texture),this._shaderTechniques=i(this._shaderTechniques),this.disposeOverlays()}get _bindParameters(){return this._renderContext.bindParameters}get _rctx(){return this.view._stage.renderView.renderingContext}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}initializeRenderContext(e){this.pluginContext=e}uninitializeRenderContext(){}renderNode(){}get updating(){return this._sortedDrapeSourceRenderersDirty||r(this._renderers,(e=>e.updating))}get hasOverlays(){return null!=this._overlays&&null!=this._renderTargets}getMemoryForMaterial(e){return Array.from(this._renderers.values()).reduce(((t,r)=>t+r.getMemoryForMaterial(e)),0)}get layers(){return this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers(),this._sortedRenderers.map((e=>e.drapeSource.layer)).filter((e=>!!e))}createGeometryDrapeSourceRenderer(e){return this.createDrapeSourceRenderer(e,xa)}createDrapeSourceRenderer(e,t,r){const s=this._renderers.get(e);null!=s&&s.destroy();const a=new t({...r,rendererContext:this,drapeSource:e});return this._renderers.set(e,a),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in e&&this.addHandles(d((()=>e.fullOpacity),(()=>this.events.emit("content-changed"))),e),a}removeDrapeSourceRenderer(e){if(null==e)return;const t=this._renderers.get(e);null!=t&&(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(e),this.removeHandles(e),t.destroy())}computeValidity(){return this._renderTargets?.computeValidity()??0}releaseRenderTargets(){this._renderTargets?.dispose()}get overlays(){return this._overlays??[]}ensureDrapeTargets(e){this._hasTargetWithoutRasterImage=!!this._overlays&&m(e,(e=>e.drapeTargetType===rr.WithoutRasterImage))}ensureDrapeSources(e){this._overlays?(this._hasDrapedFeatureSource=m(e,(e=>e.drapeSourceType===er.Features)),this._hasDrapedRasterSource=m(e,(e=>e.drapeSourceType===er.RasterImage))):this._hasDrapedFeatureSource=this._hasDrapedRasterSource=!1}get _needsColorWithoutRasterImage(){return this._hasDrapedRasterSource&&this._hasDrapedFeatureSource&&this._hasTargetWithoutRasterImage}ensureOverlays(e,t,r=this._bindParameters.overlayStretch){null==this._overlays&&(this._renderTargets=new Cr(this.view._stage.renderer.fboCache),this._overlays=[new gr,new gr]),this.ensureDrapeTargets(e),this.ensureDrapeSources(t),this._bindParameters.overlayStretch=r}disposeOverlays(){this._overlays=null,this._renderTargets=a(this._renderTargets),this.events.emit("textures-disposed")}getTexture(e){if(null!=e)return e===cr.ColorNoRasterImage&&!this._needsColorWithoutRasterImage&&this._hasDrapedFeatureSource?this._renderTargets?.getTexture(cr.Color):this._renderTargets?.getTexture(e)}get running(){return this.updating}runTask(e){this._processDrapeSources(e,(()=>!0))}_processDrapeSources(e,t){let s=!1;for(const[r,a]of this._renderers){if(e.done)break;(r.destroyed||t(r))&&a.commitChanges()&&(s=!0,e.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,s=!0,this._updateSortedDrapeSourceRenderers()),s&&(null!=this._overlays&&0===this._renderers.size&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this.hasHighlights=r(this._renderers,(e=>e.hasHighlights)),this.notifyChange("rendersOccludedDraped"),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources($t,(e=>e.updatePolicy===it.SYNC))}get isEmpty(){return!z.OVERLAY_DRAW_DEBUG_TEXTURE&&!r(this._renderers,(e=>!e.isEmpty))}get hasWater(){return this._hasWater}get rendersOccludedDraped(){const e=this._renderContext.renderOccludedMask;this._renderContext.renderOccludedMask=Fa;const t=this._sortedRenderers.some((({renderer:e})=>e.shouldRender(this._renderContext)));return this._renderContext.renderOccludedMask=e,t}renders(e){return z.OVERLAY_DRAW_DEBUG_TEXTURE&&e!==cr.Occluded||this._sortedRenderers.some((({renderer:e})=>e.shouldRender(this._renderContext)))}get mode(){return this.isEmpty?Ur.Disabled:this._renderTargets?.getTexture(cr.WaterNormal)?Ur.EnabledWithWater:this._renderTargets?.getTexture(cr.Color)?Ur.Enabled:Ur.Disabled}updateAnimation(e){let t=!1;return this._renderers.forEach((r=>t=r.updateAnimation(e)||t)),t}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawOverlays(e){if(this._overlays&&this._renderTargets){for(const e of this._overlays)this.longitudeCyclical?e.setupGeometryViewsCyclical(this.longitudeCyclical):e.setupGeometryViewsDirect();for(const t of this._renderTargets.targets)(t.content!==cr.ColorNoRasterImage||this._needsColorWithoutRasterImage)&&(this._drawTarget(ir.INNER,t,e),this._drawTarget(ir.OUTER,t,e))}}_drawTarget(e,t,r){const s=this._overlays[e],a=s.canvasGeometries;if(0===a.numViews)return;const{alignPixelEnabled:i,contentPixelRatio:o}=r;this._screenToWorldRatio=o*s.mapUnitsPerPixel/this._bindParameters.overlayStretch;const n=t.output;if(this.isEmpty||n===K.Highlight&&!this.hasHighlights||n===K.Normal&&!this.hasWater||!s.hasSomeSizedView())return;const d=this._rctx;if(this._camera.pixelRatio=s.pixelRatio*o,this._renderContext.output=n,this._bindParameters.alignPixelEnabled=i,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=n===K.Normal?ie.DRAPED_WATER:ie.DRAPED_MATERIAL,t.content===cr.Occluded&&(this._renderContext.renderOccludedMask=Fa),!this.renders(t.content))return void(this._renderContext.renderOccludedMask=ls);const c=s.resolution;this._rctx.setViewport(e===ir.INNER?0:c,0,c,c);const l=2*s.resolution,h=s.resolution,u=t.fbo;if(u.bind(d,l,h),e===ir.INNER&&(d.setClearColor(0,0,0,0),d.clearSafe(Ft.COLOR_BUFFER_BIT)),z.OVERLAY_DRAW_DEBUG_TEXTURE&&t.content!==cr.Occluded)for(let t=0;t<a.numViews;t++)this._setViewParameters(a.extents[t],s),this._ensureDebugPatternResources(s.resolution,Ia[e]),this._rctx.bindTechnique(this._debugTextureTechnique,this._renderContext.bindParameters,this._passParameters),this._rctx.screen.draw();this._sortedRenderers.forAll((({drapeSource:r,renderer:i})=>{if(t.content===cr.ColorNoRasterImage&&r.drapeSourceType===er.RasterImage)return;const{fullOpacity:o}=r,c=null!=o&&o<1&&n===K.Color?this.bindTemporaryFramebuffer(l,h):null;for(let e=0;e<a.numViews;e++)this._setViewParameters(a.extents[e],s),i.render(this._renderContext);if(c){u.bind(d,l,h),this._overlayParameters.texture=c.getTexture(),this._overlayParameters.opacity=o,this._overlayParameters.overlayIndex=e;const t=this.pluginContext.techniqueRepository.acquire(Oa);this._rctx.bindTechnique(t,this._renderContext.bindParameters,this._overlayParameters),this._rctx.screen.draw(),t.release(),c.release()}})),d.bindFramebuffer(null),e===ir.OUTER&&u.generateMipMap(),this._renderContext.renderOccludedMask=ls}bindTemporaryFramebuffer(e,t){const r=this.view._stage.renderer.fboCache,s=r.acquire(e,t,"overlay tmp");return r.rctx.clearSafe(Ft.COLOR_BUFFER_BIT),s}async reloadShaders(){await this._shaderTechniques.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(e,t,r,s){this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers();let a=0;for(const{renderer:i}of this._sortedRenderers)a=i.intersect?.(e,t,r,s,a)??a}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),0===this._renderers.size)return;const e=this.view.map.allLayers,t=e.length;this._renderers.forEach(((r,s)=>{const a=e.indexOf(s.layer),i=a>=0,o=s.renderGroup??(i?tr.MapLayer:tr.ViewLayer),n=t*o+(i?a:0);this._sortedRenderers.push(new Aa(s,r,n))})),this._sortedRenderers.sort(((e,t)=>e.index-t.index))}_setViewParameters(e,t){const r=this._camera;r.viewport=[0,0,t.resolution,t.resolution],M(r.projectionMatrix,0,e[2]-e[0],0,e[3]-e[1],r.near,r.far),D(r.viewMatrix,[-e[0],-e[1],0])}_updateHasWater(){const e=r(this._renderers,(e=>e.hasWater));e!==this._hasWater&&(this._hasWater=e,this.events.emit("has-water",e))}_ensureDebugPatternResources(e,t){if(L(this._passParameters.color,t[0],t[1],t[2]),this._passParameters.texture)return;const r=new Uint8Array(e*e*4);let s=0;for(let t=0;t<e;t++)for(let a=0;a<e;a++){const i=Math.floor(a/10),o=Math.floor(t/10);i<2||o<2||10*i>e-20||10*o>e-20?(r[s++]=255,r[s++]=255,r[s++]=255,r[s++]=255):(r[s++]=255,r[s++]=255,r[s++]=255,r[s++]=1&i&&1&o?1&a^1&t?0:255:1&i^1&o?0:128)}const a=new Gt(e);a.samplingMode=Lt.NEAREST,this._passParameters.texture=new jt(this._rctx,a,r);const i=new Ma;i.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniques.acquire(ba,i)}get test(){return{drapedRenderers:Array.from(this._renderers.values()),sortedDrapeSources:Array.from(this._sortedRenderers).map((({drapeSource:e})=>e)),getDrapeSourceRenderer:e=>this._renderers.get(e)}}};e([p()],Ea.prototype,"hasHighlights",void 0),e([p()],Ea.prototype,"_sortedDrapeSourceRenderersDirty",void 0),e([p()],Ea.prototype,"_shaderTechniques",void 0),e([p({constructOnly:!0})],Ea.prototype,"view",void 0),e([p()],Ea.prototype,"worldToPCSRatio",void 0),e([p()],Ea.prototype,"spatialReference",void 0),e([p({type:Boolean,readOnly:!0})],Ea.prototype,"updating",null),e([p()],Ea.prototype,"isEmpty",null),e([p({readOnly:!0})],Ea.prototype,"rendersOccludedDraped",null),Ea=e([v("esri.views.3d.terrain.OverlayRenderer")],Ea);class Aa{constructor(e,t,r){this.drapeSource=e,this.renderer=t,this.index=r}}const Ia=[[1,.5,.5],[.5,.5,1]],Pa=-2,Fa=nt.OccludeAndTransparent;class Na{constructor(e,t={}){this.geometry=e,this.screenToWorldRatio=1,this._transformation=Ae(),this._shaderTransformation=null,this._boundingSphere=null,this.id=u(),this.layerUid=t.layerUid,this.graphicUid=t.graphicUid,this.castShadow=t.castShadow??!1,null!=t.objectShaderTransformation&&this.objectShaderTransformationChanged(t.objectShaderTransformation)}get transformation(){return this._transformation}set transformation(e){T(this._transformation,e),this._boundingSphere=null}get boundingInfo(){return this.geometry.boundingInfo}objectShaderTransformationChanged(e){null==e?this._shaderTransformation=null:(this._shaderTransformation??=Ae(),x(this._shaderTransformation,e,this.geometry.transformation)),this._boundingSphere=null}get boundingSphere(){return this.boundingInfo?(null==this._boundingSphere&&(this._boundingSphere??=Wt(),H(Vt(this._boundingSphere),this.boundingInfo.center,this.shaderTransformation),this._boundingSphere[3]=this.boundingInfo.radius*Jt(this.shaderTransformation)),this._boundingSphere):zt}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return this._shaderTransformation??this.transformation}get attributes(){return this.geometry.attributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(e){this.geometry.visible=e}}export{fs as A,os as B,Vr as C,er as D,cs as E,br as F,as as G,Sr as H,Zs as I,na as J,ls as K,nr as L,ia as M,ba as N,ir as O,or as P,Ma as Q,Na as R,xa as S,dr as T,$r as U,rs as V,zr as W,Us as X,rr as a,sr as b,ar as c,Pa as d,tr as e,Ys as f,Dr as g,ur as h,mr as i,hr as j,Or as k,Ea as l,fr as m,Ur as n,kr as o,cr as p,Ks as q,Fa as r,Wr as s,Br as t,Qr as u,lr as v,xr as w,Rr as x,us as y,qs as z};
