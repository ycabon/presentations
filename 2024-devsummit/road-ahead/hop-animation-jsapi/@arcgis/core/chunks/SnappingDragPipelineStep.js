/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{a as n,r as e}from"./maybe.js";import{ignoreAbortErrors as t,debounce as o}from"../core/promiseUtils.js";import{watch as a}from"../core/reactiveUtils.js";import{p as i}from"./dehydratedFeatureComparison.js";import{c as r}from"./hydratedFeatures.js";import{a as l}from"./elevationInfoUtils.js";import{E as s}from"./InteractiveToolBase.js";import{S as c}from"./SnappingContext.js";import{T as u,I as p}from"./Scheduler.js";function f({predicate:r=(()=>!0),snappingManager:f,snappingContext:P,updatingHandles:v,useZ:S=!0}){const h=new s;if(null==f)return{snappingStep:[x,h],cancelSnapping:x};let y,Z=null,j=null,T=null;const I=()=>{Z=n(Z),f.doneSnapping(),j?.frameTask.remove(),j=null,y=e(y),T=null},z=function(n,e,t){return o((async({frameTask:o,point:a,scenePoint:r,context:l,event:s,delta:c,getLastState:u},p)=>{const f=await o.schedule((()=>n.snap({point:a,scenePoint:r,context:l,signal:p})),p);if(f.valid){let r=await o.schedule((()=>f.apply()),p);const d=u();null!=d.point&&a!==d.point&&(r=n.update({point:d.point,scenePoint:d.scenePoint,context:l})),null!=d.updatePoint&&i(r,d.updatePoint)||(g(s.mapEnd,r,c,e),t.execute(s))}}))}(f,S,h);let k=null,w=null,U=null;return{snappingStep:[n=>{if(!r(n))return n;const{action:e}=n;if("start"===e){const{info:e}=n,t="3d"===(o=f.view).type?o.resourceController.scheduler.registerTask(u.SNAPPING):p;if(j=function(n,e,t){return{context:new c({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:null!=e.info?e.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:null!=e.snapOrigin?n.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,originalScenePos:null!=e.scenePoints?e.scenePoints.sceneStart:null,frameTask:t}}(P,n,t),j.context.selfSnappingZ=null,!S&&null!=e){const n=function(n,e){if(!n.hasZ())return null;const t=e.vertices;let o=null;for(const e of t){const t=n.getZ(e.pos);if(null!=o&&null!=t&&Math.abs(t-o)>1e-6)return null;null==o&&(o=t)}return o}(P.coordinateHelper,e.handle.component);null!=n&&(j.context.selfSnappingZ={value:n,elevationInfo:P.elevationInfo??l})}}var o;if(null!=j){const{context:o,originalScenePos:i,originalPos:r}=j,{mapEnd:l,mapStart:s,scenePoints:c}=n,u=d(r,m(l,s)),p=m(s,r),x={...n,action:"update"},P=j.context,h=function(n,e){return null==n||null==e?null:d(n,m(e.sceneEnd,e.sceneStart))}(i,c),I=f.update({point:u,scenePoint:h,context:o});if(U=I,g(l,I,p,S),k=u,w=h,"end"!==e){const{frameTask:n}=j;null==Z&&(Z=new AbortController),T=e=>{v.addPromise(t(z({frameTask:n,event:x,context:P,point:u,scenePoint:h,delta:p,getLastState:()=>({point:k,scenePoint:w,updatePoint:e.forceUpdate?null:U})},Z.signal)))},T({forceUpdate:!1}),null==y&&(y=a((()=>f.options.effectiveEnabled),(()=>T?.({forceUpdate:!0}))))}}return"end"===e&&I(),n},h],cancelSnapping:n=>(I(),n)}}function d(n,[e,t,o]){const a=r(n);return a.x+=e,a.y+=t,a.hasZ&&(a.z+=o),a}function m(n,e){const t=n.hasZ&&e.hasZ?n.z-e.z:0;return[n.x-e.x,n.y-e.y,t]}function g(n,e,[t,o,a],i){n.x=e.x+t,n.y=e.y+o,i&&n.hasZ&&e.hasZ&&(n.z=e.z+a)}function x(n){return n}export{f as c};
