/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Accessor.js";import i from"../core/Evented.js";import{allSettledValues as s,throwIfAborted as n,isAborted as r}from"../core/promiseUtils.js";import{watch as a,syncAndInitial as o,mapCollectionAsync as c,sync as l}from"../core/reactiveUtils.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{L as h}from"./Logger.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import{project as u,initializeProjection as g}from"../geometry/projection.js";import{a as f}from"./elevationInfoUtils.js";import{e as m,a as y,b as S,f as _,g as v,h as w}from"./normalizedPoint.js";import{d as E}from"./Settings.js";import{a as x,L as P,R as T,P as R,I as C}from"./RightAngleSnappingHint.js";import{d as L}from"./handleUtils.js";import{g as F,x as j,f as V}from"./unitUtils.js";import{o as M,x as b,s as I,d as N,c as D,a as O,h as H}from"./vec2.js";import{k as q,p as A,s as z,c as G,h as U,o as k,m as Z,a as W}from"./vec3.js";import{c as X,a as $}from"./vec3f64.js";import{g as B}from"./common.js";import{U as Q}from"./UpdatingHandles.js";import{e as J,D as K,L as Y,f as ee,s as te,d as ie,g as se,h as ne,j as re,k as ae,p as oe,V as ce,P as le}from"./snappingUtils.js";import{sqlAnd as de}from"../core/sql.js";import he from"../layers/support/FeatureFilter.js";import{a as pe}from"./floorFilterUtils.js";import{u as ue,a as ge}from"./layerUtils2.js";import{a as fe}from"./viewUtils.js";import me from"../core/Collection.js";import{b as ye,a as Se}from"./Cyclical.js";import{d as _e,v as ve,c as we}from"./quantityUtils.js";import{r as Ee,p as xe}from"./angularMeasurementUtils.js";import"../geometry.js";import{geodesicLength as Pe}from"../geometry/geometryEngine.js";import{g as Te}from"./projectBuffer.js";import{p as Re}from"./projectVectorToWGS84ComparableLonLat.js";import{inverseGeodeticSolver as Ce,geodesicLengths as Le,InverseGeodeticSolverResult as Fe}from"../geometry/support/geodesicUtils.js";import{g as je}from"./geodesicMeasurementUtils.js";import Ve from"../geometry/SpatialReference.js";import{L as Me,p as be,b as Ie}from"./geometry2dUtils.js";import{c as Ne}from"./vec2f64.js";import De from"../views/interactive/snapping/SnappingOptions.js";let Oe=class extends t{get layerView(){return this.view?.allLayerViews?.find((e=>e.layer===this.layer))}get valid(){return this._valid}get subtypeFilter(){const{layer:e}=this;if(!ue(e)||!e.subtypes?.length)return{mode:"not-in-use",filter:null};const t=e.fieldsIndex.get(e.subtypeField)?.name??e.subtypeField,i=e.sublayers.filter((e=>e.visible)).map((e=>e.subtypeCode));return i.length?i.length===e.subtypes.length?{mode:"all-visible",filter:null}:1===i.length?{mode:"in-use",filter:`${t} = ${i.getItemAt(0)}`}:{mode:"in-use",filter:`${t} IN (${i.join(", ")})`}:{mode:"none-visible",filter:null}}get floorFilter(){const{view:e,layer:t}=this;return e&&t?pe({view:e,layer:t}):null}constructor(e){super(e),this.rulesTable=null,this._valid=!1}initialize(){if(!this.snappingSource||!this.layer)return;const{layer:e,snappingSource:t}=this;if("refresh"in e){const i=e;this.addHandles(i.on("refresh",(()=>t.refresh())))}this.loadRules(),this.addHandles([a((()=>t.updating),(e=>t.layerSource.updating=e),o),a((()=>t.availability),(e=>t.layerSource.availability=e),o)])}getFetchCandidatesParameters(e,t,i){if(!this.valid)return[];const{layer:s,layerView:n,floorFilter:r,rulesTable:a,subtypeFilter:o}=this,c={distance:i,mode:this.view?.type??"2d",point:e,coordinateHelper:t.coordinateHelper,...this._types,filter:n&&"filter"in n?n.filter:null};if(r&&(c.filter=He(c.filter,r)),"not-in-use"!==o.mode&&"all-visible"!==o.mode){if("none-visible"===o.mode)return[];c.filter?c.filter.where=de(c.filter.where,o.mode):c.filter=new he({where:o.filter})}const l=t.feature,d=l?.sourceLayer;if(a&&l&&J(this.view?.map)&&ge(s)&&s.layerId&&ge(d)&&this.view.map.utilityNetworks?.find((e=>e.isUtilityLayer(d)))){if("loaded"!==a.loadStatus)return[];const e=[],t=s.layerId,i=a.getFeatureSQL(d,l)?.[t];if(!i)return[];const n=i.anyVertex;let r=i.endVertex;return r&&n&&r===n&&(r=""),r&&e.push({...c,returnEdge:!1,vertexMode:"ends",filter:He(c.filter,r)}),n&&e.push({...c,returnEdge:!1,vertexMode:"all",filter:He(c.filter,n)}),e}return[c]}async loadRules(){const{layer:e,view:t}=this;if(e&&t&&J(t?.map)&&ge(e)){const i=t.map.utilityNetworks?.find((t=>t.isUtilityLayer(e)));if(i)try{this.rulesTable=await i.getRulesTable(),await(this.rulesTable?.load())}catch(t){return void h.getLogger("esri.views.interactive.snapping.FeatureSnappingSourceInfo").error("Failed to load rules table for snapping source",e.title)}}this._valid=!0}get _types(){return{returnEdge:!0,vertexMode:"all"}}remove(){this.destroy()}destroy(){this.snappingSource?.destroy()}};function He(e,t){return null==e?new he({where:t}):e.where?new he({where:de(e.where,t)}):new he({where:t})}e([d({constructOnly:!0})],Oe.prototype,"layer",void 0),e([d({constructOnly:!0})],Oe.prototype,"snappingSource",void 0),e([d({constructOnly:!0})],Oe.prototype,"view",void 0),e([d()],Oe.prototype,"layerView",null),e([d()],Oe.prototype,"rulesTable",void 0),e([d()],Oe.prototype,"valid",null),e([d()],Oe.prototype,"subtypeFilter",null),e([d()],Oe.prototype,"floorFilter",null),e([d()],Oe.prototype,"_valid",void 0),Oe=e([p("esri.views.interactive.snapping.FeatureSnappingSourceInfo")],Oe);class qe{constructor(e,t,i,s){this.targetPoint=e,this.constraint=t,this.isDraped=i,this.domain=s}}class Ae extends qe{constructor({targetPoint:e,objectId:t,constraint:i,isDraped:s}){super(e,i,s,x.FEATURE),this.objectId=t}}class ze extends Ae{constructor(e){super({...e,isDraped:!0,constraint:new K(e.edgeStart,e.edgeEnd,e.getGroundElevation)})}get hints(){return[new P(Y.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}class Ge extends Ae{constructor(e){super({...e,constraint:new ee(e.edgeStart,e.edgeEnd)})}get hints(){return[new P(Y.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}class Ue extends qe{constructor({targetPoint:e,constraint:t,previousVertex:i,otherVertex:s,otherVertexType:n,objectId:r,isDraped:a}){super(e,t,a,x.SELF),this.previousVertex=i,this.otherVertex=s,this.otherVertexType=n,this.objectId=r}get hints(){const e=this.previousVertex,t=this.otherVertexType===ke.CENTER?this.otherVertex:this.targetPoint,i=this.otherVertexType===ke.CENTER?this.targetPoint:this.otherVertex;return[new P(Y.TARGET,t,i,this.isDraped,this.domain),new P(Y.REFERENCE,e,t,this.isDraped,this.domain),new T(this.previousVertex,t,i,this.isDraped,this.domain)]}}var ke;!function(e){e[e.NEXT=0]="NEXT",e[e.CENTER=1]="CENTER"}(ke||(ke={}));let Ze=class extends t{get updating(){return this._snappingSources.some((e=>null==e||e.valid&&e.snappingSource.updating))||this._updatingHandles.updating}constructor(e){super(e),this.options=null,this._domain=x.FEATURE,this._updatingHandles=new Q,this._sourceModules={featureService:{module:null,loader:null},featureCollection:{module:null,loader:null},graphics:{module:null,loader:null},notes:{module:null,loader:null},scene:{module:null,loader:null}}}initialize(){const e=c((()=>this.options?.featureSources),((e,t)=>this._createSourceInfo(e,t)));this._snappingSources=e,this.addHandles(L(e))}destroy(){this._set("options",null),this._updatingHandles.destroy()}async fetchCandidates(e,t,i,r){if(!(t&this._domain&&null!=this.options&&this.options.effectiveFeatureEnabled))return[];const a=[],o=this._computeScreenSizeDistanceParameters(e,i);for(const t of this._snappingSources){if(null==t||!t.valid||!t.snappingSource.layerSource.enabled||t.layerView?.suspended)continue;const s=t.getFetchCandidatesParameters(e,i,o);for(const e of s)a.push(t.snappingSource.fetchCandidates(e,r).then((e=>e.filter((e=>!this._candidateIsExcluded(t.snappingSource,e,i.excludeFeature))))))}const c=(await s(a)).flat();return this._addRightAngleCandidates(c,e,o,i),n(r),te(e,c),c}_addRightAngleCandidates(e,t,i,s){const n=null!=s.vertexHandle?s.vertexHandle.rightEdge?.rightVertex?.pos:null!=s.editGeometryOperations&&"polygon"===s.editGeometryOperations.data.type?s.editGeometryOperations.data.components[0]?.getFirstVertex()?.pos:null,r=null!=s.vertexHandle?s.vertexHandle.leftEdge?.leftVertex?.pos:null!=s.editGeometryOperations?s.editGeometryOperations.data.components[0]?.getLastVertex()?.pos:null,{view:a}=this,o=m(n,a,s),c=m(r,a,s),l=e.length;for(let s=0;s<l;s++)this._addRightAngleCandidate(e[s],c,t,i,e),this._addRightAngleCandidate(e[s],o,t,i,e)}_addRightAngleCandidate(e,t,i,s,n){if(null==t||!function(e){return(e instanceof Ge||e instanceof ze)&&!function({constraint:{start:e,end:t}}){const i=q(e,t),s=M(y(e),y(t));return i<B()||s/i<Be}(e)}(e))return;const r=e.constraint.closestTo(t),a=(r[0]-i[0])/s.x,o=(r[1]-i[1])/s.y,{start:c,end:l}=e.constraint;if(a*a+o*o<=1){const i=new Ue({targetPoint:r,otherVertex:t,otherVertexType:ke.NEXT,previousVertex:M(y(r),y(c))>M(y(r),y(l))?c:l,constraint:new ie(t,r),objectId:e.objectId,isDraped:e.isDraped});n.push(i)}}_computeScreenSizeDistanceParameters(e,t){let i=null!=this.options?this.options.distance*("touch"===t.pointer?this.options.touchSensitivityMultiplier:1):0;return null==this.view?{x:i,y:i,z:i,distance:i}:"2d"===this.view.type?(i*=this.view.resolution,{x:i,y:i,z:i,distance:i}):this._computeScreenSizeDistanceParameters3D(e,i,this.view,t)}_computeScreenSizeDistanceParameters3D(e,t,i,s){const{spatialReference:n}=s;i.renderCoordsHelper.toRenderCoords(e,n,Xe);const r=i.state.camera.computeScreenPixelSizeAt(Xe),a=r*i.renderCoordsHelper.unitInMeters,o=a/F(n),c=a/j(n),l=t*o,d=t*c,h=fe(e,n,f,i),p=h?We(h,e,o,0,0,i,s):0,u=h?We(h,e,0,o,0,i,s):0,g=h?We(h,e,0,0,c,i,s):0;return{x:0===p?0:l/p,y:0===u?0:l/u,z:0===g?0:d/g,distance:r*t}}_candidateIsExcluded(e,t,i){if(null==i)return!1;const s=this._getCandidateObjectId(t);if(null==s)return!1;const n=e.layerSource.layer;return"graphics"===n.type?i.uid===s:i.sourceLayer===n&&!(!i.attributes||!("objectIdField"in n))&&i.attributes[n.objectIdField]===s}_getCandidateObjectId(e){return e instanceof Ae?e.objectId:null}async _createSourceInfo(e,t){const i=e.layer;i.loaded||(await i.load(),n(t));const{view:s}=this,r=await this._createFeatureSnappingSourceType(e);return n(t),new Oe(null==r?{}:{snappingSource:r,view:s,layer:i})}async _createFeatureSnappingSourceType(e){switch(e.layer.type){case"feature":case"geojson":case"csv":case"oriented-imagery":case"subtype-group":case"wfs":return this._createFeatureSnappingSourceFeatureLayer(e);case"graphics":return this._createFeatureSnappingSourceGraphicsLayer(e);case"map-notes":return this._createFeatureSnappingSourceMapNotesLayer(e);case"scene":case"building-scene":return this._createFeatureSnappingSourceSceneLayer(e)}return null}async _createFeatureSnappingSourceSceneLayer(e){const{view:t}=this;return null==t||"3d"!==t.type?null:new((await this._getSourceModule("scene")).SceneLayerSnappingSource)({layerSource:e,view:t})}async _createFeatureSnappingSourceFeatureLayer(e){switch(e.layer.source?.type){case"feature-layer":case"oriented-imagery":return new((await this._getSourceModule("featureService")).FeatureServiceSnappingSource)({spatialReference:this.spatialReference,view:this.view,layerSource:e});case"memory":case"csv":case"geojson":case"wfs":return"mesh"===e.layer.geometryType?null:new((await this._getSourceModule("featureCollection")).FeatureCollectionSnappingSource)({layerSource:e,view:this.view})}return null}async _createFeatureSnappingSourceGraphicsLayer(e){return new((await this._getSourceModule("graphics")).GraphicsSnappingSource)({getGraphicsLayers:()=>[e.layer],spatialReference:this.spatialReference,view:this.view,layerSource:e})}async _createFeatureSnappingSourceMapNotesLayer(e){return new((await this._getSourceModule("notes")).GraphicsSnappingSource)({getGraphicsLayers:()=>e.layer.sublayers?.toArray()??[],spatialReference:this.spatialReference,view:this.view,layerSource:e})}async _getSourceModule(e){const t=this._sourceModules[e];if(null==t.loader){const t=this._loadSourceModule(e),i={module:null,loader:t};this._sourceModules[e]=i;const s=await t,n={module:s,loader:t};return this._sourceModules[e]=n,s}return null==t.module?t.loader:t.module}_loadSourceModule(e){const t=this._updatingHandles;switch(e){case"featureService":return t.addPromise(import("./FeatureServiceSnappingSource.js"));case"featureCollection":return t.addPromise(import("./FeatureCollectionSnappingSource.js"));case"graphics":case"notes":return t.addPromise(import("./GraphicsSnappingSource.js"));case"scene":return t.addPromise(import("./SceneLayerSnappingSource.js"))}}get test(){return{snappingSources:this._snappingSources}}};function We(e,t,i,s,n,r,{spatialReference:a}){const o=A($e,t);o[0]+=i,o[1]+=s,o[2]+=n;const c=fe(o,a,f,r);return c?se(c,e):1/0}e([d({constructOnly:!0})],Ze.prototype,"spatialReference",void 0),e([d({constructOnly:!0})],Ze.prototype,"view",void 0),e([d()],Ze.prototype,"options",void 0),e([d({readOnly:!0})],Ze.prototype,"updating",null),e([d()],Ze.prototype,"_snappingSources",void 0),Ze=e([p("esri.views.interactive.snapping.FeatureSnappingEngine")],Ze);const Xe=X(),$e=X(),Be=1e-4;class Qe{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=E.shortLineThreshold*E.shortLineThreshold}snap(e,t){return null!=t.vertexHandle?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(m(e.leftVertex.pos,this.view,t),m(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return 0===this.squaredShortLineThreshold||ne(fe(t,i,f,this.view),fe(e,i,f,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:i}){const s=F(i);return b(y(e),y(t))*s<E.verticalLineThresholdMeters}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class Je extends qe{constructor({lineStart:e,lineEnd:t,targetPoint:i,isDraped:s}){super(i,new re(e,t),s,x.SELF),this._referenceLineHint=new P(Y.REFERENCE_EXTENSION,e,t,s,this.domain)}get hints(){return[this._referenceLineHint,new P(Y.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}}const Ke=X();function Ye(e){const{spatialReference:t}=e;return je(t,rt,at,ot,e)}function et(e,t){if(!V(e.spatialReference,t.spatialReference))return null;const{spatialReference:i}=e;return lt[0]=e.x,lt[1]=e.y,lt[2]=e.hasZ?e.z:0,dt[0]=t.x,dt[1]=t.y,dt[2]=t.hasZ?t.z:0,tt(lt,dt,i)}function tt(e,t,i){return je(i,it,st,nt,e,t,i)}function it(e,t,i){return _e(Ce(ct,e,t,i).distance,"meters")}function st(e,t,i){return _e(Pe(function(e,t,i){return{type:"polyline",spatialReference:i,paths:[[[...e],[...t]]]}}(e,t,i),"meters"),"meters")}function nt(e,t,i){return Re(e,i,ht)&&Re(t,i,pt)?_e(Ce(ct,ht,pt,Ve.WGS84).distance,"meters"):null}function rt(e){return _e(Le([e],"meters")[0],"meters")}function at(e){return _e(Pe(e,"meters"),"meters")}function ot(e){const t=[];if(!function({hasZ:e,spatialReference:t,paths:i},s,n=0){const r=Te(t);if(null==r)return!1;const a=e?e=>e:e=>z(Ke,e[0],e[1],n);for(const e of i){const t=[];for(const i of e){const e=[0,0,n];r(a(i),0,e,0),t.push(e)}s.push(t)}return!0}(e,t))return null;let i=0;for(const e of t){let t=0;for(let i=1;i<e.length;++i)t+=Ce(ct,e[i-1],e[i],Ve.WGS84).distance;i+=t}return _e(i,"meters")}const ct=new Fe,lt=X(),dt=X(),ht=X(),pt=X();class ut extends Qe{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=[];if(s<1)return n;const{spatialReference:r}=t,a=fe(e,r,f,this.view),{view:o}=this,c=i.edges[s-1];let l=c;do{if(this.edgeExceedsShortLineThreshold(l,t)){const i=ae(l,o,t);this._processCandidateProposal(i.left,i.right,e,a,t,n)}l=l.leftVertex.leftEdge}while(l&&l!==c);return n}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<2)return i;const{view:r}=this,{spatialReference:a}=t,o=fe(e,a,f,r),c=s.leftEdge,l=s.rightEdge;c&&l&&this.edgeExceedsShortLineThreshold(c,t)&&this.edgeExceedsShortLineThreshold(l,t)&&this._processCandidateProposal(m(c.leftVertex.pos,r,t),m(l.rightVertex.pos,r,t),e,o,t,i);const d=n.edges[0];let h=d;do{if(h!==s.leftEdge&&h!==s.rightEdge&&this.edgeExceedsShortLineThreshold(h,t)){const s=ae(h,r,t);this._processCandidateProposal(s.left,s.right,e,o,t,i)}h=h.rightVertex.rightEdge}while(h&&h!==d);return i}_processCandidateProposal(e,t,i,s,n,r){const{spatialReference:a,pointer:o}=n,c=X();this._projectedLine(c,e,t,i,n);const l=S(c);ne(s,fe(l,a,f,this.view))<this.squaredProximityThreshold(o)&&r.push(new Je({lineStart:e,lineEnd:t,targetPoint:l,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}_projectedLine(e,t,i,s,n){this._projectToLineGeodesic(e,t,i,s,n)||this._projectToLinePlanar(e,s,t,i)}_projectToLineGeodesic(e,t,i,s,{spatialReference:n}){const r=Ee(t,i,n,n);if(null==r)return!1;const a=Ee(i,s,n,n);if(null==a)return!1;const o=tt(i,s,n);if(null==o)return!1;const c=Math.abs(ye.shortestSignedDiff(r,a))>Math.PI/2?Se.normalize(r+Math.PI):r;return xe(e,i,n,ve(o,"meters"),we(c,"radians","geographic"),"geodesic"),e[2]=s[2],!0}_projectToLinePlanar(e,t,i,s){oe(t,{start:i,end:s,type:Me.LINE},e),e[2]=t[2]}}class gt extends qe{constructor({referenceLine:e,lineStart:t,targetPoint:i,isDraped:s}){const n=$(t),{left:r,right:a}=e;G(n,U(n,n,a),r),super(i,new re(t,S(n)),s,x.SELF),this._referenceLines=[{edge:e,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new P(Y.TARGET,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new R(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map((e=>new P(Y.REFERENCE,e.edge.left,e.edge.right,this.isDraped,this.domain,e.fadeLeft,e.fadeRight)))]}addReferenceLine(e){const t={edge:e,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach((i=>{k(e.right,i.edge.left)&&(i.fadeLeft=!1,t.fadeRight=!1),k(e.right,i.edge.right)&&(i.fadeRight=!1,t.fadeRight=!1),k(e.left,i.edge.right)&&(i.fadeRight=!1,t.fadeLeft=!1),k(e.left,i.edge.left)&&(i.fadeLeft=!1,t.fadeLeft=!1)})),this._referenceLines.push(t)}}class ft extends Qe{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=i.vertices.length,r=[];if(s<2)return r;const{view:a}=this,o=fe(e,t.spatialReference,f,a),c=m(i.vertices[n-1].pos,a,t),l=m(i.vertices[0].pos,a,t),d=i.edges[s-1];let h=d;do{if(this.edgeExceedsShortLineThreshold(h,t)){const i=ae(h,a,t);this._checkEdgeForParallelLines(i,c,e,o,t,r),this._checkEdgeForParallelLines(i,l,e,o,t,r)}h=h.leftVertex.leftEdge}while(h&&h!==d);return r}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<3)return i;const{view:r}=this,a=fe(e,t.spatialReference,f,r),o=s.leftEdge,c=s.rightEdge,l=n.vertices[0],d=m(l.pos,r,t),h=n.vertices.length,p=n.vertices[h-1],u=m(p.pos,r,t),g=n.edges[0];let y=g;do{if(y!==o&&y!==c&&this.edgeExceedsShortLineThreshold(y,t)){const n=ae(y,r,t);o&&this._checkEdgeForParallelLines(n,m(o.leftVertex.pos,r,t),e,a,t,i),c&&this._checkEdgeForParallelLines(n,m(c.rightVertex.pos,r,t),e,a,t,i),s===l?this._checkEdgeForParallelLines(n,u,e,a,t,i):s===p&&this._checkEdgeForParallelLines(n,d,e,a,t,i)}y=y.rightVertex.rightEdge}while(y&&y!==g);return i}_checkEdgeForParallelLines(e,t,i,s,n,r){const a=e.left,o=e.right;if(be(mt,y(t),y(a),y(o)),M(mt,y(t))<E.parallelLineThreshold)return;be(mt,y(i),y(a),y(o),y(t));const{spatialReference:c,pointer:l}=n,d=_(mt[0],mt[1],i[2]);if(ne(s,fe(d,c,f,this.view))<this.squaredProximityThreshold(l)){if(this.isVertical(d,t,n)||this.isVertical(a,o,n))return;if(this._parallelToPreviousCandidate(e,r))return;r.push(new gt({referenceLine:e,lineStart:t,targetPoint:d,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}}_parallelToPreviousCandidate(e,t){const i=e.left,s=e.right;for(const n of t)if(be(mt,y(s),y(n.constraint.start),y(n.constraint.end),y(i)),M(mt,y(s))<E.parallelLineThreshold)return n.addReferenceLine(e),!0;return!1}}const mt=Ne();class yt extends Qe{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[];if(i.vertices.length<2)return s;const{view:n}=this,r=fe(e,t.spatialReference,f,n),a=i.vertices.at(-1);this._checkForSnappingCandidate(s,a.leftEdge,a,a.leftEdge.leftVertex,e,r,t);const o=i.vertices[0];return this._checkForSnappingCandidate(s,o.rightEdge,o,o.rightEdge.rightVertex,e,r,t),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:n}=this,r=fe(e,t.spatialReference,f,n),a=s.leftEdge,o=s.rightEdge;if(a?.leftVertex.leftEdge){const s=a.leftVertex.leftEdge;this._checkForSnappingCandidate(i,s,s.rightVertex,s.leftVertex,e,r,t)}if(o?.rightVertex.rightEdge){const s=o.rightVertex.rightEdge;this._checkForSnappingCandidate(i,s,s.leftVertex,s.rightVertex,e,r,t)}return i}_checkForSnappingCandidate(e,t,i,s,n,r,a){if(!this.edgeExceedsShortLineThreshold(t,a))return;const o=this.view,c=m(i.pos,o,a),l=m(s.pos,o,a);this._checkForSnappingCandidateNormalized(e,l,c,n,r,a)}_checkForSnappingCandidateNormalized(e,t,i,s,n,r){this._projectionRay(_t,t,i,s,r),this._checkForSnappingCandidateAlongProjectedRay(e,t,i,_t,s,n,r)}_projectionRay(e,t,i,s,n){this._projectionRayGeodesic(e,t,i,s,n)||this._projectionRayPlanar(e,t,i)}_projectionRayGeodesic(e,t,i,s,{spatialReference:n}){const r=Ee(t,i,n,n);if(null==r)return!1;const a=Ee(i,s,n,n);if(null==a)return!1;const o=Math.sign(Se.shortestSignedDiff(r,a))*Math.PI*.5,c=we(r+o,"radians","geographic"),l=X(),d=tt(i,s,n);return null!=d&&(xe(l,i,n,ve(d,"meters"),c,"geodesic"),G(e,l,i),!0)}_projectionRayPlanar(e,t,i){const s=I(St,y(i),y(t));z(e,s[1],-s[0],0)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,s,n,r,a){const{spatialReference:o,pointer:c}=a,l=I(St,y(n),y(i)),d=N(s,l)/D(s),h=O(St,y(i),s,d),p=_(h[0],h[1],n[2]);if(ne(r,fe(p,o,f,this.view))>this.squaredProximityThreshold(c)||this.isVertical(p,i,a)||this.isVertical(i,t,a))return;const u=Z(X(),i,s,Math.sign(d));e.push(new Ue({targetPoint:p,constraint:new ie(i,S(u)),previousVertex:t,otherVertex:i,otherVertexType:ke.CENTER,isDraped:"on-the-ground"===a.elevationInfo?.mode}))}}const St=Ne(),_t=X();class vt extends qe{constructor({targetPoint:e,point1:t,point2:i,isDraped:s}){super(e,new ce(S(W(X(),t,i,.5)),.5*b(y(t),y(i))),s,x.SELF),this._p1=t,this._p2=i}get hints(){return[new P(Y.REFERENCE,this.targetPoint,this._p1,this.isDraped,this.domain),new P(Y.REFERENCE,this.targetPoint,this._p2,this.isDraped,this.domain),new T(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}}class wt extends Qe{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[],n=i.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||n<2)return s;const{view:r}=this,a=i.vertices[0],o=i.vertices[n-1],c=m(a.pos,r,t),l=m(o.pos,r,t);return this._processCandidateProposal(c,l,e,t,s),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<2)return i;if("polyline"===t.editGeometryOperations.data.type&&(0===s.index||s.index===n.vertices.length-1))return i;const{view:r}=this,a=m(s.leftEdge.leftVertex.pos,r,t),o=m(s.rightEdge.rightVertex.pos,r,t);return this._processCandidateProposal(a,o,e,t,i),i}_processCandidateProposal(e,t,i,s,n){if(!this.exceedsShortLineThreshold(e,t,s))return;const r=H(Et,y(e),y(t),.5),a=.5*b(y(e),y(t)),o=Ie(Et,y(i),r,a),c=_(o[0],o[1],i[2]),{spatialReference:l,pointer:d}=s,h=fe(i,l,f,this.view);if(ne(h,fe(c,l,f,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(e,c,s)||this.isVertical(c,t,s))return;n.push(new vt({targetPoint:c,point1:e,point2:t,isDraped:"on-the-ground"===s.elevationInfo?.mode}))}}}const Et=Ne();let xt=class extends t{constructor(e){super(e),this.updating=!1,this._snappers=new me,this._domain=x.SELF}initialize(){this._snappers.push(new ft(this.view,this.options),new ut(this.view,this.options),new yt(this.view,this.options),new wt(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,i){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const s=[];for(const t of this._snappers.items)for(const n of t.snap(e,i))s.push(n);return te(e,s),s}};function Pt(e,t){return[new xt({view:e,options:t}),new Ze({view:e,options:t,spatialReference:e.spatialReference})]}e([d({readOnly:!0})],xt.prototype,"updating",void 0),e([d({constructOnly:!0})],xt.prototype,"view",void 0),e([d()],xt.prototype,"options",null),xt=e([p("esri.views.interactive.snapping.SelfSnappingEngine")],xt);class Tt extends qe{constructor(e,t,i,s){super(e,new le(e),s,x.ALL),this.first=t,this.second=i}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new C(this.targetPoint,this.isDraped,this.domain)]}}let Rt=class extends(i.EventedMixin(t)){constructor(e){super(e),this.options=new De,this.snappingEnginesFactory=Pt,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=Ct.MAIN}initialize(){this.addHandles([a((()=>{const{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}=this.options;return{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}}),(()=>{this.doneSnapping(),this.emit("changed")}),l),a((()=>this.options),(e=>{for(const t of this._engines)t.options=e}),l),a((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:e,snappingEnginesFactory:t})=>this._recreateEngines(e,t)),o)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((e=>e.updating))}_recreateEngines(e,t){if(this._destroyEngines(),!e)return;const{view:i,options:s}=this;this._engines=t(i,s)}_destroyEngines(){for(const e of this._engines)e.destroy();this._engines=[]}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}get _squaredSatisfiesConstraintThreshold(){return E.satisfiesConstraintScreenThreshold*E.satisfiesConstraintScreenThreshold}snap(e){return function(e){return null!=e.scenePoint}(e)?this._snapMultiPoint(e):this._snapSinglePoint(e)}update(e){const{point:t,context:i}=e;this._removeVisualization();const s=this._currentMainCandidate;if(null==s)return t;const n=this._selectUpdateInput(e);if(null==n)return t;const{spatialReference:r}=i,a=u(n,r);if(null==a)return t;const{view:o}=this,{elevationInfo:c,visualizer:l}=i,d=[],h=v(a,o,c),p=s.constraint.closestTo(h);if(!this._arePointsWithinScreenThreshold(h,p,i))return this._resetSnappingState(),t;s.targetPoint=p,d.push(...s.hints);for(const e of this._currentOtherActiveCandidates)e.targetPoint=p,d.push(...e.hints);return null!=l&&this.addHandles(l.draw(d,{spatialReference:r,elevationInfo:Ft(i),view:o,selfSnappingZ:i.selfSnappingZ}),Lt),w(p,o,t,i)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:e,scenePoint:t}){switch(this._currentSnappedType){case Ct.MAIN:return e;case Ct.SCENE:return t}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=Ct.MAIN}_removeVisualization(){this.removeHandles(Lt)}async _snapSinglePoint({point:e,context:t,signal:i}){const{view:s}=this,{elevationInfo:n}=t,r=v(e,s,n),a=await this._fetchCandidates(r,x.ALL,t,i);return this._createSnapResult(r,Ct.MAIN,a,s,e,t,i)}async _snapMultiPoint({point:e,scenePoint:t,context:i,signal:s}){const{view:n}=this,{coordinateHelper:r,elevationInfo:a,spatialReference:o}=i;await g(t.spatialReference,o);const c=u(t,o),l=v(c,n,a),d=await this._fetchCandidates(l,x.FEATURE,i,s);if(d.length>0){const e=await this._fetchCandidates(l,x.SELF,i,s);return this._createSnapResult(l,Ct.SCENE,[...d,...e],n,c,i,s)}const h=v(e,n,a),p=await this._fetchCandidates(h,x.SELF,i,s);return this._createSnapResult(h,Ct.MAIN,p,n,{z:r.hasZ()&&e.hasZ?e.z??0:void 0,m:r.hasM()&&e.hasM?e.m??0:void 0},i,s)}async _fetchCandidates(e,t,i,s){return(await Promise.all(this._engines.map((n=>n.fetchCandidates(e,t,i,s))))).flat()}_createSnapResult(e,t,i,s,n,a,o){return{get valid(){return!r(o)},apply:()=>{const{spatialReference:r}=a,{snappedPoint:o,hints:c}=this._processCandidates(e,t,i,a);return this._removeVisualization(),null!=a.visualizer&&this.addHandles(a.visualizer.draw(c,{spatialReference:r,elevationInfo:f,view:s,selfSnappingZ:a.selfSnappingZ}),Lt),w(o,s,n,a)}}}_processCandidates(e,t,i,s){if(i.length<1)return this.doneSnapping(),{snappedPoint:e,hints:[]};this._currentSnappedType!==t&&this._resetSnappingState(),te(e,i);const n=this._currentMainCandidate;if(null!=n){const r=this._findOldConstraintInNewCandidates(n,i);if(r>=0){if(!(i[r]instanceof Tt))return this._intersectWithOtherCandidates(r,i,e,t,s);if(this._arePointsWithinScreenThreshold(e,n.targetPoint,s))return this._updateSnappingCandidate(n,t,i,s)}}return this._intersectWithOtherCandidates(0,i,e,t,s)}_findOldConstraintInNewCandidates(e,t){return e instanceof Tt?this._findOldCandidateIndex(t,e.first)>=0&&this._findOldCandidateIndex(t,e.second)>=0?0:-1:this._findOldCandidateIndex(t,e)}_intersectWithOtherCandidates(e,t,i,s,n){const{coordinateHelper:r}=n,a=t[e],o=[];for(let s=0;s<t.length;++s){if(s===e)continue;const n=t[s],c=a.constraint.intersect(n.constraint);if(c)for(const e of c.closestPoints(a.targetPoint))o.push([new Tt(e,a,n,n.isDraped),this._squaredScreenDistance(i,e,r)])}return o.length>0&&(o.sort(((e,t)=>e[1]-t[1])),o[0][1]<this._squaredPointProximityThreshold(n.pointer))?this._updateSnappingCandidate(o[0][0],s,t,n):this._updateSnappingCandidate(a,s,t,n)}_updateSnappingCandidate(e,t,i,s){this.doneSnapping(),this._currentMainCandidate=e,this._currentSnappedType=t;const n=this._currentMainCandidate.targetPoint,r=[];r.push(...e.hints);for(const t of i){if(e instanceof Tt){if(t.constraint.equals(e.first.constraint)||t.constraint.equals(e.second.constraint))continue}else if(t.constraint.equals(e.constraint))continue;const i=t.constraint.closestTo(n);this._squaredScreenDistance(i,n,s.coordinateHelper)<this._squaredSatisfiesConstraintThreshold&&(t.targetPoint=n,this._currentOtherActiveCandidates.push(t),r.push(...t.hints))}return{snappedPoint:n,hints:r}}_squaredPointProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(e,t,i){return this._squaredScreenDistance(e,t,i.coordinateHelper)<this._squaredPointProximityThreshold(i.pointer)}_squaredScreenDistance(e,t,i){return ne(this._toScreen(e,i),this._toScreen(t,i))}_toScreen(e,t){return fe(e,t.spatialReference,f,this.view)}_findOldCandidateIndex(e,t){let i=-1;for(let s=0;s<e.length;++s)if(t.constraint.equals(e[s].constraint)){i=s;break}return i}get test(){return{visualizationsActive:this.hasHandles(Lt),engines:this._engines}}};var Ct;e([d({constructOnly:!0})],Rt.prototype,"view",void 0),e([d()],Rt.prototype,"options",void 0),e([d({readOnly:!0})],Rt.prototype,"updating",null),e([d()],Rt.prototype,"snappingEnginesFactory",void 0),e([d()],Rt.prototype,"_engines",void 0),e([d()],Rt.prototype,"_squaredMouseProximityThreshold",null),e([d()],Rt.prototype,"_squaredTouchProximityThreshold",null),e([d()],Rt.prototype,"_squaredSatisfiesConstraintThreshold",null),Rt=e([p("esri.views.interactive.snapping.SnappingManager")],Rt),function(e){e[e.MAIN=0]="MAIN",e[e.SCENE=1]="SCENE"}(Ct||(Ct={}));const Lt="visualization-handle";function Ft({coordinateHelper:e,elevationInfo:t}){return e.hasZ()?f:t}export{ze as D,Ge as E,Ae as F,Rt as S,Ze as a,et as b,tt as c,Ye as g};
