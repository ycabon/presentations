/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{j as e}from"./unitUtils.js";import{T as t}from"./TileKey2.js";import{_ as s}from"./tslib.es6.js";import i,{f as o}from"../core/Accessor.js";import{d as l}from"./maybe.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{subclass as n}from"../core/accessorSupport/decorators/subclass.js";import{x as h,o as a}from"./vec2.js";import{Q as c}from"./QueueProcessor.js";import{c as u,m as f}from"./aaBoundingRect.js";function d(e,t){return[e,t]}function m(e,t,s){return e[0]=t,e[1]=s,e}const g=new t("0/0/0/0");class y{static create(t,s,i=null){const o=e(t.spatialReference),l=s.origin||d(t.origin.x,t.origin.y),r=d(t.size[0]*s.resolution,t.size[1]*s.resolution),n=d(-1/0,-1/0),h=d(1/0,1/0),a=d(1/0,1/0);null!=i&&(m(n,Math.max(0,Math.floor((i.xmin-l[0])/r[0])),Math.max(0,Math.floor((l[1]-i.ymax)/r[1]))),m(h,Math.max(0,Math.floor((i.xmax-l[0])/r[0])),Math.max(0,Math.floor((l[1]-i.ymin)/r[1]))),m(a,h[0]-n[0]+1,h[1]-n[1]+1));const{cols:c,rows:u}=s;let f,g,p,_;return!i&&c&&u&&(m(n,c[0],u[0]),m(h,c[1],u[1]),m(a,c[1]-c[0]+1,u[1]-u[0]+1)),t.isWrappable?(f=d(Math.ceil(Math.round((o.valid[1]-o.valid[0])/s.resolution)/t.size[0]),a[1]),g=d(Math.floor((o.origin[0]-l[0])/r[0]),n[1]),p=d(f[0]+g[0]-1,h[1]),_=!0):(g=n,p=h,f=a,_=!1),new y(s.level,s.resolution,s.scale,l,n,h,a,r,g,p,f,_)}constructor(e,t,s,i,o,l,r,n,h,a,c,u){this.level=e,this.resolution=t,this.scale=s,this.origin=i,this.first=o,this.last=l,this.size=r,this.norm=n,this.worldStart=h,this.worldEnd=a,this.worldSize=c,this.wrap=u}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){return this.origin[0]+e*this.norm[0]}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,s=!1){g.set(t);const i=s?g.col:this.denormalizeCol(g.col,g.world),o=g.row;return function(e,t,s,i,o){e[0]=t,e[1]=s,e[2]=i,e[3]=o}(e,this.getXForColumn(i),this.getYForRow(o+1),this.getXForColumn(i+1),this.getYForRow(o)),e}getTileCoords(e,t,s=!1){g.set(t);const i=s?g.col:this.denormalizeCol(g.col,g.world);return Array.isArray(e)?m(e,this.getXForColumn(i),this.getYForRow(g.row)):(e.x=this.getXForColumn(i),e.y=this.getYForRow(g.row)),e}}class p{constructor(){this.spans=[]}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:s,colFrom:i,colTo:o}of this.spans)for(let l=i;l<=o;l++){const i=e.getWorldForColumn(l);yield new t(e.level,s,e.normalizeCol(l),i)}}forEach(e,t){const{spans:s,lodInfo:i}=this,{level:o}=i;if(0!==s.length)for(const{row:l,colFrom:r,colTo:n}of s)for(let s=r;s<=n;s++)e.call(t,o,l,i.normalizeCol(s),i.getWorldForColumn(s))}}p.pool=new o(p);class _{constructor(e,t,s){this.row=e,this.colFrom=t,this.colTo=s}}const w=new t("0/0/0/0");class v{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[s,i]=e,[o,l]=t,r=o-s,n=l-i,h=0!==n?r/n:0,a=(Math.ceil(i)-i)*h,c=(Math.floor(i)-i)*h;return new v(s,Math.floor(i),Math.ceil(l),h,r<0?a:c,r<0?c:a,r<0?o:s,r<0?s:o)}constructor(e,t,s,i,o,l,r,n){this.x=e,this.ymin=t,this.ymax=s,this.invM=i,this.leftAdjust=o,this.rightAdjust=l,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const I=[[0,0],[0,0],[0,0],[0,0]];class T{constructor(e,t=null,s=e.lods[0].level,i=e.lods[e.lods.length-1].level){this.tileInfo=e,this.fullExtent=t,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=e.lods.filter((e=>e.level>=s&&e.level<=i));this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const l=this._lodInfos=o.map((s=>y.create(e,s,t)));o.forEach(((e,t)=>{this._infoByLevel[e.level]=l[t],this._infoByScale[e.scale]=l[t],this.scales[t]=e.scale}),this),this._wrap=e.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(e){return this._infoByLevel["number"==typeof e?e:e.level]}getTileBounds(e,t,s=!1){w.set(t);const i=this._infoByLevel[w.level];return i?i.getTileBounds(e,w,s):e}getTileCoords(e,t,s=!1){w.set(t);const i=this._infoByLevel[w.level];return i?i.getTileCoords(e,w,s):e}getTileCoverage(e,t=192,s=!0,i="closest"){if(!s&&(e.scale>this.minScale||e.scale<this.maxScale))return null;const o="closest"===i?this.getClosestInfoForScale(e.scale):this.getSmallestInfoForScale(e.scale),l=p.pool.acquire(o),r=this._wrap;let n,h,a,c=1/0,u=-1/0;const f=l.spans;I[0][0]=I[0][1]=I[1][1]=I[3][0]=-t,I[1][0]=I[2][0]=e.size[0]+t,I[2][1]=I[3][1]=e.size[1]+t;for(const t of I)e.toMap(t,t),t[0]=o.getColumnForX(t[0]),t[1]=o.getRowForY(t[1]);const d=[];let m=3;for(let e=0;e<4;e++){if(I[e][1]===I[m][1]){m=e;continue}const t=v.create(I[e],I[m]);c=Math.min(t.ymin,c),u=Math.max(t.ymax,u),void 0===d[t.ymin]&&(d[t.ymin]=[]),d[t.ymin].push(t),m=e}if(null==c||null==u||u-c>100)return null;let g=[];for(n=c;n<u;){null!=d[n]&&(g=g.concat(d[n])),h=1/0,a=-1/0;for(let e=g.length-1;e>=0;e--){const t=g[e];h=Math.min(h,t.getLeftCol()),a=Math.max(a,t.getRightCol())}if(h=Math.floor(h),a=Math.floor(a),n>=o.first[1]&&n<=o.last[1])if(r)if(o.size[0]<o.worldSize[0]){const e=Math.floor(a/o.worldSize[0]);for(let t=Math.floor(h/o.worldSize[0]);t<=e;t++)f.push(new _(n,Math.max(o.getFirstColumnForWorld(t),h),Math.min(o.getLastColumnForWorld(t),a)))}else f.push(new _(n,h,a));else h>o.last[0]||a<o.first[0]||(h=Math.max(h,o.first[0]),a=Math.min(a,o.last[0]),f.push(new _(n,h,a)));n+=1;for(let e=g.length-1;e>=0;e--){const t=g[e];t.ymax>=n?t.incrRow():g.splice(e,1)}}return l}getTileParentId(e){w.set(e);const t=this._infoByLevel[w.level],s=this._lodInfos.indexOf(t)-1;return s<0?null:(this._getTileIdAtLOD(w,this._lodInfos[s],w),w.id)}getTileResolution(e){const t=this._infoByLevel["object"==typeof e?e.level:e];return t?t.resolution:-1}getTileScale(e){const t=this._infoByLevel[e.level];return t?t.scale:-1}intersects(e,t){w.set(t);const s=this._infoByLevel[w.level],i=e.lodInfo;if(i.resolution>s.resolution){this._getTileIdAtLOD(w,i,w);const t=i.denormalizeCol(w.col,w.world);for(const s of e.spans)if(s.row===w.row&&s.colFrom<=t&&s.colTo>=t)return!0}if(i.resolution<s.resolution){const[t,o,l,r]=e.spans.reduce(((e,t)=>(e[0]=Math.min(e[0],t.row),e[1]=Math.max(e[1],t.row),e[2]=Math.min(e[2],t.colFrom),e[3]=Math.max(e[3],t.colTo),e)),[1/0,-1/0,1/0,-1/0]),n=s.denormalizeCol(w.col,w.world),h=i.getColumnForX(s.getXForColumn(n)),a=i.getRowForY(s.getYForRow(w.row)),c=i.getColumnForX(s.getXForColumn(n+1))-1,u=i.getRowForY(s.getYForRow(w.row+1))-1;return!(h>r||c<l||a>o||u<t)}const o=i.denormalizeCol(w.col,w.world);return e.spans.some((e=>e.row===w.row&&e.colFrom<=o&&e.colTo>=o))}normalizeBounds(t,s,i){if(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],this._wrap){const s=e(this.tileInfo.spatialReference),o=-i*(s.valid[1]-s.valid[0]);t[0]+=o,t[2]+=o}return t}getSmallestInfoForScale(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e];if(e>t[0])return this._infoByScale[t[0]];for(let s=1;s<t.length-1;s++)if(e>t[s]+1e-6)return this._infoByScale[t[s-1]];return this._infoByScale[t[t.length-1]]}getClosestInfoForScale(e){const t=this.scales;return this._infoByScale[e]||(e=t.reduce(((t,s)=>Math.abs(s-e)<Math.abs(t-e)?s:t),t[0])),this._infoByScale[e]}scaleToLevel(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e].level;for(let s=t.length-1;s>=0;s--)if(e<t[s])return s===t.length-1?this._infoByScale[t[t.length-1]].level:this._infoByScale[t[s]].level+(t[s]-e)/(t[s]-t[s+1]);return this._infoByScale[t[0]].level}scaleToZoom(e){return this.tileInfo.scaleToZoom(e)}_getTileIdAtLOD(e,t,s){const i=this._infoByLevel[s.level];return e.set(s),t.resolution<i.resolution?null:(t.resolution===i.resolution||(e.level=t.level,e.col=Math.floor(s.col*i.resolution/t.resolution+.01),e.row=Math.floor(s.row*i.resolution/t.resolution+.01)),e)}}const C=new Set,S=[],F=new Map,x=[0,0];let M=class extends i{constructor(e){super(e),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:e,process:t,strategy:s}=this;this._queue=new c({concurrency:e,process:(e,s)=>{const i=this._keyToItem.get(e);return t(i,{signal:s})},peeker:"scale-first"===s?e=>this._peekByScaleFirst(e):e=>this._peekByCenterFirst(e)})}destroy(){this.clear(),this._queue=l(this._queue)}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}abort(e){const t="string"==typeof e?e:e.id;this._queue.abort(t)}clear(){this._queue.clear(),this._keyToItem.clear()}has(e){return"string"==typeof e?this._keyToItem.has(e):this._keyToItem.has(e.id)}isOngoing(e){const t="string"==typeof e?e:e.id;return this.has(t)&&this._queue.isOngoing(t)}pause(){this._queue.pause()}push(e){const t=e.key.id;if(this._queue.has(t))return this._queue.get(t);const s=this._queue.push(t),i=()=>{this._keyToItem.delete(t)};return this._keyToItem.set(t,e),s.then(i,i),s}reset(){this._queue.reset()}resume(){this._queue.resume()}_peekByScaleFirst(e){if(!this.state)return e.values().next().value;const t=this.tileInfoView;let s=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY;e.forEach((e=>{const t=this._keyToItem.get(e),o=this.tileInfoView.getTileScale(t.key);F.has(o)||(F.set(o,[]),s=Math.max(o,s),i=Math.min(o,i)),F.get(o).push(t.key),C.add(o)}));let o=this.state.scale;var l,r;F.has(o)||(r=C,(l=S).length=0,r.forEach((e=>l.push(e))),S.sort(((e,t)=>e-t)),o=S.reduce(((e,t)=>Math.abs(t-o)<Math.abs(e-o)?t:e),S[0])),o=Math.min(o,s),o=Math.max(o,i);const n=F.get(o),h=t.getClosestInfoForScale(o),a=h.getColumnForX(this.state.center[0]),c=h.getRowForY(this.state.center[1]);return n.sort(((e,t)=>{const s=h.denormalizeCol(e.col,e.world),i=h.denormalizeCol(t.col,t.world);return Math.sqrt((a-s)*(a-s)+(c-e.row)*(c-e.row))-Math.sqrt((a-i)*(a-i)+(c-t.row)*(c-t.row))})),C.clear(),F.clear(),n[0].id}_peekByCenterFirst(e){if(!this.state)return e.values().next().value;const t=this.tileInfoView,s=this.state.center;let i,o=Number.POSITIVE_INFINITY;return e.forEach((e=>{const l=this._keyToItem.get(e);t.getTileCoords(x,l.key);const r=h(x,s);r<o&&(o=r,i=l.key)})),i.id}};s([r({constructOnly:!0})],M.prototype,"concurrency",void 0),s([r({constructOnly:!0})],M.prototype,"process",void 0),s([r()],M.prototype,"state",void 0),s([r({constructOnly:!0})],M.prototype,"strategy",void 0),s([r({constructOnly:!0})],M.prototype,"tileInfoView",void 0),M=s([n("esri.views.2d.tiling.TileQueue")],M);const z=M;class k{constructor(e,t,s){this.maxSize=e,this._tileInfoView=t,this._removedFunc=s,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const t=this._tilePerId.get(e);if(!t)return;const s=t.key.level,i=this._tileKeysPerLevel[s];B(this._tilePerId,e);for(let t=0;t<i.length;t++)if(i[t].id===e){i.splice(t,1);break}return t.visible=!0,t}add(e){e.visible=!1;const t=e.key,s=t.id;if(this._tilePerId.has(s))return;this._tilePerId.set(s,e);const i=t.level;this._tileKeysPerLevel[i]||(this._tileKeysPerLevel[i]=[]),this._tileKeysPerLevel[i].push(t)}prune(e,t,s){let i=this._tilePerId.size;if(i<=this.maxSize)return;let o=this._tileKeysPerLevel.length-1;for(;i>this.maxSize&&o>=0;)o!==e&&(i=this._pruneAroundCenterTile(i,t,s,o)),o--;i>this.maxSize&&(i=this._pruneAroundCenterTile(i,t,s,e))}_pruneAroundCenterTile(e,t,s,i){const o=this._tileKeysPerLevel[i];if(!o||0===o.length)return e;const{size:l,origin:r}=this._tileInfoView.tileInfo,n=s*l[0],h=s*l[1],c=[0,0],u=[0,0];for(o.sort(((e,s)=>(c[0]=r.x+n*(e.col+.5),c[1]=r.y-h*(e.row+.5),u[0]=r.x+n*(s.col+.5),u[1]=r.y-h*(s.row+.5),a(c,t)-a(u,t))));o.length>0;){const t=o.pop();if(this._removeTile(t.id),--e===this.maxSize)break}return e}_removeTile(e){const t=this._tilePerId.get(e);this._removedFunc&&t&&this._removedFunc(t),B(this._tilePerId,e)}}function B(e,t){e.delete(t)}const P=new t(0,0,0,0),b=new Map,R=[],L=[];class q{constructor(e){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=e.acquireTile,this.releaseTile=e.releaseTile,this.tileInfoView=e.tileInfoView,null!=e.resampling&&(this.resampling=e.resampling),e.cachePolicy&&(this.cachePolicy=e.cachePolicy),e.coveragePolicy&&(this.coveragePolicy=e.coveragePolicy),null!=e.buffer&&(this.buffer=e.buffer),e.cacheSize&&(this._tileCache=new k(e.cacheSize,this.tileInfoView,(e=>{this.releaseTile(e)})))}destroy(){this.tileIndex.clear()}update(e){const{resampling:t,tileIndex:s}=this,{scale:i,center:o,resolution:l}=e.state,{minScale:r,maxScale:n}=this.tileInfoView,h=!e.stationary&&i>this._previousScale;if(this._previousScale=i,!t&&(i>r||i<n))return this.tiles.length=0,void this.clear();const a=this.tileInfoView.getTileCoverage(e.state,this.buffer,this.resampling,this.coveragePolicy);if(!a)return this.tiles.length=0,void this.clear();const{spans:c,lodInfo:u}=a,{level:f}=u;this.tiles.length=0,s.forEach((e=>e.visible=!0));let d=0,m=0;if(c.length>0)for(const{row:e,colFrom:t,colTo:i}of c)for(let o=t;o<=i;o++){d++;const t=P.set(f,e,u.normalizeCol(o),u.getWorldForColumn(o)).id;let i=s.get(t);if(i)i.isReady?(b.set(t,i),m++):h||this._addParentTile(t,b);else{if(this._tileCache?.has(t)){if(i=this._tileCache.pop(t),this.tileIndex.set(t,i),i.isReady){b.set(t,i),m++;continue}}else i=this.acquireTile(P),this.tileIndex.set(t,i);h||this._addParentTile(t,b)}}const g=m===d;for(const[e,t]of s){if(b.has(e))continue;P.set(e);const s=this.tileInfoView.intersects(a,P),i="purge"===this.cachePolicy?P.level!==f:P.level>f;!s||!h&&g?!i&&s||R.push(t):t.isReady?i&&"purge"===this.cachePolicy&&this._hasReadyAncestor(P,f)?R.push(t):L.push(t):i&&R.push(t)}for(const e of L)e.isReady&&b.set(e.key.id,e);for(const e of R)this._tileCache?this._tileCache.add(e):this.releaseTile(e),s.delete(e.key.id);for(const e of b.values())this.tiles.push(e);for(const e of s.values())b.has(e.key.id)||(e.visible=!1);this._tileCache?.prune(f,o,l),p.pool.release(a),L.length=0,R.length=0,b.clear()}clear(){const{tileIndex:e}=this;for(const t of e.values())this.releaseTile(t);e.clear()}refresh(e){for(const t of this.tileIndex.values())this.tiles.includes(t)?e(t):R.push(t);for(const e of R)this.releaseTile(e),this.tileIndex.delete(e.key.id);this._tileCache?.clear()}updateCacheSize(e){this._tileCache&&(this._tileCache.maxSize=e)}_addParentTile(e,t){let s=e,i=null;for(;s=this.tileInfoView.getTileParentId(s),s;)if(this.tileIndex.has(s)){if(i=this.tileIndex.get(s),i?.isReady){t.has(i.key.id)||t.set(i.key.id,i);break}}else if(this._tileCache?.has(s)&&(i=this._tileCache.pop(s),this.tileIndex.set(s,i),i?.isReady)){t.has(i.key.id)||t.set(i.key.id,i);break}}_hasReadyAncestor(e,t){const s=u();this.tileInfoView.getTileBounds(s,e,!0);for(const i of this.tileIndex.values())if(i.isReady&&i.key.level>=t&&i.key.level<e.level){const e=u();if(this.tileInfoView.getTileBounds(e,i.key,!0),f(e,s))return!0}return!1}}export{T,z as a,q as b,p as c};
