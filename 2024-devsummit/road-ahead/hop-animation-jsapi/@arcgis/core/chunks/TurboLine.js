/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{C as t,J as e}from"./enums2.js";import{t as i}from"./definitions.js";function x(t,e){return t.x===e.x&&t.y===e.y}function r(t,e){return t.x=e.y,t.y=-e.x,t}function s(t,e){return t.x=-e.y,t.y=e.x,t}function n(t,e){return t.x=e.x,t.y=e.y,t}function y(t,e){return t.x=-e.x,t.y=-e.y,t}function o(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function h(t,e){return t.x*e.x+t.y*e.y}function l(t,e,i,x){return t.x=e.x*i+e.y*x,t.y=e.x*x-e.y*i,t}class _{constructor(t,e,i){this._writeVertex=t,this._writeTriangle=e,this._canUseThinTessellation=i,this._prevNormal={x:void 0,y:void 0},this._nextNormal={x:void 0,y:void 0},this._textureNormalLeft={x:0,y:1},this._textureNormalRight={x:0,y:-1},this._textureNormal={x:void 0,y:void 0},this._joinNormal={x:void 0,y:void 0},this._inner={x:void 0,y:void 0},this._outer={x:void 0,y:void 0},this._roundStart={x:void 0,y:void 0},this._roundEnd={x:void 0,y:void 0},this._startBreak={x:void 0,y:void 0},this._endBreak={x:void 0,y:void 0},this._innerPrev={x:void 0,y:void 0},this._innerNext={x:void 0,y:void 0},this._bevelStart={x:void 0,y:void 0},this._bevelEnd={x:void 0,y:void 0},this._bevelMiddle={x:void 0,y:void 0}}tessellate(t,e,r=this._canUseThinTessellation){!function(t){if(!t)return;const e=t.length;if(e<=1)return;let i=0;for(let r=1;r<e;r++)x(t[r],t[i])||++i===r||(t[i]=t[r]);t.length=i+1}(t),r&&e.halfWidth<i&&!e.offset?this._tessellateThin(t,e):this._tessellate(t,e)}_tessellateThin(t,e){if(t.length<2)return;const i=e.wrapDistance||65535;let x=e.initialDistance||0,r=!1,s=t[0].x,n=t[0].y;const y=t.length;for(let e=1;e<y;++e){r&&(r=!1,x=0);let y=t[e].x,o=t[e].y,h=y-s,l=o-n,_=Math.sqrt(h*h+l*l);if(h/=_,l/=_,x+_>i){r=!0;const t=(i-x)/_;_=i-x,y=(1-t)*s+t*y,o=(1-t)*n+t*o,--e}const a=this._writeVertex(s,n,0,0,h,l,l,-h,0,-1,x),c=this._writeVertex(s,n,0,0,h,l,-l,h,0,1,x);x+=_;const d=this._writeVertex(y,o,0,0,h,l,l,-h,0,-1,x),u=this._writeVertex(y,o,0,0,h,l,-l,h,0,1,x);this._writeTriangle(a,c,d),this._writeTriangle(c,d,u),s=y,n=o}}_tessellate(i,_){const a=i[0],c=i[i.length-1],d=x(a,c),u=d?3:2;if(i.length<u)return;const v=_.pixelCoordRatio,f=null!=_.capType?_.capType:t.BUTT,w=null!=_.joinType?_.joinType:e.MITER,T=null!=_.miterLimit?Math.min(_.miterLimit,4):2,g=null!=_.roundLimit?Math.min(_.roundLimit,1.05):1.05,m=null!=_.halfWidth?_.halfWidth:2,V=!!_.textured;let N,E,b,R=null;const U=this._prevNormal,k=this._nextNormal;let p=-1,M=-1;const B=this._joinNormal;let L,D;const S=this._textureNormalLeft,j=this._textureNormalRight,A=this._textureNormal;let O=-1,I=-1;const P=_.wrapDistance||65535;let W=_.initialDistance||0;const q=this._writeVertex,C=this._writeTriangle,Q=(t,e,i,x,r,s)=>{const n=q(E,b,L,D,i,x,t,e,r,s,W);return O>=0&&I>=0&&n>=0&&C(O,I,n),O=I,I=n,n};d&&(N=i[i.length-2],k.x=c.x-N.x,k.y=c.y-N.y,M=o(k),k.x/=M,k.y/=M);let X=!1;for(let x=0;x<i.length;++x){if(X&&(X=!1,W=0),N&&(U.x=-k.x,U.y=-k.y,p=M,W+p>P&&(X=!0)),X){const t=(P-W)/p;p=P-W,N={x:(1-t)*N.x+t*i[x].x,y:(1-t)*N.y+t*i[x].y},--x}else N=i[x];E=N.x,b=N.y;const _=x<=0&&!X,a=x===i.length-1;if(_||(W+=p),R=a?d?i[1]:null:i[x+1],R?(k.x=R.x-E,k.y=R.y-b,M=o(k),k.x/=M,k.y/=M):(k.x=void 0,k.y=void 0),!d){if(_){s(B,k),L=B.x,D=B.y,f===t.SQUARE&&(Q(-k.y-k.x,k.x-k.y,k.x,k.y,0,-1),Q(k.y-k.x,-k.x-k.y,k.x,k.y,0,1)),f===t.ROUND&&(Q(-k.y-k.x,k.x-k.y,k.x,k.y,-1,-1),Q(k.y-k.x,-k.x-k.y,k.x,k.y,-1,1)),f!==t.ROUND&&f!==t.BUTT||(Q(-k.y,k.x,k.x,k.y,0,-1),Q(k.y,-k.x,k.x,k.y,0,1));continue}if(a){r(B,U),L=B.x,D=B.y,f!==t.ROUND&&f!==t.BUTT||(Q(U.y,-U.x,-U.x,-U.y,0,-1),Q(-U.y,U.x,-U.x,-U.y,0,1)),f===t.SQUARE&&(Q(U.y-U.x,-U.x-U.y,-U.x,-U.y,0,-1),Q(-U.y-U.x,U.x-U.y,-U.x,-U.y,0,1)),f===t.ROUND&&(Q(U.y-U.x,-U.x-U.y,-U.x,-U.y,1,-1),Q(-U.y-U.x,U.x-U.y,-U.x,-U.y,1,1));continue}}let c,u,q=(z=k,-((J=U).x*z.y-J.y*z.x));if(Math.abs(q)<.01)h(U,k)>0?(B.x=U.x,B.y=U.y,q=1,c=Number.MAX_VALUE,u=!0):(s(B,k),q=1,c=1,u=!1);else{B.x=(U.x+k.x)/q,B.y=(U.y+k.y)/q,c=o(B);const t=(c-1)*m*v;u=c>4||t>p&&t>M}L=B.x,D=B.y;let C=w;switch(w){case e.BEVEL:c<1.05&&(C=e.MITER);break;case e.ROUND:c<g&&(C=e.MITER);break;case e.MITER:c>T&&(C=e.BEVEL)}switch(C){case e.MITER:if(Q(B.x,B.y,-U.x,-U.y,0,-1),Q(-B.x,-B.y,-U.x,-U.y,0,1),a)break;if(V){const t=X?0:W;O=this._writeVertex(E,b,L,D,k.x,k.y,B.x,B.y,0,-1,t),I=this._writeVertex(E,b,L,D,k.x,k.y,-B.x,-B.y,0,1,t)}break;case e.BEVEL:{const t=q<0;let e,i,x,o;if(t){const t=O;O=I,I=t,e=S,i=j}else e=j,i=S;if(u)x=t?s(this._innerPrev,U):r(this._innerPrev,U),o=t?r(this._innerNext,k):s(this._innerNext,k);else{const e=t?y(this._inner,B):n(this._inner,B);x=e,o=e}const h=t?r(this._bevelStart,U):s(this._bevelStart,U);Q(x.x,x.y,-U.x,-U.y,e.x,e.y);const _=Q(h.x,h.y,-U.x,-U.y,i.x,i.y);if(a)break;const c=t?s(this._bevelEnd,k):r(this._bevelEnd,k);if(u){const t=this._writeVertex(E,b,L,D,-U.x,-U.y,0,0,0,0,W);O=this._writeVertex(E,b,L,D,k.x,k.y,o.x,o.y,e.x,e.y,W),I=this._writeVertex(E,b,L,D,k.x,k.y,c.x,c.y,i.x,i.y,W),this._writeTriangle(_,t,I)}else{if(V){const t=this._bevelMiddle;t.x=(h.x+c.x)/2,t.y=(h.y+c.y)/2,l(A,t,-U.x,-U.y),Q(t.x,t.y,-U.x,-U.y,A.x,A.y),l(A,t,k.x,k.y),O=this._writeVertex(E,b,L,D,k.x,k.y,t.x,t.y,A.x,A.y,W),I=this._writeVertex(E,b,L,D,k.x,k.y,o.x,o.y,e.x,e.y,W)}else{const t=O;O=I,I=t}Q(c.x,c.y,k.x,k.y,i.x,i.y)}if(t){const t=O;O=I,I=t}break}case e.ROUND:{const t=q<0;let e,i;if(t){const t=O;O=I,I=t,e=S,i=j}else e=j,i=S;const x=t?y(this._inner,B):n(this._inner,B);let o,_;u?(o=t?s(this._innerPrev,U):r(this._innerPrev,U),_=t?r(this._innerNext,k):s(this._innerNext,k)):(o=x,_=x);const d=t?r(this._roundStart,U):s(this._roundStart,U),v=t?s(this._roundEnd,k):r(this._roundEnd,k),f=Q(o.x,o.y,-U.x,-U.y,e.x,e.y),w=Q(d.x,d.y,-U.x,-U.y,i.x,i.y);if(a)break;const T=this._writeVertex(E,b,L,D,-U.x,-U.y,0,0,0,0,W);u||this._writeTriangle(O,I,T);const g=y(this._outer,x),m=this._writeVertex(E,b,L,D,k.x,k.y,v.x,v.y,i.x,i.y,W);let N,R;const p=c>2;if(p){let e;c!==Number.MAX_VALUE?(g.x/=c,g.y/=c,e=h(U,g),e=(c*(e*e-1)+1)/e):e=-1,N=t?r(this._startBreak,U):s(this._startBreak,U),N.x+=U.x*e,N.y+=U.y*e,R=t?s(this._endBreak,k):r(this._endBreak,k),R.x+=k.x*e,R.y+=k.y*e}l(A,g,-U.x,-U.y);const M=this._writeVertex(E,b,L,D,-U.x,-U.y,g.x,g.y,A.x,A.y,W);l(A,g,k.x,k.y);const P=V?this._writeVertex(E,b,L,D,k.x,k.y,g.x,g.y,A.x,A.y,W):M,C=T,X=V?this._writeVertex(E,b,L,D,k.x,k.y,0,0,0,0,W):T;let J=-1,z=-1;if(p&&(l(A,N,-U.x,-U.y),J=this._writeVertex(E,b,L,D,-U.x,-U.y,N.x,N.y,A.x,A.y,W),l(A,R,k.x,k.y),z=this._writeVertex(E,b,L,D,k.x,k.y,R.x,R.y,A.x,A.y,W)),V?p?(this._writeTriangle(C,w,J),this._writeTriangle(C,J,M),this._writeTriangle(X,P,z),this._writeTriangle(X,z,m)):(this._writeTriangle(C,w,M),this._writeTriangle(X,P,m)):p?(this._writeTriangle(T,w,J),this._writeTriangle(T,J,z),this._writeTriangle(T,z,m)):(this._writeTriangle(T,w,M),this._writeTriangle(T,P,m)),u?(O=this._writeVertex(E,b,L,D,k.x,k.y,_.x,_.y,e.x,e.y,W),I=m):(O=V?this._writeVertex(E,b,L,D,k.x,k.y,_.x,_.y,e.x,e.y,W):f,this._writeTriangle(O,X,m),I=m),t){const t=O;O=I,I=t}break}}}var J,z}}export{_ as L};
