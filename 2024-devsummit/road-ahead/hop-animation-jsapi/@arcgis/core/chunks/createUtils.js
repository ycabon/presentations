/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import"../geometry.js";import{clone as t,e,i as o}from"../core/lang.js";import{k as n,g as a}from"./unitUtils.js";import{a as l}from"./vec3.js";import{c as r}from"./vec3f64.js";import s from"../geometry/Circle.js";import{simplify as i,distance as c}from"../geometry/geometryEngine.js";import{u as y,i as u,a as p}from"./coordsUtils.js";import{m as f}from"./surfaceCoordinateSystems.js";import x from"../geometry/Multipoint.js";import m from"../geometry/Polyline.js";import h from"../geometry/Polygon.js";import M from"../geometry/Point.js";function g(t,e){const o=new M({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(o.z=t[2]),o}function d(t,e){return new x({points:t,spatialReference:e})}function R(t,e,o){const n=new m({paths:t,spatialReference:e});return o&&y(n),n}function T(o,a,l,r=!0){const s=t(o);s.forEach((t=>{const o=t[0],n=t[t.length-1];e(o,n)&&1!==t.length||t.push(t[0])}));let c=new h({rings:s,spatialReference:a});return c.rings.forEach((t=>{u(t)||t.reverse()})),l&&y(c),r&&c.isSelfIntersecting&&n(a)&&(c=i(c)),c}function j(t,e,n){const a=e.mapToLocalMultiple(t),l=[],r={x:a[0].x,y:a[0].y},s=a[1].x,i=a[1].y,c=Math.round(s-r.x),y=Math.round(i-r.y),u=Math.max(Math.abs(c),Math.abs(y));if(n){const t={x:r.x+u,y:r.y+u},e={x:r.x-u,y:r.y-u};l.push(f(t.x,e.y),f(e.x,e.y),f(e.x,t.y),f(t.x,t.y))}else{const t={x:c>0?r.x+u:r.x-u,y:y>0?r.y+u:r.y-u};l.push(f(r.x,r.y),f(t.x,r.y),f(t.x,t.y),f(r.x,t.y))}return P(T([l.map((t=>e.localToMap(t))).filter(o)],e.spatialReference,e.doUnnormalization,!0),l,e)}function b(t,e,n){let a=e.mapToLocalMultiple(t);if(1===a.length){const t=48,e=a[0];a=[f(e.x-t,e.y+t),f(e.x+t,e.y-t),f(e.x+t,e.y-t),f(e.x-t,e.y+t)]}const l=[],r={x:a[0].x,y:a[0].y},s={x:a[1].x,y:a[1].y};if(n){const t=Math.round(s.x-r.x),e=Math.round(s.y-r.y);l.push(f(r.x-t,r.y-e),f(s.x,r.y-e),f(s.x,s.y),f(r.x-t,s.y))}else l.push(f(r.x,r.y),f(s.x,r.y),f(s.x,s.y),f(r.x,s.y));return P(T([l.map((t=>e.localToMap(t))).filter(o)],e.spatialReference,e.doUnnormalization,!0),l,e)}function P(t,e,o){const n=U(e[3],e[2],o),a=U(e[1],e[2],o),l=U(e[0],e[1],o),r=U(e[0],e[3],o);return{geometry:t,midpoints:null!=n&&null!=a&&null!=l&&null!=r?{top:n,right:a,bottom:l,left:r}:null}}function U(t,e,o){w[0]=t.x,w[1]=t.y,w[2]=0,I[0]=e.x,I[1]=e.y,I[2]=0,l(w,w,I,.5),z.x=w[0],z.y=I[1],z.z=I[2];const n=o.localToMap(z);return null!=n?g(n,o.spatialReference):null}const z=f(0,0,0),w=r(),I=r();function L(t,e,o,l){const r=e.mapToLocalMultiple(t);let i=null,y=null;if(o)i=r[0],y=r[1];else{const t=r[0],e=r[1],o=Math.round(e.x-t.x),n=Math.round(e.y-t.y),a=Math.max(Math.abs(o),Math.abs(n));i=f(o>0?t.x+a/2:t.x-a/2,n>0?t.y+a/2:t.y-a/2),y=f(Math.abs(o)>Math.abs(n)?i.x-a/2:i.x,Math.abs(o)>Math.abs(n)?i.y:i.y-a/2)}const u=e.localToMap(i),x=e.localToMap(y);if(null==u||null==x)return null;e.doUnnormalization&&p([[u,x]],e.spatialReference);const m=g(u,e.spatialReference),h=g(x,e.spatialReference),M=a(e.spatialReference);let d=0;if(n(e.spatialReference))d=M*c(m,h,null);else{const t=i.x-y.x,e=i.y-y.y;d=M*Math.sqrt(t*t+e*e)*(l||1)}const R=new s({center:m,radius:d,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:T(R.rings,R.spatialReference,!1),center:m,edge:h}}function v(t,e,n){const a=e.mapToLocalMultiple(t),l=a[0],r=a[1],s=Math.round(r.x-l.x),i=Math.round(r.y-l.y),c=f(n?l.x:l.x+s/2,n?l.y:l.y+i/2),y=n?s:s/2,u=n?i:i/2,p=[],x=2*Math.PI/60;function m(t){const e=Math.cos(t),o=Math.sin(t);return f(y*e+c.x,u*o+c.y)}for(let t=0;t<60;t++)p.push(m(t*x));p.push(p[0]);const{spatialReference:h,doUnnormalization:M}=e,d=T([p.map((t=>e.localToMap(t))).filter(o)],h,M,!1),R=e.localToMap(m(Math.PI/2)),j=e.localToMap(m(0)),b=e.localToMap(m(-Math.PI/2)),P=e.localToMap(m(Math.PI));return{geometry:d,midpoints:null!=R&&null!=j&&null!=b&&null!=P?{top:g(R,h),right:g(j,h),bottom:g(b,h),left:g(P,h)}:null}}export{j as a,v as b,L as c,b as d,T as e,R as f,d as g};
