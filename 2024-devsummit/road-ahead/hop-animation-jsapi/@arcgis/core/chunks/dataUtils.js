/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import"../geometry.js";import{h as t,R as e}from"../core/lang.js";import{L as n}from"./Logger.js";import{d as r}from"./mathUtils.js";import{throwIfAborted as o}from"../core/promiseUtils.js";import{j as l}from"./unitUtils.js";import i from"../geometry/Extent.js";const a=()=>n.getLogger("esri.views.2d.engine.flow.dataUtils");async function s(n,r,l,i){const s=performance.now(),f=function(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),l=new Array(2*o+1);let i=0;for(let t=-o;t<=o;t++){const e=Math.exp(-t*t/(r*r));l[t+o]=e,i+=e}for(let t=-o;t<=o;t++)l[t+o]/=i;const a=new Float32Array(t.length);for(let r=0;r<n;r++)for(let n=0;n<e;n++){let i=0,s=0;for(let a=-o;a<=o;a++){if(n+a<0||n+a>=e)continue;const c=l[a+o];i+=c*t[2*(r*e+(n+a))],s+=c*t[2*(r*e+(n+a))+1]}a[2*(r*e+n)]=i,a[2*(r*e+n)+1]=s}const s=new Float32Array(t.length);for(let t=0;t<e;t++)for(let r=0;r<n;r++){let i=0,c=0;for(let s=-o;s<=o;s++){if(r+s<0||r+s>=n)continue;const f=l[s+o];i+=f*a[2*((r+s)*e+t)],c+=f*a[2*((r+s)*e+t)+1]}s[2*(r*e+t)]=i,s[2*(r*e+t)+1]=c}return s}(e.data,e.width,e.height,t.smoothing);return t.interpolate?(t,r)=>{const o=Math.floor(t),l=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(l<0||l>=e.height)return[0,0];const i=t-o,a=r-l,s=o,c=l,f=o<e.width-1?o+1:o,u=l<e.height-1?l+1:l,h=n[2*(c*e.width+s)],d=n[2*(c*e.width+f)],m=n[2*(u*e.width+s)],w=n[2*(u*e.width+f)],p=n[2*(c*e.width+s)+1],g=n[2*(c*e.width+f)+1];return[(h*(1-a)+m*a)*(1-i)+(d*(1-a)+w*a)*i,(p*(1-a)+n[2*(u*e.width+s)+1]*a)*(1-i)+(g*(1-a)+n[2*(u*e.width+f)+1]*a)*i]}:(t,r)=>{const o=Math.round(t),l=Math.round(r);return o<0||o>=e.width||l<0||l>=e.height?[0,0]:[n[2*(l*e.width+o)],n[2*(l*e.width+o)+1]]}}(r,l),u=performance.now(),h=function(t,n,r,o){const l=[],i=new e,a=1/Math.max(t.lineCollisionWidth,1),s=Math.round(r*a),f=Math.round(o*a),u=new Int32Array(s*f);for(let t=0;t<u.length;t++)u[t]=-1;const h=[];for(let e=0;e<o;e+=t.lineSpacing)for(let n=0;n<r;n+=t.lineSpacing)h.push({x:n,y:e,sort:i.getFloat()});h.sort(((t,e)=>t.sort-e.sort));for(const{x:e,y:r}of h)if(i.getFloat()<t.density){const o=c(t,n,e,r,l.length,u,s,f,a);if(o.length<2)continue;l.push(o)}return l}(r,f,l.width,l.height),d=performance.now(),m=function(t,n){const r=new e,o=t.reduce(((t,e)=>t+e.length),0),l=new Float32Array(4*o),i=new Array(t.length);let a=0,s=0;for(const e of t){const t=a;for(const t of e)l[4*a]=t.x,l[4*a+1]=t.y,l[4*a+2]=t.t,l[4*a+3]=t.speed,a++;i[s++]={startVertex:t,numberOfVertices:e.length,totalTime:e[e.length-1].t,timeSeed:r.getFloat()}}return{lineVertices:l,lineDescriptors:i}}(h),w=performance.now(),p="Streamlines"===n?function(t,e){const{lineVertices:n,lineDescriptors:r}=t;let o=0,l=0;for(const t of r)o+=2*t.numberOfVertices,l+=6*(t.numberOfVertices-1);const i=new Float32Array(9*o),a=new Uint32Array(l);let s=0,c=0;function f(t,e,n,r,o,l,a,c){const f=9*s;let u=0;i[f+u++]=t,i[f+u++]=e,i[f+u++]=1,i[f+u++]=n,i[f+u++]=l,i[f+u++]=a,i[f+u++]=r/2,i[f+u++]=o/2,i[f+u++]=c,s++,i[f+u++]=t,i[f+u++]=e,i[f+u++]=-1,i[f+u++]=n,i[f+u++]=l,i[f+u++]=a,i[f+u++]=-r/2,i[f+u++]=-o/2,i[f+u++]=c,s++}for(const t of r){const{totalTime:e,timeSeed:r}=t;let o=null,l=null,i=null,u=null,h=null,d=null;for(let m=0;m<t.numberOfVertices;m++){const w=n[4*(t.startVertex+m)],p=n[4*(t.startVertex+m)+1],g=n[4*(t.startVertex+m)+2],y=n[4*(t.startVertex+m)+3];let x=null,M=null,A=null,I=null;if(m>0){x=w-o,M=p-l;const t=Math.sqrt(x*x+M*M);if(x/=t,M/=t,m>1){let t=x+h,e=M+d;const n=Math.sqrt(t*t+e*e);t/=n,e/=n;const r=Math.min(1/(t*x+e*M),10);t*=r,e*=r,A=-e,I=t}else A=-M,I=x;null!==A&&null!==I&&(f(o,l,i,A,I,e,r,y),a[c++]=s-2,a[c++]=s,a[c++]=s-1,a[c++]=s,a[c++]=s+1,a[c++]=s-1)}o=w,l=p,i=g,h=x,d=M,u=y}f(o,l,i,-d,h,e,r,u)}return{vertexData:i,indexData:a}}(m):function(t){const e=16,n=1,r=2,{lineVertices:o,lineDescriptors:l}=t;let i=0,a=0;for(const t of l){const e=t.numberOfVertices-1;i+=4*e*2,a+=6*e*2}const s=new Float32Array(i*e),c=new Uint32Array(a);let f,u,h,d,m,w,p,g,y,x,M,A,I,V,F=0,v=0;function D(t,o){let l=y+M,i=x+A;const a=Math.sqrt(l*l+i*i);l/=a,i/=a;const D=y*l+x*i;l/=D,i/=D;let b=M+I,S=A+V;const k=Math.sqrt(b*b+S*S);b/=k,S/=k;const L=M*b+A*S;b/=L,S/=L,function(t,o,l,i,a,c,f,u,h,d,m,w,p,g){const y=F*e;let x=0;for(const e of[n,r])for(const n of[1,2,3,4])s[y+x++]=t,s[y+x++]=o,s[y+x++]=l,s[y+x++]=i,s[y+x++]=f,s[y+x++]=u,s[y+x++]=h,s[y+x++]=d,s[y+x++]=e,s[y+x++]=n,s[y+x++]=p,s[y+x++]=g,s[y+x++]=a/2,s[y+x++]=c/2,s[y+x++]=m/2,s[y+x++]=w/2,F++}(f,u,h,d,-i,l,m,w,p,g,-S,b,t,o),c[v++]=F-8,c[v++]=F-7,c[v++]=F-6,c[v++]=F-7,c[v++]=F-5,c[v++]=F-6,c[v++]=F-4,c[v++]=F-3,c[v++]=F-2,c[v++]=F-3,c[v++]=F-1,c[v++]=F-2}function b(t,e,n,r,o,l){if(y=M,x=A,M=I,A=V,null==y&&null==x&&(y=M,x=A),null!=m&&null!=w){I=t-m,V=e-w;const n=Math.sqrt(I*I+V*V);I/=n,V/=n}null!=y&&null!=x&&D(o,l),f=m,u=w,h=p,d=g,m=t,w=e,p=n,g=r}function S(t,e){y=M,x=A,M=I,A=V,null==y&&null==x&&(y=M,x=A),null!=y&&null!=x&&D(t,e)}for(const t of l){f=null,u=null,h=null,d=null,m=null,w=null,p=null,g=null,y=null,x=null,M=null,A=null,I=null,V=null;const{totalTime:e,timeSeed:n}=t;for(let r=0;r<t.numberOfVertices;r++)b(o[4*(t.startVertex+r)],o[4*(t.startVertex+r)+1],o[4*(t.startVertex+r)+2],o[4*(t.startVertex+r)+3],e,n);S(e,n)}return{vertexData:s,indexData:c}}(m),g=performance.now();return t("esri-2d-profiler")&&(a().info("I.1","_createFlowFieldFromData (ms)",Math.round(u-s)),a().info("I.2","_getStreamlines (ms)",Math.round(d-u)),a().info("I.3","createAnimatedLinesData (ms)",Math.round(w-d)),a().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(g-w)),a().info("I.5","createFlowMesh (ms)",Math.round(g-s)),a().info("I.6","Mesh size (bytes)",p.vertexData.buffer.byteLength+p.indexData.buffer.byteLength)),await Promise.resolve(),o(i),p}function c(t,e,n,r,o,l,i,a,s){const c=[];let f=n,u=r,h=0,[d,m]=e(f,u);d*=t.velocityScale,m*=t.velocityScale;const w=Math.sqrt(d*d+m*m);let p,g;c.push({x:f,y:u,t:h,speed:w});for(let n=0;n<t.verticesPerLine;n++){let[n,r]=e(f,u);n*=t.velocityScale,r*=t.velocityScale;const d=Math.sqrt(n*n+r*r);if(d<t.minSpeedThreshold)return c;const m=n/d,w=r/d;if(f+=m*t.segmentLength,u+=w*t.segmentLength,h+=t.segmentLength/d,Math.acos(m*p+w*g)>t.maxTurnAngle)return c;if(t.collisions){const t=Math.round(f*s),e=Math.round(u*s);if(t<0||t>i-1||e<0||e>a-1)return c;const n=l[e*i+t];if(-1!==n&&n!==o)return c;l[e*i+t]=o}c.push({x:f,y:u,t:h,speed:d}),p=m,g=w}return c}function f(t,e){const n=e.pixels,{width:o,height:l}=e,i=new Float32Array(o*l*2),a=e.mask||new Uint8Array(o*l*2);if(e.mask||a.fill(255),"vector-uv"===t)for(let t=0;t<o*l;t++)i[2*t]=n[0][t],i[2*t+1]=-n[1][t];else if("vector-magdir"===t)for(let t=0;t<o*l;t++){const e=n[0][t],o=r(n[1][t]),l=Math.cos(o-Math.PI/2),a=Math.sin(o-Math.PI/2);i[2*t]=l*e,i[2*t+1]=a*e}return{data:i,mask:a,width:o,height:l}}async function u(e,n,r,o,s,c){const f=performance.now(),u=l(n.spatialReference);if(!u){const l=await h(e,n,r,o,s,c);return t("esri-2d-profiler")&&a().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-f)),t("esri-2d-profiler")&&a().info("I.9","Number of parts",1),l}const[d,m]=u.valid,w=m-d,p=Math.ceil(n.width/w),g=n.width/p,y=Math.round(r/p);let x=n.xmin;const M=[],A=performance.now();for(let t=0;t<p;t++){const t=new i({xmin:x,xmax:x+g,ymin:n.ymin,ymax:n.ymax,spatialReference:n.spatialReference});M.push(h(e,t,y,o,s,c)),x+=g}const I=await Promise.all(M);t("esri-2d-profiler")&&a().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-A)),t("esri-2d-profiler")&&a().info("I.9","Number of parts",I.length);const V={data:new Float32Array(r*o*2),mask:new Uint8Array(r*o),width:r,height:o};let F=0;for(const t of I){for(let e=0;e<t.height;e++)for(let n=0;n<t.width;n++)F+n>=r||(V.data[2*(e*r+F+n)]=t.data[2*(e*t.width+n)],V.data[2*(e*r+F+n)+1]=t.data[2*(e*t.width+n)+1],V.mask[e*r+F+n]=t.mask[e*t.width+n]);F+=t.width}return t("esri-2d-profiler")&&a().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-f)),V}async function h(t,e,n,r,o,l){const i={requestProjectedLocalDirections:!0,signal:l};if(null!=o&&(i.timeExtent=o),"imagery"===t.type){await t.load({signal:l});const o=t.rasterInfo.dataType,a=await t.fetchImage(e,n,r,i);return null==a?.pixelData?.pixelBlock?{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r}:f(o,a.pixelData.pixelBlock)}await t.load({signal:l});const a=t.serviceRasterInfo.dataType,s=await t.fetchPixels(e,n,r,i);return null==s?.pixelBlock?{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r}:f(a,s.pixelBlock)}export{s as c,u as l};
