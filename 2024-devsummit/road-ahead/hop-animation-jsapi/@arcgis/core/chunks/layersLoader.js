/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import t from"../core/Error.js";import{p as e}from"./arcgisLayerUrl.js";import{f as r}from"./fetchService.js";import{g as o,p as s,a,b as i,c as p,d as n,e as l,f as c,h as m,L as u}from"./portalLayers.js";import{populateGroupLayer as y}from"./layersCreator.js";import{l as j}from"./lazyLayerLoader.js";import f from"../portal/Portal.js";import{a as d}from"./jsonContext.js";import{h as g}from"./portalItemUtils.js";import{l as h}from"./styleUtils2.js";import{f as w}from"./requestPresets.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import"./ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"./persistableUrlUtils.js";import"../kernel.js";import"./associatedFeatureServiceUtils.js";import"../request.js";import"../portal/PortalItem.js";import"./assets.js";import"../core/Loadable.js";import"../core/Promise.js";import"./reader.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../portal/PortalItemResource.js";import"../portal/PortalRating.js";import"./locale.js";import"../portal/PortalGroup.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"./layerUtils2.js";import"../core/Collection.js";import"../core/Evented.js";import"./shared.js";import"./SimpleObservable.js";import"../geometry/projection.js";import"./vec3f64.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"./vec3.js";import"./common.js";import"../geometry/Polyline.js";import"./projectBuffer.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./asyncUtils.js";async function b(e,m){const j=e.instance.portalItem;if(j?.id)return await j.load(m),function(e){const r=e.instance.portalItem;if(!r?.type||!e.supportedTypes.includes(r.type))throw new t("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:r?.type,expectedType:e.supportedTypes.join(", ")})}(e),e.validateItem&&e.validateItem(j),async function(e,m){const j=e.instance,f=j.portalItem;if(!f)return;const{url:b,title:S}=f,v=d(f,"portal-item");if("group"===j.type)return async function(e,m,j){const f=e.portalItem;if(!e.sourceIsPortalItem)return;const{title:h,type:b}=f;if("Group Layer"===b){if(!g(f,"Map"))throw new t("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return async function(t){const e=t.portalItem,r=await e.fetchData("json");if(!r)return;const o=d(e,"web-map");t.read(r,o),await y(t,r,{context:o}),t.resourceReferences={portalItem:e,paths:o.readResourcePaths??[]}}(e)}return e.read({title:h},m),async function(e,m){let y;const{portalItem:j}=e;if(!j)return;const f=j.type,d=m.layerModuleTypeMap;switch(f){case"Feature Service":case"Feature Collection":y=d.FeatureLayer;break;case"Stream Service":y=d.StreamLayer;break;case"Scene Service":y=d.SceneLayer;break;default:throw new t("portal:unsupported-item-type-as-group",`The item type '${f}' is not supported as a 'IGroupLayer'`)}const g=new u;let[h,b]=await Promise.all([y(),P(m,g)]),S=()=>h;if("Feature Service"===f){const t=o(b)?.customParameters;b=j.url?await s(b,j.url,g):{};const n=a(b),l=i(b),c=p(b),m=[];if(n.length||l?.length){n.length&&m.push("SubtypeGroupLayer"),l?.length&&m.push("OrientedImageryLayer"),c?.length&&m.push("CatalogLayer");const t=[];for(const e of m){const r=d[e];t.push(r())}const e=await Promise.all(t),r=new Map;m.forEach(((t,o)=>{r.set(t,e[o])})),S=t=>t.layerType?r.get(t.layerType)??h:h}const u=await async function(t,e){const{layersJSON:o}=await r(t,e);if(!o)return null;const s=[...o.layers,...o.tables];return t=>s.find((e=>e.id===t.id))}(j.url,{customParameters:t,loadContext:g});return await I(e,S,b,u)}return"Scene Service"===f&&j.url&&(b=await n(j,b,g)),l(b)>0?await I(e,S,b):await async function(t,e){const{portalItem:r}=t;if(!r?.url)return;const o=await w(r.url);o&&I(t,e,{layers:o.layers?.map(c),tables:o.tables?.map(c)})}(e,S)}(e,j)}(j,v,e);b&&j.read({url:b},v);const L=new u,T=await P(e,L,m);return T&&j.read(T,v),j.resourceReferences={portalItem:f,paths:v.readResourcePaths??[]},"subtype-group"!==j.type&&j.read({title:S},v),h(j,v)}(e,m)}async function I(t,e,r,o){let s=r.layers||[];const a=r.tables||[];if("Feature Collection"===t.portalItem?.type?(s.forEach(((t,e)=>{t.id=e,"Table"===t?.layerDefinition?.type&&a.push(t)})),s=s.filter((t=>"Table"!==t?.layerDefinition?.type))):(s.reverse(),a.reverse()),s.forEach((s=>{const a=o?.(s);if(a||!o){const o=S(t,e(s),r,s,a);t.add(o)}})),a.length){const e=await j.FeatureLayer();a.forEach((s=>{const a=o?.(s);if(a||!o){const o=S(t,e,r,s,a);t.tables.add(o)}}))}}function S(t,e,r,o,s){const a=t.portalItem,i={portalItem:a.clone(),layerId:o.id};null!=o.url&&(i.url=o.url);const p=new e(i);if("sourceJSON"in p&&(p.sourceJSON=s),"subtype-group"!==p.type&&"catalog"!==p.type&&(p.sublayerTitleMode="service-name"),"Feature Collection"===a.type){const t={origin:"portal-item",portal:a.portal||f.getDefault()};p.read(o,t);const e=r.showLegend;null!=e&&p.read({showLegend:e},t)}return p}async function P(t,r,s){if(!1===t.supportsData)return;const i=t.instance,p=i.portalItem;if(!p)return;let n=null;try{n=await p.fetchData("json",s)}catch(t){}if(function(t){return"stream"!==t.type&&"layerId"in t}(i)){let t=null;const s=await async function(t,r,s){if(r?.layers&&r?.tables)return l(r);const a=e(t.url);if(!a)return 1;const i=await s.fetchServiceMetadata(a.url.path,{customParameters:o(r)?.customParameters}).catch((()=>null));return(r?.layers?.length??i?.layers?.length??0)+(r?.tables?.length??i?.tables?.length??0)}(p,n,r);if((n?.layers||n?.tables)&&s>0){if(null==i.layerId){const t=a(n);i.layerId="subtype-group"===i.type?t?.[0]:m(n)}t=function(t,e){const{layerId:r}=e,o=t.layers?.find((t=>t.id===r))||t.tables?.find((t=>t.id===r));return o&&function(t,e){return!("feature"===e.type&&"layerType"in t&&"SubtypeGroupLayer"===t.layerType||"subtype-group"===e.type&&!("layerType"in t))}(o,e)?o:null}(n,i),t&&null!=n.showLegend&&(t.showLegend=n.showLegend)}return s>1&&"sublayerTitleMode"in i&&"service-name"!==i.sublayerTitleMode&&(i.sublayerTitleMode="item-title-and-service-name"),t}return n}export{b as load};
