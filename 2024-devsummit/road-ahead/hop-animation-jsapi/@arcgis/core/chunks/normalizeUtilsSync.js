/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{isSerializable as t}from"../core/JSONSupport.js";import{c as i}from"./aaBoundingRect.js";import{c as s}from"./extentUtils.js";import{c as n}from"./coordsUtils.js";import{isPoint as e,isMultipoint as h,isExtent as o,isPolygon as r,isPolyline as u}from"../geometry/support/jsonUtils.js";import{c as m,u as x,o as _}from"./normalizeUtilsCommon.js";import{j as l,b as a}from"./unitUtils.js";function c(t){return f(t,!0)}function p(t){return f(t,!1)}function f(i,n){if(null==i)return null;const c=i.spatialReference,p=l(c),f=t(i)?i.toJSON():i;if(!p)return f;const I=a(c)?102100:4326,C=m[I].maxX,S=m[I].minX;if(e(f))return d(f,C,S);if(h(f))return f.points=f.points.map((t=>d(t,C,S))),f;if(o(f))return function(t,i){if(!i)return t;const s=function(t,i){const s=[],{ymin:n,ymax:e,xmin:h,xmax:o}=t,r=t.xmax-t.xmin,[u,m]=i.valid,{x,frameId:_}=y(t.xmin,i),{x:l,frameId:a}=y(t.xmax,i),c=x===l&&r>0;if(r>2*m){const t={xmin:h<o?x:l,ymin:n,xmax:m,ymax:e},i={xmin:u,ymin:n,xmax:h<o?l:x,ymax:e},r={xmin:0,ymin:n,xmax:m,ymax:e},c={xmin:u,ymin:n,xmax:0,ymax:e},p=[],f=[];g(t,r)&&p.push(_),g(t,c)&&f.push(_),g(i,r)&&p.push(a),g(i,c)&&f.push(a);for(let t=_+1;t<a;t++)p.push(t),f.push(t);s.push(new O(t,[_]),new O(i,[a]),new O(r,p),new O(c,f))}else x>l||c?s.push(new O({xmin:x,ymin:n,xmax:m,ymax:e},[_]),new O({xmin:u,ymin:n,xmax:l,ymax:e},[a])):s.push(new O({xmin:x,ymin:n,xmax:l,ymax:e},[_]));return s}(t,i).map((t=>t.extent));return s.length<2?s[0]||t:s.length>2?(t.xmin=i.valid[0],t.xmax=i.valid[1],t):{rings:s.map((t=>[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]))}}(f,p);if(r(f)||u(f)){const t=s(P,f),i={xmin:t[0],ymin:t[1],xmax:t[2],ymax:t[3]},e=_(i.xmin,S)*(2*C),h=0===e?f:x(f,e);return i.xmin+=e,i.xmax+=e,i.xmax>C?v(h,C,n):i.xmin<S?v(h,S,n):h}return f}function d(t,i,s){if(Array.isArray(t)){const n=t[0];if(n>i){const s=_(n,i);t[0]=n+s*(-2*i)}else if(n<s){const i=_(n,s);t[0]=n+i*(-2*s)}}else{const n=t.x;if(n>i){const s=_(n,i);t.x+=s*(-2*i)}else if(n<s){const i=_(n,s);t.x+=i*(-2*s)}}return t}function y(t,i){const[s,n]=i.valid,e=2*n;let h,o=0;return t>n?(h=Math.ceil(Math.abs(t-n)/e),t-=h*e,o=h):t<s&&(h=Math.ceil(Math.abs(t-s)/e),t+=h*e,o=-h),{x:t,frameId:o}}function g(t,i){const{xmin:s,ymin:n,xmax:e,ymax:h}=i;return I(t,s,n)&&I(t,s,h)&&I(t,e,h)&&I(t,e,n)}function I(t,i,s){return i>=t.xmin&&i<=t.xmax&&s>=t.ymin&&s<=t.ymax}function v(t,i,s=!0){const e=!u(t);if(e&&n(t),s)return(new C).cut(t,i);const h=e?t.rings:t.paths,o=e?4:2,r=h.length,m=-2*i;for(let t=0;t<r;t++){const i=h[t];if(i&&i.length>=o){const t=[];for(const s of i)t.push([s[0]+m,s[1]]);h.push(t)}}return e?t.rings=h:t.paths=h,t}class O{constructor(t,i){this.extent=t,this.frameIds=i}}const P=i();class C{constructor(){this._linesIn=[],this._linesOut=[]}cut(t,i){let s;if(this._xCut=i,t.rings)this._closed=!0,s=t.rings,this._minPts=4;else{if(!t.paths)return null;this._closed=!1,s=t.paths,this._minPts=2}for(const t of s){if(!t||t.length<this._minPts)continue;let i=!0;for(const s of t)i?(this.moveTo(s),i=!1):this.lineTo(s);this._closed&&this.close()}this._pushLineIn(),this._pushLineOut(),s=[];for(const t of this._linesIn)t&&t.length>=this._minPts&&s.push(t);const n=-2*this._xCut;for(const t of this._linesOut)if(t&&t.length>=this._minPts){for(const i of t)i[0]+=n;s.push(t)}return this._closed?t.rings=s:t.paths=s,t}moveTo(t){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(t[0]),this._moveTo(t[0],t[1],this._prevSide),this._prevPt=t,this._firstPt=t}lineTo(t){const i=this._side(t[0]);if(i*this._prevSide==-1){const s=this._intersect(this._prevPt,t);this._lineTo(this._xCut,s,0),this._prevSide=0,this._lineTo(t[0],t[1],i)}else this._lineTo(t[0],t[1],i);this._prevSide=i,this._prevPt=t}close(){const t=this._firstPt,i=this._prevPt;t[0]===i[0]&&t[1]===i[1]||this.lineTo(t),this._checkClosingPt(this._lineIn),this._checkClosingPt(this._lineOut)}_moveTo(t,i,s){this._closed?(this._lineIn.push([s<=0?t:this._xCut,i]),this._lineOut.push([s>=0?t:this._xCut,i])):(s<=0&&this._lineIn.push([t,i]),s>=0&&this._lineOut.push([t,i]))}_lineTo(t,i,s){this._closed?(this._addPolyVertex(this._lineIn,s<=0?t:this._xCut,i),this._addPolyVertex(this._lineOut,s>=0?t:this._xCut,i)):s<0?(0===this._prevSide&&this._pushLineOut(),this._lineIn.push([t,i])):s>0?(0===this._prevSide&&this._pushLineIn(),this._lineOut.push([t,i])):this._prevSide<0?(this._lineIn.push([t,i]),this._lineOut.push([t,i])):this._prevSide>0&&(this._lineOut.push([t,i]),this._lineIn.push([t,i]))}_addPolyVertex(t,i,s){const n=t.length;n>1&&t[n-1][0]===i&&t[n-2][0]===i?t[n-1][1]=s:t.push([i,s])}_checkClosingPt(t){const i=t.length;i>3&&t[0][0]===this._xCut&&t[i-2][0]===this._xCut&&t[1][0]===this._xCut&&(t[0][1]=t[i-2][1],t.pop())}_side(t){return t<this._xCut?-1:t>this._xCut?1:0}_intersect(t,i){const s=(this._xCut-t[0])/(i[0]-t[0]);return t[1]+s*(i[1]-t[1])}_pushLineIn(){this._lineIn&&this._lineIn.length>=this._minPts&&this._linesIn.push(this._lineIn),this._lineIn=[]}_pushLineOut(){this._lineOut&&this._lineOut.length>=this._minPts&&this._linesOut.push(this._lineOut),this._lineOut=[]}}export{p as a,c as n};
