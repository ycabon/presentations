/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{b as t}from"./maybe.js";import n from"../layers/support/PixelBlock.js";import{g as s}from"./pixelRangeUtils.js";import{a as e}from"./stretchRendererUtils.js";function i(t){return["u8","s8"].includes(t.pixelType)&&null!=t.statistics?.[0]?.min&&null!=t.statistics[0]?.max&&1===t.bandCount}function a(t,n){const{attributeTable:s,bandCount:e}=t;return!((null!=s||!i(t))&&(null==s||e>1||n&&null==s.fields.find((t=>t.name.toLowerCase()===n.toLowerCase()))))}function o(t){const{bandCount:n,dataType:s,pixelType:e}=t;return"elevation"===s||"generic"===s&&1===n&&("s16"===e||"s32"===e||"f32"===e||"f64"===e)}function r(t,n=!1){const{bandCount:s,colormap:e,pixelType:i}=t;return 1===s&&(!!e?.length||!n&&"u8"===i)}function l(t,n=!1){const{attributeTable:s,bandCount:e}=t;return 1===e&&(!n||null!=s||null!=t.histograms)}function u(t){const{dataType:n}=t;return"vector-uv"===n||"vector-magdir"===n}function f(t){const{dataType:n}=t;return"vector-uv"===n||"vector-magdir"===n}const c=1,m=[.299,.587,.114];function h(t,n=256){n=Math.min(n,256);const{size:s,counts:e}=t,i=new Uint8Array(s),a=e.reduce(((t,s)=>t+s/n),0);let o=0,r=0,l=0,u=a;for(let t=0;t<s;t++)if(l+=e[t],!(t<s-1&&l+e[t+1]<u)){for(;o<n-1&&u<l;)o++,u+=a;for(let n=r;n<=t;n++)i[n]=o;r=t+1}for(let t=r;t<s;t++)i[t]=n-1;return i}function g(t){const{minCutOff:n,maxCutOff:s,gamma:e,pixelType:i,rounding:a}=t,o=t.outMin||0,r=t.outMax||255;if(!["u8","u16","s8","s16"].includes(i))return null;const l=n.length;let u,f,c=0;"s8"===i?c=-127:"s16"===i&&(c=-32767);let m=256;["u16","s16"].includes(i)&&(m=65536);const h=[],g=[],p=r-o;for(u=0;u<l;u++)g[u]=s[u]-n[u],h[u]=0===g[u]?0:p/g[u];let x;const M=[];let y,b,v;if(e&&e.length>=l){const t=C(l,e);for(u=0;u<l;u++){for(v=[],f=0;f<m;f++)if(0!==g[u])if(y=f+c,x=(y-n[u])/g[u],b=1,e[u]>1&&(b-=(1/p)**(x*t[u])),y<s[u]&&y>n[u]){const t=b*p*x**(1/e[u])+o;v[f]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}else y>=s[u]?v[f]=r:v[f]=o;else v[f]=o;M[u]=v}}else for(u=0;u<l;u++){for(v=[],f=0;f<m;f++)if(y=f+c,y<=n[u])v[f]=o;else if(y>=s[u])v[f]=r;else{const t=(y-n[u])*h[u]+o;v[f]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}M[u]=v}if(null!=t.contrastOffset){const n=d(t.contrastOffset,t.brightnessOffset);for(u=0;u<l;u++)for(v=M[u],f=0;f<m;f++)v[f]=n[v[f]]}return{lut:M,offset:c}}function d(t,n){const s=Math.min(Math.max(t,-100),100),e=Math.min(Math.max(n??0,-100),100);let i=0,a=0;const o=new Uint8Array(256);for(i=0;i<256;i++)s>0&&s<100?a=(200*i-25500+510*e)/(2*(100-s))+128:s<=0&&s>-100?a=(200*i-25500+510*e)*(100+s)/2e4+128:100===s?(a=200*i-25500+256*(100-s)+510*e,a=a>0?255:0):-100===s&&(a=128),o[i]=a>255?255:a<0?0:a;return o}function p(t,n,s){const e=[];for(let i=0;i<n.length;i++){let a=0,o=0,r=0;"min"in n[i]?({min:a,max:o,avg:r}=n[i]):[a,o,r]=n[i];let l=r??0;"u8"!==t&&(l=255*(l-a)/(o-a)),s&&(l*=m[i]),e.push(x(l))}return e}function x(t){if(t<=0||t>=255)return c;let n=0;150!==t&&(n=t<=150?45*Math.cos(.01047*t):17*Math.sin(.021*t));const s=t+n,e=Math.log(t/255),i=Math.log(s/255);if(0===i)return c;const a=e/i;return isNaN(a)?c:Math.min(9.9,Math.max(.01,a))}function M(t){const{pixels:n,mask:s,pixelType:e,bandMasks:i}=t,a=n.map(((t,n)=>function(t,n,s,e){let i=1/0,a=-1/0,o=0,r=0,l=0,u=0;const f=t.length,c=new Map,m=[];for(let s=0;s<f;s++){const e=t[s];if(!n||n[s]){m.push(e);const t=(c.get(e)??0)+1;c.set(e,t),t>u&&(u=t,l=e),i=e<i?e:i,a=e>a?e:a,o+=e,r++}}if(0===r)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const h=o/r;let g=0;for(let s=0;s<f;s++)n&&!n[s]||(g+=(t[s]-h)**2);const d=n?n.filter((t=>t)).length:f,p=d<=1?0:Math.sqrt(g/(d-1));m.sort(((t,n)=>t-n));const x=r>>>1,M={min:i,max:a,avg:h,stddev:p,mode:l,median:r%2?m[Math.floor(x)]:(m[x-1]+m[x])/2};if(["u8","s8","u4","u2","u1"].includes(s)){const s=a-i+1,e=new Uint32Array(s);for(let s=0;s<f;s++)n&&!n[s]||e[t[s]-i]++;return{statistics:M,histogram:{min:i-.5,max:a+.5,size:s,counts:e}}}const y=new Uint32Array(256),b=(a-i)/256;if(0===b)return{statistics:M,histogram:{min:i,max:a,size:1,counts:new Uint32Array(1).fill(r)}};const v=new Uint32Array(257);for(let s=0;s<f;s++)n&&!n[s]||v[Math.floor((t[s]-i)/b)]++;for(let t=0;t<255;t++)y[t]=v[t];return y[255]=v[255]+v[256],{statistics:M,histogram:{min:i,max:a,size:256,counts:y}}}(t,i?.[n]??s,e)));return{statistics:a.map((({statistics:t})=>t)),histograms:a.map((({histogram:t})=>t))}}function y(t){if(!t?.pixels?.length)return null;const{pixels:n,mask:s,bandMasks:e,pixelType:i}=t,a=t.width*t.height,o=n.length,r=[],l=[],u=256;let f,c,m,h;for(let g=0;g<o;g++){m=new Uint32Array(u);const o=n[g],d=e?.[g]??s;if("u8"===i){if(f=255,c=0,d){for(let t=0;t<a;t++)if(d[t]){const n=o[t];f=n<f?n:f,c=n>c?n:c,m[n]++}}else for(let t=0;t<a;t++){const n=o[t];f=n<f?n:f,c=n>c?n:c,m[n]++}m=m.slice(f,c+1)}else{let n=!1;t.statistics||(t.updateStatistics(),n=!0);const s=t.statistics;f=s[g].minValue,c=s[g].maxValue;const e=(c-f)/u;if(0===e){!s||t.validPixelCount||n||t.updateStatistics();const e=(t.validPixelCount||t.width*t.height)/u;for(let t=0;t<u;t++)m[t]=Math.round(e*(t+1))-Math.round(e*t)}else{h=new Uint32Array(257);for(let t=0;t<a;t++)d&&!d[t]||h[Math.floor((o[t]-f)/e)]++;for(let t=0;t<255;t++)m[t]=h[t];m[255]=h[255]+h[256]}}const p="u8"===i?f-.5:f,x="u8"===i?c+.5:c;r.push({min:p,max:x,size:m.length,counts:m});let M=0,y=0,b=0;for(let t=0;t<m.length;t++)M+=m[t],y+=t*m[t];const v=y/M;for(let t=0;t<m.length;t++)b+=m[t]*(t-v)**2;const C=Math.sqrt(b/(M-1)),w=(x-p)/m.length,k=(v+("u8"===i?0:.5))*w+f,z=C*w;l.push({min:f,max:c,avg:k,stddev:z})}return{statistics:l,histograms:r}}function b(t){const n=[];for(let s=0;s<t.length;s++){const{min:e,max:i,size:a,counts:o}=t[s];let r=0,l=0;for(let t=0;t<a;t++)r+=o[t],l+=t*o[t];const u=l/r;let f=0;for(let t=0;t<a;t++)f+=o[t]*(t-u)**2;const c=(i-e)/a,m=(u+.5)*c+e,h=Math.sqrt(f/(r-1))*c;n.push({min:e,max:i,avg:m,stddev:h})}return n}function v(n,i){const{pixelBlock:a,bandIds:o,returnHistogramLut:r,rasterInfo:l}=i;let u=null,f=null,c=n.stretchType;if("number"==typeof c&&(c=e[c]),n.dra)if("minMax"===c&&a?.statistics)u=a.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=y(a);u=null!=t?t.statistics:null,f=null!=t?t.histograms:null}else u=n.statistics?.length?n.statistics:l.statistics,f="histograms"in n?n.histograms:void 0,f||(f=l.histograms);"percentClip"!==c&&"histogramEqualization"!==c||f?.length||(c="minMax");const m=u?.length||f?.length||l.bandCount,g=[],d=[];let p,x,M,b,v,C,w,k,z;u&&!Array.isArray(u[0])&&(u=u.map((t=>[t.min,t.max,t.avg,t.stddev])));const[T,O]=s(l.pixelType);if(!u?.length){for(u=[],k=0;k<m;k++)u.push([T,O,1,1]);"standardDeviation"===c&&(c="minMax")}switch(c){case"none":for(k=0;k<m;k++)g[k]=T,d[k]=O;break;case"minMax":for(k=0;k<m;k++){const t=u[k];g[k]=t[0],d[k]=t[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:t=2}=n;for(k=0;k<m;k++){const n=u[k];g[k]=n[2]-t*n[3],d[k]=n[2]+t*n[3],g[k]<n[0]&&(g[k]=n[0]),d[k]>n[1]&&(d[k]=n[1])}}break;case"histogramEqualization":for(t(f),k=0;k<m;k++)g[k]=f[k].min,d[k]=f[k].max;break;case"percentClip":for(t(f),k=0;k<f.length;k++){for(p=f[k],v=new Uint32Array(p.size),b=[...p.counts],b.length>=20&&(b[0]=b[1]=b[2]=b[b.length-1]=b[b.length-2]=0),M=0,x=(p.max-p.min)/p.size,w=-.5===p.min&&1===x?.5:0,z=0;z<p.size;z++)M+=b[z],v[z]=M;for(C=(n.minPercent||0)*M/100,g[k]=p.min+w,z=0;z<p.size;z++)if(v[z]>C){g[k]=p.min+x*(z+w);break}for(C=(1-(n.maxPercent||0)/100)*M,d[k]=p.max+w,z=p.size-2;z>=0;z--)if(v[z]<C){d[k]=p.min+x*(z+2-w);break}if(d[k]<g[k]){const t=g[k];g[k]=d[k],d[k]=t}}break;default:for(k=0;k<m;k++){const t=u[k];g[k]=t[0],d[k]=t[1]}}let A,U,q;return"histogramEqualization"===c?(t(f),U=f[0].size||256,A=0,r&&(q=f.map((t=>h(t))))):(U=n.max||255,A=n.min||0),function(t,n){if(null==n||0===n.length)return t;const s=Math.max.apply(null,n),{minCutOff:e,maxCutOff:i,outMin:a,outMax:o,histogramLut:r}=t;return e.length===n.length||e.length<=s?t:{minCutOff:n.map((t=>e[t])),maxCutOff:n.map((t=>i[t])),histogramLut:r?n.map((t=>r[t])):null,outMin:a,outMax:o}}({minCutOff:g,maxCutOff:d,outMax:U,outMin:A,histogramLut:q},o)}function C(t,n){const s=new Float32Array(t);for(let e=0;e<t;e++)n[e]>1?n[e]>2?s[e]=6.5+(n[e]-2)**2.5:s[e]=6.5+100*(2-n[e])**4:s[e]=1;return s}function w(t,s){if(!t?.pixels?.length)return t;const{mask:e,bandMasks:i,width:a,height:o,pixels:r}=t,{minCutOff:l,maxCutOff:u,gamma:f}=s,c=s.outMin||0,m=s.outMax||255,h=a*o,g=s.outputPixelType||"u8",d=t.pixels.map((()=>n.createEmptyBand(g,h))),p=d.length,x=m-c,M=[],y=[];for(let t=0;t<p;t++)y[t]=u[t]-l[t],M[t]=0===y[t]?0:x/y[t];const b=g.startsWith("u")||g.startsWith("s"),v=f&&f.length>=p,w=!!s.isRenderer;if(v){const t=C(p,f);for(let n=0;n<p;n++){const s=i?.[n]??e;for(let e=0;e<h;e++)if(null==s||s[e]){if(0===y[n]){d[n][e]=c;continue}const s=r[n][e],i=(s-l[n])/y[n];let a=1;if(f[n]>1&&(a-=(1/x)**(i*t[n])),s<u[n]&&s>l[n]){const t=a*x*i**(1/f[n])+c;d[n][e]=w?Math.floor(t):b?Math.round(t):t}else s>=u[n]?d[n][e]=m:d[n][e]=c}}}else for(let t=0;t<p;t++){const n=i?.[t]??e;for(let s=0;s<h;s++)if(null==n||n[s]){const n=r[t][s];if(n<u[t]&&n>l[t]){const e=(n-l[t])*M[t]+c;d[t][s]=w?Math.floor(e):b?Math.round(e):e}else n>=u[t]?d[t][s]=m:d[t][s]=c}}const k=new n({width:a,height:o,mask:e,bandMasks:i,pixels:d,pixelType:g});return k.updateStatistics(),k}export{r as a,a as b,l as c,o as d,f as e,i as f,M as g,y as h,u as i,b as j,v as k,g as l,p as m,h as n,d as o,C as p,w as s};
