/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import s from"../request.js";import"../core/lang.js";import{L as e}from"./Logger.js";import{throwIfAborted as t,after as r,throwIfAbortError as o}from"../core/promiseUtils.js";import{M as a}from"../core/scheduling.js";import{join as n,parseData as i}from"../core/urlUtils.js";import{a as c}from"./uuid.js";import{e as p,b as l,a as u,S as m,c as f}from"./External.js";import{U as d,N as y,B as g,a as w,b as h,C as j,c as b,d as P,e as T}from"./uploadAssetErrors.js";import{m as A,e as U,u as S,a as F,s as E}from"./progressUtils.js";import{i as N}from"./arcgisLayerUrl.js";import{d as x,a as D,b as v}from"./infoFor3D.js";import"../config.js";import"../kernel.js";import"../core/Error.js";import"../core/JSONSupport.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import"./ObservableBase.js";import"./persistableUrlUtils.js";const I=1e6,O=20*I,k=2e9,B=3;async function q(s,e,r){const o=s.length;if(!o)return r?.onProgress?.(1),[];const a=A(o,r?.onProgress,"uploadAssets");return Promise.all(s.map(((s,o)=>async function(s,{layer:e,ongoingUploads:r},o){const a=r.get(s);if(a)return a;if(!function(s){return!!s.infoFor3D&&!!s.url}(e))throw new d;if(function(s,e){const{parsedUrl:t}=e;return null!=t&&s.metadata.externalSources.some((s=>p(s,t)))}(s,e))return o?.onProgress?.(1),s;const i=async function(s,e,r){const{metadata:o}=s,{displaySource:a}=o,i=C(a?.source,e),p=!!i,l=o.externalSources.length>0,f=p?async function(s,e,t){return{source:await R(s,e,t),original:!0}}(i,e,r):l?async function(s,e,t){const r=$(e),{externalSources:o}=s.metadata,a=function(s,e){for(const t of s){const s=C(t.source,e);if(s)return s}return null}(o,e);if(!a)throw new y;const i=A(S.uploadConvertibleSource,t?.onProgress,"uploadConvertibleSource"),c=await R(a,e,{onProgress:i.makeOnProgress("uploadEditSource")});s.addExternalSources([{source:c,original:!0}]);const p=a.reduce(((s,{asset:e})=>e instanceof File?s+e.size:s),0),l=i.simulate("serviceAssetsToGlb",F(p));try{const s=await async function(s,e,t){const r=s.map((({assetName:s,parts:e})=>({assetName:s,assetHash:e[0].partHash}))),o=e.capabilities?.operations.supportsAsyncConvert3D,a={f:"json",assets:JSON.stringify(r),transportType:"esriTransportTypeUrl",targetFormat:t,async:o},i=n(e.parsedUrl.path,"convert3D");let c;try{c=(await(o?H:M)(i,{query:a,responseType:"json",timeout:0})).data}catch(s){throw new j}const{supportedFormats:p}=e.infoFor3D;return c.assets.map((s=>{const e=D(s.contentType,p);if(!e)throw new h(e);return new u(s.assetName,s.contentType,[new m(s.assetURL,s.assetHash)])}))}(c,e,r);return{source:s}}finally{l.remove()}}(s,e,r):async function(s,e,r){const o=A(S.uploadLocalMesh,r?.onProgress,"uploadLocalMesh"),a=async function(s,e,r){const o=$(e),a=await s.load(r),n=await a.toBinaryGLTF({ignoreLocalTransform:!0});t(r);const i=await n.buffer();return t(r),{blob:new Blob([i.data],{type:i.type}),assetName:`${c()}.glb`,assetType:o}}(s,e,{...r,onProgress:o.makeOnProgress("meshToAssetBlob")});return{source:await z([a],e,{...r,onProgress:o.makeOnProgress("uploadAssetBlobs")}),extent:s.extent.clone(),original:!0}}(s,e,r),d=await f;return t(r),s.addExternalSources([d]),s}(s,e,o);r.set(s,i);try{await i}finally{r.delete(s)}return s}(s,e,{...r,onProgress:a.makeOnProgress(o)}))))}function C(s,e){if(!s)return null;const{infoFor3D:{supportedFormats:t,editFormats:r}}=e,o=f(s),a=new Array;let n=!1;for(let s=0;s<o.length;++s){const e=L(o[s],t);if(!e)return null;r.includes(e.assetType)&&(n=!0),a.push(e)}return n?a:null}function L(s,e){const t=l(s,e);return t?{asset:s,assetType:t}:null}async function R(s,e,r){const o=s.map((s=>async function(s,e){const{asset:r,assetType:o}=s;if(r instanceof File)return{blob:r,assetName:r.name,assetType:o};const a=await r.toBlob(e);return t(e),{blob:a,assetName:r.assetName,assetType:o}}(s,r)));return z(o,e,r)}async function z(r,a,c){const p=A(S.uploadAssetBlobs,c?.onProgress,"uploadAssetBlobs"),l=await function(r,a,c){const p=A(r.length,c?.onProgress,"prepareAssetItems");return Promise.all(r.map((async(r,l)=>{const u=async function(r,a,c){const{blob:p,assetType:l,assetName:u}=r;let m=null;try{const e=await async function({data:e,name:r,description:o},a,i){let c=null;try{const l=n(a,"uploads"),u=n(l,"info"),{data:m}=await s(u,{query:{f:"json"},responseType:"json"});t(i);const f=N(a),d=m.maxUploadFileSize*I,y=f?k:d,g=f?Math.min(O,d):O;if(e.size>y)throw new Error("Data too large");const w=n(l,"register"),{data:h}=await s(w,{query:{f:"json",itemName:(p=r,p.replaceAll("/","_").replaceAll("\\","_")),description:o},responseType:"json",method:"post"});if(t(i),!h.success)throw new Error("Registration failed");const{itemID:j}=h.item;c=n(l,j);const b=n(c,"uploadPart"),P=Math.ceil(e.size/g),T=new Array;for(let s=0;s<P;++s)T.push(e.slice(s*g,Math.min((s+1)*g,e.size)));const S=T.slice().reverse(),F=new Array,E=A(P,i?.onProgress,"uploadItem"),x=async()=>{for(;0!==S.length;){const e=T.length-S.length,r=S.pop(),o=new FormData,a=E.simulate(e,U(r.size));try{o.append("f","json"),o.append("file",r),o.append("partId",`${e}`);const{data:a}=await s(b,{timeout:0,body:o,responseType:"json",method:"post"});if(t(i),!a.success)throw new Error("Part upload failed")}finally{a.remove()}}};for(let s=0;s<B&&0!==S.length;++s)F.push(x());await Promise.all(F);const D=n(c,"commit"),{data:v}=await s(D,{query:{f:"json",parts:T.map(((s,e)=>e)).join(",")},responseType:"json",method:"post"});if(t(i),!v.success)throw new Error("Commit failed");return v.item}catch(e){if(null!=c){const e=n(c,"delete");await s(e,{query:{f:"json"},responseType:"json",method:"post"})}throw e}var p}({data:p,name:u},a.url,c);t(c),m={assetType:l,assetUploadId:e.itemID}}catch(s){o(s),e.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${a.url} does not support the REST Uploads API.`)}if(!m){const s=await i(p);if(t(c),!s.isBase64)throw new P;m={assetType:l,assetData:s.data}}if(!m)throw new T;return{item:m,assetName:u}}(await r,a,{...c,onProgress:p.makeOnProgress(l)});return t(c),u})))}(r,a,{...c,onProgress:p.makeOnProgress("prepareAssetItems")});t(c);const f=l.map((({item:s})=>s)),{uploadResults:d}=await async function(e,r,o){const a=E(o?.onProgress);try{const a=await s(n(r.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(t(o),a.data.uploadResults.length!==e.length)throw new g(e.length,a.data.uploadResults.length);return a.data}finally{a.remove()}}(f,a,{...c,onProgress:p.makeOnProgress("uploadAssetItems")});return t(c),r.map(((s,e)=>function(s,e,t){const{success:r}=e;if(!r){const{error:t}=e;throw new w(s.assetName,t)}const{assetHash:o}=e,{assetName:a,item:{assetType:n}}=s,{infoFor3D:{supportedFormats:i}}=t,c=x(n,i);if(!c)throw new h(n);return new u(a,c,[new m(`${t.parsedUrl.path}/assets/${o}`,o)])}(l[e],d[e],a)))}function M(e,t){return s(e,t)}async function H(e,t){const o=(await s(e,t)).data.statusUrl;for(;;){const e=(await s(o,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return s(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(e.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await r(J)}}function $(s){const{infoFor3D:e}=s,t=D("model/gltf-binary",e.supportedFormats)??v("glb",e.supportedFormats);if(!t)throw new b;return t}const J=a(1e3);export{q as uploadAssets};
