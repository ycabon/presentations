/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import{clone as n,e}from"../core/lang.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../chunks/Logger.js";import{subclass as s}from"../core/accessorSupport/decorators/subclass.js";import{w as i}from"../chunks/writer.js";import o,{i as l,p as a}from"./Extent.js";import h from"./Geometry.js";import u from"./Point.js";import c from"./SpatialReference.js";import{b as p,h as m,i as f}from"../chunks/coordsUtils.js";import{d as g}from"../chunks/extentUtils.js";import{project as y}from"./support/webMercatorUtils.js";import{u as x}from"../chunks/zmUtils.js";import"../chunks/ensureType.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../core/Error.js";import"../config.js";import"../chunks/tracking.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/maybe.js";import"../chunks/ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/Axis.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";import"../chunks/vec3.js";import"../chunks/vec3f64.js";import"../chunks/common.js";function I(t){const n=[];for(t.reset();t.nextPath();){const e=[];for(;t.nextPoint();)e.push([t.x,t.y]);n.push(e)}return t.reset(),n}function N(t){const n=[];for(;t.nextPoint();)n.push([t.x,t.y]);return t.seekPathStart(),n}function j(t){return t?t.hasZ?[t.xmax-t.xmin/2,t.ymax-t.ymin/2,t.zmax-t.zmin/2]:[t.xmax-t.xmin/2,t.ymax-t.ymin/2]:null}function d(t){return t?P(t.rings,t.hasZ??!1):null}function P(t,n){if(!t?.length)return null;const e=[],r=[],s=n?[1/0,-1/0,1/0,-1/0,1/0,-1/0]:[1/0,-1/0,1/0,-1/0];for(let e=0,i=t.length;e<i;e++){const i=k(t[e],n,s);i&&r.push(i)}if(r.sort(((t,e)=>{let r=t[2]-e[2];return 0===r&&n&&(r=t[4]-e[4]),r})),r.length&&(e[0]=r[0][0],e[1]=r[0][1],n&&(e[2]=r[0][3]),(e[0]<s[0]||e[0]>s[1]||e[1]<s[2]||e[1]>s[3]||n&&(e[2]<s[4]||e[2]>s[5]))&&(e.length=0)),!e.length){const r=t[0]&&t[0].length?function(t,n){const e=n?[0,0,0]:[0,0],r=n?[0,0,0]:[0,0];let s=0,i=0,o=0,l=0;for(let a=0,h=t.length;a<h-1;a++){const h=t[a],u=t[a+1];if(h&&u){e[0]=h[0],e[1]=h[1],r[0]=u[0],r[1]=u[1],n&&h.length>2&&u.length>2&&(e[2]=h[2],r[2]=u[2]);const t=p(e,r);if(t){s+=t;const e=m(h,u);i+=t*e[0],o+=t*e[1],n&&e.length>2&&(l+=t*e[2])}}}return s>0?n?[i/s,o/s,l/s]:[i/s,o/s]:t.length?t[0]:null}(t[0],n):null;if(!r)return null;e[0]=r[0],e[1]=r[1],n&&r.length>2&&(e[2]=r[2])}return e}function k(t,n,e){let r=0,s=0,i=0,o=0,l=0;const a=t.length?t[0][0]:0,h=t.length?t[0][1]:0,u=t.length&&n?t[0][2]:0;for(let c=0;c<t.length;c++){const p=t[c],m=t[(c+1)%t.length],[f,g,y]=p,x=f-a,I=g-h,[N,j,d]=m,P=N-a,k=j-h,R=x*k-P*I;if(o+=R,r+=(x+P)*R,s+=(I+k)*R,n&&p.length>2&&m.length>2){const t=y-u,n=d-u,e=x*n-P*t;i+=(t+n)*e,l+=e}f<e[0]&&(e[0]=f),f>e[1]&&(e[1]=f),g<e[2]&&(e[2]=g),g>e[3]&&(e[3]=g),n&&(y<e[4]&&(e[4]=y),y>e[5]&&(e[5]=y))}if(o>0&&(o*=-1),l>0&&(l*=-1),!o)return null;o*=.5,l*=.5;const c=[r/(6*o)+a,s/(6*o)+h,o];return n&&(e[4]===e[5]||0===l?(c[3]=(e[4]+e[5])/2,c[4]=0):(c[3]=i/(6*l)+u,c[4]=l)),c}function R(t,n){let e=0,r=0,s=0;t.nextPoint();const i=t.pathSize?t.x:0,o=t.pathSize?t.y:0;for(let l=0;l<t.pathSize;l++){t.seekInPath(l);const a=[t.x,t.y];t.seekInPath((l+1)%t.pathSize);const h=[t.x,t.y],[u,c]=a,p=u-i,m=c-o,[f,g]=h,y=f-i,x=g-o,I=p*x-y*m;s+=I,e+=(p+y)*I,r+=(m+x)*I,u<n[0]&&(n[0]=u),u>n[1]&&(n[1]=u),c<n[2]&&(n[2]=c),c>n[3]&&(n[3]=c)}return s>0&&(s*=-1),s?(s*=.5,[e/(6*s)+i,r/(6*s)+o,s]):null}function S(t){let n=0;for(t.reset();t.nextPath();)n+=t.getCurrentRingArea();if(n<1e-6){const n=function(t){const{hasZ:n,totalSize:e}=t;if(0===e)return null;const r=[],s=[],i=n?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];for(t.reset();t.nextPath();){const n=k(N(t),t.hasZ,i);n&&s.push(n)}if(s.sort(((t,e)=>{let r=t[2]-e[2];return 0===r&&n&&(r=t[4]-e[4]),r})),s.length&&(r[0]=s[0][0],r[1]=s[0][1],n&&(r[2]=s[0][3]),(r[0]<i[0]||r[0]>i[1]||r[1]<i[2]||r[1]>i[3]||n&&(r[2]<i[4]||r[2]>i[5]))&&(r.length=0)),!r.length){t.reset(),t.nextPath();const e=t.pathSize?function(t){const{hasZ:n}=t,e=n?[0,0,0]:[0,0],r=n?[0,0,0]:[0,0];let s=0,i=0,o=0,l=0;if(t.nextPoint()){let a=t.x,h=t.y,u=t.z;for(;t.nextPoint();){const c=t.x,f=t.y,g=t.z;e[0]=a,e[1]=h,r[0]=c,r[1]=f,n&&(e[2]=u,r[2]=g);const y=p(e,r);if(y){s+=y;const t=m(e,r);i+=y*t[0],o+=y*t[1],n&&t.length>2&&(l+=y*t[2])}a=c,h=f,u=g}}return s>0?n?[i/s,o/s,l/s]:[i/s,o/s]:t.pathSize?(t.seekPathStart(),t.nextPoint(),[t.x,t.y]):null}(t):null;if(!e)return null;r[0]=e[0],r[1]=e[1],n&&e.length>2&&(r[2]=e[2])}return r}(t);return n?[n[0],n[1]]:null}const e=[0,0];if(t.reset(),!t.nextPath()||!t.nextPoint())return null;const r=[t.x,t.y];for(t.reset();t.nextPath();)z(e,r,t);return e[0]*=1/n,e[1]*=1/n,e[0]+=r[0],e[1]+=r[1],e}const T=1/3;function z(t,n,e){if(!t||!e||e.pathSize<3)return null;e.nextPoint();const r=e.x,s=e.y;e.nextPoint();let i,o=e.x-r,l=e.y-s,a=0,h=0;for(;e.nextPoint();)a=e.x-r,h=e.y-s,i=.5*T*(a*l-h*o),t[0]+=i*(o+a),t[1]+=i*(l+h),o=a,l=h;const u=e.getCurrentRingArea(),c=[r,s];return c[0]-=n[0],c[1]-=n[1],c[0]*=u,c[1]*=u,t[0]+=c[0],t[1]+=c[1],t}var A;function b(t){return!Array.isArray(t[0])}let v=A=class extends h{static fromExtent(t){const n=t.clone().normalize(),e=t.spatialReference;let r=!1,s=!1;for(const t of n)t.hasZ&&(r=!0),t.hasM&&(s=!0);const i={rings:n.map((t=>{const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const e=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(e)}if(s&&t.hasM){const e=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(e)}return n})),spatialReference:e};return r&&(i.hasZ=!0),s&&(i.hasM=!0),new A(i)}constructor(...t){super(...t),this.rings=[],this.type="polygon"}normalizeCtorArgs(t,n){let e,r,s=null,i=null;return t&&!Array.isArray(t)?(s=t.rings??null,n||(t.spatialReference?n=t.spatialReference:t.rings||(n=t)),e=t.hasZ,r=t.hasM):s=t,s=s||[],n=n||c.WGS84,s.length&&null!=s[0]?.[0]&&"number"==typeof s[0][0]&&(s=[s]),i=s[0]?.[0],i&&(void 0===e&&void 0===r?(e=i.length>2,r=i.length>3):void 0===e?e=r?i.length>3:i.length>2:void 0===r&&(r=e?i.length>3:i.length>2)),{rings:s,spatialReference:n,hasZ:e,hasM:r}}get cache(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get centroid(){const t=d(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const n=new u;return n.x=t[0],n.y=t[1],n.spatialReference=this.spatialReference,this.hasZ&&(n.z=t[2]),n}get extent(){const{spatialReference:t}=this,n=g(this);if(!n)return null;const e=new o(n);return e.spatialReference=t,e}get isSelfIntersecting(){return l(this.rings)}writeRings(t,e){e.rings=n(this.rings)}addRing(t){if(!t)return;const n=this.rings,e=n.length;if(b(t)){const r=[];for(let n=0,e=t.length;n<e;n++)r[n]=t[n].toArray();n[e]=r}else n[e]=t.concat();return this.notifyChange("rings"),this}clone(){const t=new A;return t.spatialReference=this.spatialReference,t.rings=n(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(null==t)return!1;const n=this.spatialReference,r=t.spatialReference;if(null!=n!=(null!=r))return!1;if(null!=n&&null!=r&&!n.equals(r))return!1;if(this.rings.length!==t.rings.length)return!1;const s=([t,n,e,r],[s,i,o,l])=>t===s&&n===i&&(null==e&&null==o||e===o)&&(null==r&&null==l||r===l);for(let n=0;n<this.rings.length;n++){const r=this.rings[n],i=t.rings[n];if(!e(r,i,s))return!1}return!0}contains(t){if(!t)return!1;const n=y(t,this.spatialReference);return a(this,null!=n?n:t)}isClockwise(t){let n;return n=b(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,f(n)}getPoint(t,n){if(!this._validateInputs(t,n))return null;const e=this.rings[t][n],r=this.hasZ,s=this.hasM;return r&&!s?new u(e[0],e[1],e[2],void 0,this.spatialReference):s&&!r?new u(e[0],e[1],void 0,e[2],this.spatialReference):r&&s?new u(e[0],e[1],e[2],e[3],this.spatialReference):new u(e[0],e[1],this.spatialReference)}insertPoint(t,n,e){return this._validateInputs(t,n,!0)?(x(this,e),Array.isArray(e)||(e=e.toArray()),this.rings[t].splice(n,0,e),this.notifyChange("rings"),this):this}removePoint(t,n){if(!this._validateInputs(t,n))return null;const e=new u(this.rings[t].splice(n,1)[0],this.spatialReference);return this.notifyChange("rings"),e}removeRing(t){if(!this._validateInputs(t,null))return null;const n=this.rings.splice(t,1)[0],e=this.spatialReference,r=n.map((t=>new u(t,e)));return this.notifyChange("rings"),r}setPoint(t,n,e){return this._validateInputs(t,n)?(x(this,e),Array.isArray(e)||(e=e.toArray()),this.rings[t][n]=e,this.notifyChange("rings"),this):this}_validateInputs(t,n,e=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=n){const r=this.rings[t];if(e&&(n<0||n>r.length))return!1;if(!e&&(n<0||n>=r.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([r({readOnly:!0})],v.prototype,"cache",null),t([r({readOnly:!0})],v.prototype,"centroid",null),t([r({readOnly:!0})],v.prototype,"extent",null),t([r({readOnly:!0})],v.prototype,"isSelfIntersecting",null),t([r({type:[[[Number]]],json:{write:{isRequired:!0}}})],v.prototype,"rings",void 0),t([i("rings")],v.prototype,"writeRings",null),v=A=t([s("esri.geometry.Polygon")],v),v.prototype.toJSON.isDefaultToJSON=!0;const w=v;export{N as a,R as b,I as c,w as default,j as e,d as p,P as r,S as w};
