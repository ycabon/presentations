/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import"../geometry.js";import{open as t}from"../core/workers/workers.js";import r from"./Point.js";import{fromJSON as n}from"./support/jsonUtils.js";import"../chunks/ensureType.js";import"../core/lang.js";import"../chunks/Logger.js";import"../config.js";import"./Extent.js";import"../chunks/tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"../chunks/tracking.js";import"./Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/maybe.js";import"../chunks/ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"../chunks/reader.js";import"./SpatialReference.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"./Multipoint.js";import"../chunks/zmUtils.js";import"../core/accessorSupport/decorators/cast.js";import"./Polygon.js";import"../chunks/coordsUtils.js";import"../chunks/Axis.js";import"../chunks/extentUtils.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";import"../chunks/vec3.js";import"../chunks/vec3f64.js";import"../chunks/common.js";import"./Polyline.js";import"../chunks/typeUtils.js";import"../core/workers/Connection.js";import"../chunks/Queue.js";import"../chunks/SimpleObservable.js";import"../core/workers/RemoteClient.js";import"../intl.js";import"../chunks/date.js";import"../chunks/locale.js";import"../chunks/timeZoneUtils.js";import"../chunks/datetime.js";import"../chunks/messages.js";function e(t){return Array.isArray(t)?t[0]?.spatialReference:t?.spatialReference}function o(t){return t?Array.isArray(t)?t.map(o):t.toJSON?t.toJSON():t:t}function s(t){return Array.isArray(t)?t.map((t=>n(t))):n(t)}let i;async function c(){return i||(i=t("geometryEngineWorker",{strategy:"distributed"})),i}async function a(t,r){return(await c()).invoke("executeGEOperation",{operation:t,parameters:o(r)})}async function u(t,r){const n=await c();return Promise.all(n.broadcast("executeGEOperation",{operation:t,parameters:o(r)}))}function p(t){return a("extendedSpatialReferenceInfo",[t])}async function m(t,r){return s(await a("clip",[e(t),t,r]))}async function f(t,r){return s(await a("cut",[e(t),t,r]))}function l(t,r){return a("contains",[e(t),t,r])}function j(t,r){return a("crosses",[e(t),t,r])}function y(t,r,n){return a("distance",[e(t),t,r,n])}function h(t,r){return a("equals",[e(t),t,r])}function w(t,r){return a("intersects",[e(t),t,r])}function k(t,r){return a("touches",[e(t),t,r])}function d(t,r){return a("within",[e(t),t,r])}function g(t,r){return a("disjoint",[e(t),t,r])}function S(t,r){return a("overlaps",[e(t),t,r])}function x(t,r,n){return a("relate",[e(t),t,r,n])}function O(t){return a("isSimple",[e(t),t])}async function R(t){return s(await a("simplify",[e(t),t]))}async function A(t,r=!1){return s(await a("convexHull",[e(t),t,r]))}async function U(t,r){return s(await a("difference",[e(t),t,r]))}async function b(t,r){return s(await a("symmetricDifference",[e(t),t,r]))}async function J(t,r){return s(await a("intersect",[e(t),t,r]))}async function N(t,r=null){const n=function(t,r){let n;return Array.isArray(t)?n=t:(n=[],n.push(t),null!=r&&n.push(r)),n}(t,r);return s(await a("union",[e(n),n]))}async function v(t,r,n,o,i,c){return s(await a("offset",[e(t),t,r,n,o,i,c]))}async function E(t,r,n,o=!1){const i=[e(t),t,r,n,o];return s(await a("buffer",i))}async function P(t,r,n,o,i,c){const u=[e(t),t,r,n,o,i,c];return s(await a("geodesicBuffer",u))}async function D(t,n,o=!0){const s=await a("nearestCoordinate",[e(t),t,n,o]);return{...s,coordinate:r.fromJSON(s.coordinate)}}async function L(t,n){const o=await a("nearestVertex",[e(t),t,n]);return{...o,coordinate:r.fromJSON(o.coordinate)}}async function T(t,n,o,s){return(await a("nearestVertices",[e(t),t,n,o,s])).map((t=>({...t,coordinate:r.fromJSON(t.coordinate)})))}function z(t){return"xmin"in t?t.center:"x"in t?t:t.extent?.center}async function B(t,r,n){if(null==t)throw new X;const e=t.spatialReference;if(null==(n=n??z(t)))throw new X;const o=t.constructor.fromJSON(await a("rotate",[e,t,r,n]));return o.spatialReference=e,o}async function C(t,r){if(null==t)throw new X;const n=t.spatialReference;if(null==(r=r??z(t)))throw new X;const e=t.constructor.fromJSON(await a("flipHorizontal",[n,t,r]));return e.spatialReference=n,e}async function G(t,r){if(null==t)throw new X;const n=t.spatialReference;if(null==(r=r??z(t)))throw new X;const e=t.constructor.fromJSON(await a("flipVertical",[n,t,r]));return e.spatialReference=n,e}async function H(t,r,n,o){return s(await a("generalize",[e(t),t,r,n,o]))}async function M(t,r,n){return s(await a("densify",[e(t),t,r,n]))}async function V(t,r,n,o=0){return s(await a("geodesicDensify",[e(t),t,r,n,o]))}function q(t,r){return a("planarArea",[e(t),t,r])}function I(t,r){return a("planarLength",[e(t),t,r])}function Q(t,r,n){return a("geodesicArea",[e(t),t,r,n])}function W(t,r,n){return a("geodesicLength",[e(t),t,r,n])}async function Z(t,r){return s(await a("intersectLinesToPoints",[e(t),t,r]))}async function F(t,r){await u("changeDefaultSpatialReferenceTolerance",[t,r])}async function K(t){await u("clearDefaultSpatialReferenceTolerance",[t])}class X extends Error{constructor(){super("Illegal Argument Exception")}}export{E as buffer,F as changeDefaultSpatialReferenceTolerance,K as clearDefaultSpatialReferenceTolerance,m as clip,l as contains,A as convexHull,j as crosses,f as cut,M as densify,U as difference,g as disjoint,y as distance,h as equals,p as extendedSpatialReferenceInfo,C as flipHorizontal,G as flipVertical,H as generalize,Q as geodesicArea,P as geodesicBuffer,V as geodesicDensify,W as geodesicLength,J as intersect,Z as intersectLinesToPoints,w as intersects,O as isSimple,D as nearestCoordinate,L as nearestVertex,T as nearestVertices,v as offset,S as overlaps,q as planarArea,I as planarLength,x as relate,B as rotate,R as simplify,b as symmetricDifference,k as touches,N as union,d as within};
