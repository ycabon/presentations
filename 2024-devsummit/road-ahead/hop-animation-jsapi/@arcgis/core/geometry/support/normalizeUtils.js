/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import t from"../../config.js";import s from"../../core/Error.js";import{L as e}from"../../chunks/Logger.js";import n from"../Polygon.js";import o from"../Polyline.js";import{g as r,c as i,o as c,u as l}from"../../chunks/normalizeUtilsCommon.js";import{j as p}from"../../chunks/unitUtils.js";import{geographicToWebMercator as u,webMercatorToGeographic as a}from"./webMercatorUtils.js";import{c as h,s as m}from"../../chunks/simplify.js";import"../../core/lang.js";import"../../chunks/tslib.es6.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ensureType.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObservableBase.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/vec3f64.js";import"../../chunks/common.js";import"../../chunks/zmUtils.js";import"./jsonUtils.js";import"../Multipoint.js";import"../../geometry.js";import"../../chunks/typeUtils.js";import"../../chunks/utils7.js";import"../../chunks/utils8.js";const f=()=>e.getLogger("esri.geometry.support.normalizeUtils");function j(t){const s=[];let e=0,n=0;for(let o=0;o<t.length;o++){const r=t[o];let i=null;for(let t=0;t<r.length;t++)i=r[t],s.push(i),0===t?(e=i[0],n=e):(e=Math.min(e,i[0]),n=Math.max(n,i[0]));i&&s.push([(e+n)/2,0])}return s}function g(t,e){if(!(t instanceof o||t instanceof n)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw f().error(t),new s(t)}const i=r(t),c=[];for(const t of i){const s=[];c.push(s),s.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const o=t[n][0],r=t[n][1],i=t[n+1][0],c=t[n+1][1],l=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),p=(c-r)/l,u=(i-o)/l,a=l/e;if(a>1){for(let t=1;t<=a-1;t++){const n=t*e,i=u*n+o,c=p*n+r;s.push([i,c])}const t=(l+Math.floor(a-1)*e)/2,n=u*t+o,i=p*t+r;s.push([n,i])}s.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new n({rings:c,spatialReference:t.spatialReference}):new o({paths:c,spatialReference:t.spatialReference})}function y(t,s,e){if(s){const s=g(t,1e6);t=a(s,!0)}return e&&(t=l(t,e)),t}function x(t,s,e){if(Array.isArray(t)){const n=t[0];if(n>s){const e=c(n,s);t[0]=n+e*(-2*s)}else if(n<e){const s=c(n,e);t[0]=n+s*(-2*e)}}else{const n=t.x;if(n>s){const e=c(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<e){const s=c(n,e);t=t.clone().offset(s*(-2*e),0)}}return t}async function k(s,e,a){if(!Array.isArray(s))return k([s],e);e&&"string"!=typeof e&&f().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const j="string"==typeof e?e:e?.url??t.geometryServiceUrl;let g,d,M,b,w,U,R,v,P=0;const S=[],A=[];for(const t of s)if(null!=t)if(g||(g=t.spatialReference,d=p(g),M=g.isWebMercator,U=M?102100:4326,b=i[U].maxX,w=i[U].minX,R=i[U].plus180Line,v=i[U].minus180Line),d)if("mesh"===t.type)A.push(t);else if("point"===t.type)A.push(x(t.clone(),b,w));else if("multipoint"===t.type){const s=t.clone();s.points=s.points.map((t=>x(t,b,w))),A.push(s)}else if("extent"===t.type){const s=t.clone()._normalize(!1,!1,d);A.push(s.rings?new n(s):s)}else if(t.extent){const s=t.extent,e=c(s.xmin,w)*(2*b);let n=0===e?t.clone():l(t.clone(),e);s.offset(e,0),s.intersects(R)&&s.xmax!==b?(P=s.xmax>P?s.xmax:P,n=y(n,M),S.push(n),A.push("cut")):s.intersects(v)&&s.xmin!==w?(P=s.xmax*(2*b)>P?s.xmax*(2*b):P,n=y(n,M,360),S.push(n),A.push("cut")):A.push(n)}else A.push(t.clone());else A.push(t);else A.push(t);let L=c(P,b),z=-90;const q=L,B=new o;for(;L>0;){const t=360*L-180;B.addPath([[t,z],[t,-1*z]]),z*=-1,L--}if(S.length>0&&q>0){const t=function(t,s){let e=-1;for(let n=0;n<s.cutIndexes.length;n++){const o=s.cutIndexes[n],i=s.geometries[n],l=r(i);for(let t=0;t<l.length;t++){const s=l[t];s.some((e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<s.length;t++){const n=s[t][0];e=n>e?n:e}e=Number(e.toFixed(9));const n=-360*c(e,180);for(let e=0;e<s.length;e++){const s=i.getPoint(t,e);i.setPoint(t,e,s.clone().offset(n,0))}return!0}}))}if(o===e){if("polygon"===t[0].type)for(const s of r(i))t[o]=t[o].addRing(s);else if("polyline"===t[0].type)for(const s of r(i))t[o]=t[o].addPath(s)}else e=o,t[o]=i}return t}(S,await h(j,S,B,a)),e=[],n=[];for(let o=0;o<A.length;o++){const r=A[o];if("cut"!==r)n.push(r);else{const r=t.shift(),i=s[o];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(e.push(r),n.push("simplify")):n.push(M?u(r):r)}}if(!e.length)return n;const o=await m(j,e,a),i=[];for(let t=0;t<n.length;t++){const s=n[t];"simplify"!==s?i.push(s):i.push(M?u(o.shift()):o.shift())}return i}const C=[];for(let t=0;t<A.length;t++){const s=A[t];if("cut"!==s)C.push(s);else{const t=S.shift();C.push(!0===M?u(t):t)}}return C}function d(t){if(!t)return null;const s=t.extent;if(!s)return null;const e=t.spatialReference&&p(t.spatialReference);if(!e)return s;const[n,o]=e.valid,r=2*o,{width:i}=s;let c,{xmin:l,xmax:u}=s;if([l,u]=[u,l],"extent"===t.type||0===i||i<=o||i>r||l<n||u>o)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;c=j(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;c=j(t.paths);break;case"multipoint":c=t.points}const a=s.clone();for(let t=0;t<c.length;t++){let s=c[t][0];s<0?(s+=o,u=Math.max(s,u)):(s-=o,l=Math.min(s,l))}return a.xmin=l,a.xmax=u,a.width<i?(a.xmin-=o,a.xmax-=o,a):s}function M(t,s,e){const n=p(e);if(null==n)return t;const[o,r]=n.valid,i=2*r;let c=0,l=0;s>r?c=Math.ceil(Math.abs(s-r)/i):s<o&&(c=-Math.ceil(Math.abs(s-o)/i)),t>r?l=Math.ceil(Math.abs(t-r)/i):t<o&&(l=-Math.ceil(Math.abs(t-o)/i));let u=t+(c-l)*i;const a=u-s;return a>r?u-=i:a<o&&(u+=i),u}function b(t,s){const e=p(s);if(e){const[s,n]=e.valid,o=n-s;if(t<s)for(;t<s;)t+=o;if(t>n)for(;t>n;)t-=o}return t}export{M as getClosestDenormalizedXToReference,d as getDenormalizedExtent,k as normalizeCentralMeridian,b as normalizeMapX,g as straightLineDensify};
