/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as e,websceneRasterRendererTypes as i,read as s}from"../../rasterRenderers.js";import r from"../../request.js";import{d as n}from"../../core/Accessor.js";import o from"../../core/Error.js";import{L as a}from"../../chunks/Logger.js";import{property as l}from"../../core/accessorSupport/decorators/property.js";import{b as m}from"../../chunks/ensureType.js";import"../../core/lang.js";import{r as c}from"../../chunks/reader.js";import{subclass as p}from"../../core/accessorSupport/decorators/subclass.js";import{g as u,j as h}from"../../chunks/unitUtils.js";import{s as d}from"../../chunks/arcgisLayerUrl.js";import{u as f}from"../../chunks/commonProperties2.js";import y from"../support/DimensionalDefinition.js";import x from"../support/MultidimensionalSubset.js";import g from"../support/RasterFunction.js";import{R as b}from"../../chunks/RasterJobHandler.js";import j from"../support/TileInfo.js";import R from"../../geometry/Polygon.js";import{JSONSupport as I}from"../../core/JSONSupport.js";import{EsriPromiseMixin as k}from"../../core/Promise.js";import{onAbort as S}from"../../core/promiseUtils.js";import w from"../support/LOD.js";import{R as v}from"../support/RasterInfo.js";import{i as T,g as M,c as _,a as F,b as C,h as P,d as D,e as J}from"../../chunks/multidimensionalUtils.js";import{g as H,a as B,p as z,d as U,b as O}from"../../chunks/RawBlockCache.js";import{c as E}from"../../chunks/pixelRangeUtils.js";import{d as L,R as A}from"../../chunks/RasterSymbolizer.js";import{m as N,d as W,e as V,f as G,h as q,c as $}from"../../chunks/vectorFieldUtils.js";import{l as Q,d as K,e as X,s as Z,f as Y,h as tt,b as et,g as it,i as st,c as rt,j as nt}from"../../chunks/rasterProjectionHelper.js";import{Q as ot}from"../../chunks/QueueProcessor.js";import at from"../../geometry/Extent.js";import lt from"../../geometry/Point.js";import mt from"../../geometry/SpatialReference.js";import ct from"../support/PixelBlock.js";import pt from"../../rest/support/FeatureSet.js";import{c as ut}from"../../chunks/rasterFunctionHelper.js";import{g as ht}from"../../chunks/stretchUtils.js";import{n as dt,g as ft,m as yt,h as xt,o as gt}from"../../chunks/rasterRendererHelper.js";import bt from"../../rest/support/ImageHistogramParameters.js";import{c as jt}from"../../chunks/dataUtils.js";import"../../geometry/Geometry.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../core/scheduling.js";import"../../config.js";import"../../chunks/jsonMap.js";import"../../chunks/assets.js";import"../../core/urlUtils.js";import"../../kernel.js";import"../../chunks/writer.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../geometry/Polyline.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/vec3f64.js";import"../../chunks/common.js";import"../../chunks/typeUtils.js";import"../../geometry/support/jsonUtils.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../renderers/ClassBreaksRenderer.js";import"../../symbols.js";import"../../symbols/CIMSymbol.js";import"../../chunks/enumeration.js";import"../support/fieldUtils.js";import"../../core/sql.js";import"../../intl.js";import"../../chunks/date.js";import"../../chunks/locale.js";import"../../chunks/timeZoneUtils.js";import"../../chunks/datetime.js";import"../../chunks/messages.js";import"../../symbols/Symbol.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils4.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../chunks/opacityUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/lineMarkers.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils5.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../symbols/Font.js";import"../../symbols/IconSymbol3DLayer.js";import"../../chunks/persistableUrlUtils.js";import"../../symbols/LabelSymbol3D.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../core/Loadable.js";import"../../portal/PortalGroup.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../core/Clonable.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../core/reactiveUtils.js";import"../../chunks/asyncUtils.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../chunks/LegendOptions.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/sizeVariableUtils.js";import"../../chunks/visualVariableUtils.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../chunks/compilerUtils.js";import"../../chunks/lengthUtils.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/layerUtils2.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../chunks/vec4.js";import"../../chunks/vec4f64.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/UniqueValueRenderer.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils7.js";import"../../chunks/utils8.js";import"../../chunks/utils9.js";import"../../chunks/jsonUtils.js";import"../../chunks/parser.js";import"../../chunks/utils3.js";import"../../chunks/mat4.js";import"../../chunks/_commonjsHelpers.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils6.js";import"../../chunks/LRUCache.js";import"../../chunks/MemCache.js";import"../../TimeExtent.js";import"../../chunks/timeUtils.js";import"../../chunks/layerContainerType.js";import"../../support/timeUtils.js";import"../../chunks/ElevationInfo.js";import"../../chunks/unitConversionUtils.js";import"../../core/workers/workers.js";import"../../core/workers/Connection.js";import"../../chunks/Queue.js";import"../../core/workers/RemoteClient.js";import"../../chunks/TileKey.js";import"../support/RasterBandInfo.js";import"../support/RasterSensorInfo.js";import"../../geometry/projection.js";import"../../chunks/projectBuffer.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../../chunks/ReactiveMap.js";import"../../core/signal.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../support/rasterFunctionConstants.js";import"../../chunks/focalStatUtils.js";import"../../chunks/generateRendererUtils.js";import"../support/MosaicRule.js";let Rt=0,It=class extends(k(I)){constructor(){super(...arguments),this._tileFetchQueue=new ot({concurrency:32,process:(t,e)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:e})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=Q();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:j.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=K(t.spatialReference);return null!=e&&t.extent.width>=e/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return null==t||"gcs-shift"===t.type}set rasterJobHandler(t){this._set("rasterJobHandler",t),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((e=>e.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+Rt++}set url(t){this._set("url",d(t,a.getLogger(this)))}async open(t){throw new o("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,i,s={}){const r=s.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(t,e,i,r);return s={noClip:!0,...s},this.fetchPixels(n,r.size[0],r.size[1],s)}async identify(t,e={}){t=m(lt,t).clone().normalize();const{multidimensionalDefinition:i,timeExtent:s}=e,{rasterInfo:r}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:o}=r;let{transposedVariableName:a}=e;const l=null!=o&&n&&(null!=s||T(i));l&&!a&&(a=null!=i&&i.length>0?i[0].variableName??void 0:o.variables[0].name,e={...e,transposedVariableName:a}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:c,extent:p}=r,{datumTransformation:u}=e;let h=X(t,c,u);if(!p.intersects(h))return{location:h,value:null};if(null!=r.transform){const t=r.transform.inverseTransform(h);if(!r.nativeExtent.intersects(t))return{location:t,value:null};h=t}let d=0;const f=null!=a&&null!=o&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const t=this.primaryRasters.rasters[0];if(f)return t.identify(h,e);const{pixelSize:i}=r,s=3,n=i.x*s/2,o=i.y*s/2,a=new at({xmin:h.x-n,xmax:h.x+n,ymin:h.y-o,ymax:h.y+o,spatialReference:c}),l={interpolation:"nearest"},{pixelBlock:m}=await t.fetchPixels(a,s,s,l),{pixelBlock:p}=await this.fetchPixels(a,s,s,l);if(null==m)return{location:h,value:null};const u=Math.floor(s*s*.5),d=!m.mask||m.mask[u]?m.pixels.map((t=>t[u])):null;let y;return null!=p&&(y=!p.mask||p.mask[u]?p.pixels.map((t=>t[u])):void 0),{location:h,value:d,processedValue:y,pyramidLevel:0}}if(!f)if(e.srcResolution)d=Z(e.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(t,e),null==d)return{location:h,value:null};const y=this.identifyPixelLocation(h,d,null,f);if(null===y)return{location:h,value:null};const{row:x,col:g,rowOffset:b,colOffset:j,blockWidth:R}=y,I=a??e.sliceId,k=H(this.rasterId,I),S=`${d}/${x}/${g}`;let w=B(k,null,S);null==w&&(w=this.fetchRawTile(d,x,g,e),z(k,null,S,w));const v=await w;if(!v?.pixels?.length)return{location:h,value:null};const M=b*R+j;return this._processIdentifyResult(v,{srcLocation:h,position:M,pyramidLevel:d,useTransposedTile:!!f,requestSomeSlices:l,identifyOptions:e})}async fetchPixels(t,e,i,s={}){t=Y(t),s=this._getRequestOptionsWithSliceId(s);const{_hasNoneOrGCSShiftTransform:r}=this;if(s.requestRawData&&r)return this._fetchPixels(t,e,i,s);const n=K(t.spatialReference),o=tt(t);if(null==n||0===o||1===o&&this._isGlobalWrappableSource&&r)return this._fetchPixels(t,e,i,s);if(o>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:l,xmax:m}=t,c=Math.round(n/(m-l)*e),p=c-Math.round((n/2-l)/(m-l)*e);let u=0;const h=[];for(let r=0;r<=o;r++){const d=new at({xmin:0===r?l:-n/2,xmax:r===o?m-n*r:n/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),f=0===r?c-p:r===o?e-u:c;u+=f,h.push(f);const y=s.disableWrapAround&&r>0?null:this._fetchPixels(d,f,i,s);a.push(y)}const d=(await Promise.all(a)).map((t=>t?.pixelBlock));let f=null;const y={width:e,height:i};return f=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},s)).pixelBlock:N(d,y,{blockWidths:h}),{extent:t,srcExtent:et(t,this.rasterInfo.spatialReference,s.datumTransformation),pixelBlock:f}}async fetchRawPixels(t,e,i,s={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const r=await this._fetchRawTiles(t,e,i,s),{nativeExtent:n,nativePixelSize:o,storageInfo:a}=this.rasterInfo,l=2**t,m=o.x*l,c=o.y*l,p=new at({xmin:n.xmin+m*e.x,xmax:n.xmin+m*(e.x+i.width-1),ymin:n.ymax-c*(e.y+i.height-1),ymax:n.ymax-c*e.y,spatialReference:n.spatialReference});if(!r)return{extent:p,srcExtent:p,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=r;if(1===u.length&&null!=u[0]&&u[0].width===i.width&&u[0].height===i.height)return{extent:p,srcExtent:p,pixelBlock:r.pixelBlocks[0]};const d=t>0?a.pyramidBlockWidth:a.blockWidth,f=t>0?a.pyramidBlockHeight:a.blockHeight,y={x:e.x%d,y:e.y%f};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:i,clipOffset:y,clipSize:i,coefs:null,sampleSpacing:null,interpolation:s.interpolation,alignmentInfo:null,blockWidths:null},s)).pixelBlock:N(u,h,{clipOffset:y,clipSize:i}),{extent:p,srcExtent:p,pixelBlock:x}}fetchRawTile(t,e,i,s){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return et(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?L(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,i=0){const{customFetchParameters:s}=this.ioConfig,{range:n,query:o,headers:a}=e;i=i??e.retryCount??this.ioConfig.retryCount;const l=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await r(t,{...e,query:{...o,...s},headers:{...a,...l}})}catch(s){if(i>0)return i--,this.request(t,e,i);throw s}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return null==e||null==t||0===t.length?null:M(t,e)}getTileExtentFromTileInfo(t,e,i,s){const r=s.lodAt(t);return this.getTileExtent({x:r.resolution,y:r.resolution},e,i,s.origin,s.spatialReference,s.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:i,pixelSize:s}=this.rasterInfo;if(!t.tileInfo){const r=[],n=t.maximumPyramidLevel||0;let o=Math.max(s.x,s.y),a=1/.0254*96*o;for(let t=0;t<=n;t++)r.unshift(new w({level:n-t,resolution:o,scale:a})),o*=2,a*=2;const l=new lt({x:i.xmin,y:i.ymax,spatialReference:e});t.tileInfo=new j({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:r}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,i=512,s){const{width:r,height:n,nativeExtent:o,pixelSize:a,spatialReference:l}=t,m=new lt({x:o.xmin,y:o.ymax,spatialReference:l});null==s&&(s=Math.max(0,Math.round(Math.log(Math.max(r,n))/Math.LN2-8)));const c=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[a],s);t.storageInfo=new v({blockWidth:e,blockHeight:i,pyramidBlockWidth:e,pyramidBlockHeight:i,origin:m,firstPyramidLevel:1,maximumPyramidLevel:s,blockBoundary:c})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,i,s,r,n=0,o=2){if(1===r.length&&n>0){r=[...r];let{x:t,y:e}=r[0];for(let i=0;i<n;i++)t*=o,e*=o,r.push({x:t,y:e})}const a=[],{x:l,y:m}=s;for(let s=0;s<r.length;s++){const{x:n,y:o}=r[s];a.push({minCol:Math.floor((t.xmin-l+.1*n)/e/n),maxCol:Math.floor((t.xmax-l-.1*n)/e/n),minRow:Math.floor((m-t.ymax+.1*o)/i/o),maxRow:Math.floor((m-t.ymin-.1*o)/i/o)})}return a}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:s}=this.rasterInfo.storageInfo;if(0===t)return e;if(null!=i&&i.length)return i[t-1];const r=s**t;return{x:e.x*r,y:e.y*r}}identifyPixelLocation(t,e,i,s){const{spatialReference:r,nativeExtent:n,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:m}=o,c=s&&null!=m?m.tileSize[0]:o.blockWidth,p=s&&null!=m?m.tileSize[1]:o.blockHeight,u=X(t,r,i);if(!n.intersects(u))return null;if(e<0||e>a)return null;const h=this.getPyramidPixelSize(e),{x:d,y:f}=h,y=(l.y-u.y)/f/p,x=(u.x-l.x)/d/c,g=Math.min(p-1,Math.floor((y-Math.floor(y))*p)),b=Math.min(c-1,Math.floor((x-Math.floor(x))*c));return{pyramidLevel:e,row:Math.floor(y),col:Math.floor(x),rowOffset:g,colOffset:b,blockWidth:c,srcLocation:u}}getTileExtent(t,e,i,s,r,n){const[o,a]=n,l=s.x+i*o*t.x,m=l+o*t.x,c=s.y-e*a*t.y,p=c-a*t.y;return new at({xmin:l,xmax:m,ymin:p,ymax:c,spatialReference:r})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,i){const s=this.rasterInfo.storageInfo.blockBoundary[t];return!s||s.maxRow<e||s.maxCol<i||s.minRow>e||s.minCol>i}updateImageSpaceRasterInfo(t){const{extent:e,pixelSize:i}=t;if(-.5===e.xmin&&.5===e.ymax&&1===i.x&&1===i.y&&null==t.transform)return;const{width:s,height:r}=t,n=mt.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new at({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-r,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new lt({x:1,y:1,spatialReference:n});const{extent:o,storageInfo:a}=t;if(a){a.origin=new lt({x:o.xmin,y:o.ymax,spatialReference:n});const{tileInfo:e}=a;if(e){e.origin=a.origin;const i=(t.nativePixelSize.x+t.nativePixelSize.y)/2;e.lods.forEach(((t,e)=>{t.resolution=i*2**e,t.scale=96*t.resolution/.0254}))}}}async _fetchPixels(t,e,i,s={}){let r=tt(t);if(r>=2)return{extent:t,pixelBlock:null};const n=this._getSourceDataInfo(t,e,i,s),{pyramidLevel:o,srcResolution:a,srcExtent:l,srcWidth:m,srcHeight:c,ul:p}=n;if(0===m||0===c)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,d="gcs-shift"===h?.type,f=null!=K(t.spatialReference);!d&&f||(r=tt(n.srcExtent,d));const y=await this._fetchRawTiles(o,p,{width:m,height:c,wrapCount:r},s);if(!y)return{extent:t,srcExtent:l,pixelBlock:null};const x=u.storageInfo,g=o>0?x.pyramidBlockWidth:x.blockWidth,b=o>0?x.pyramidBlockHeight:x.blockHeight;let{x:j,y:R}=u.pixelSize;if(o>0){const{pyramidResolutions:t,pyramidScalingFactor:e}=x;if(null!=t&&t[o-1])({x:j,y:R}=t[o-1]);else{const t=e**o;j*=t,R*=t}}const I=u.spatialReference,k=new lt({x:j,y:R,spatialReference:I}),S=g===m&&b===c&&p.x%g==0&&p.y%b==0,w=new lt({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/i,spatialReference:t.spatialReference}),v=!t.spatialReference.equals(I),T=I.isGeographic?1e-9:1e-4,{datumTransformation:M}=s;if(!v&&S&&1===y.pixelBlocks.length&&g===e&&b===i&&this._isSameResolution(a,w,T))return{extent:t,srcExtent:l,srcTilePixelSize:k,pixelBlock:y.pixelBlocks[0]};const _=f&&null!=K(l.spatialReference)&&this._hasNoneOrGCSShiftTransform,F=s.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");F&&!this.rasterJobHandler&&await Q();const C=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:w.toJSON(),datumTransformation:M,rasterTransform:h,hasWrapAround:r>0||_,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:F},s):it({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:w,datumTransformation:M,rasterTransform:h,hasWrapAround:r>0||_,isAdaptive:!1,includeGCSGrid:F});let P;const D=!s.requestRawData,J={rows:C.spacing[0],cols:C.spacing[1]},H=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(o,y.extent.xmin):void 0,{pixelBlocks:B,mosaicSize:z,isPartiallyFilled:U}=y;let O=null;if(this.rasterJobHandler){const t=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:z,destDimension:D?{width:e,height:i}:null,coefs:D?C.coefficients:null,sampleSpacing:D?J:null,projectDirections:F,gcsGrid:F?C.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:s.interpolation,alignmentInfo:H,blockWidths:null},s);({pixelBlock:P,localNorthDirections:O}=t)}else{const t=N(B,z,{alignmentInfo:H});P=D?W(t,{width:e,height:i},C.coefficients,J,s.interpolation):t,F&&C.gcsGrid&&(O=V({width:e,height:i},C.gcsGrid),P=G(P,this.rasterInfo.dataType,O))}return s.requestRawData||F?{extent:t,srcExtent:l,srcTilePixelSize:k,pixelBlock:P,transformGrid:C,localNorthDirections:O,isPartiallyFilled:U}:{extent:t,srcExtent:l,srcTilePixelSize:k,pixelBlock:P}}async _fetchRawTiles(t,e,i,s){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:a}=this.getBlockWidthHeight(t);let{x:l,y:m}=e,{width:c,height:p,wrapCount:u}=i;const h=this._getRasterTileAlignmentInfo(t,0);s.buffer&&(l-=s.buffer.cols,m-=s.buffer.rows,c+=2*s.buffer.cols,p+=2*s.buffer.rows);let d=0,f=0,y=0;u&&null!=h&&(({worldColumnCountFromOrigin:f,originColumnOffset:y,rightPadding:d}=h),f*h.blockWidth-d>=l+c&&(d=0));const x=Math.floor(l/o),g=Math.floor(m/a),b=Math.floor((l+c+d-1)/o),j=Math.floor((m+p+d-1)/a),R=n[t];if(!R)return null;const{minRow:I,minCol:k,maxCol:S,maxRow:w}=R;if(0===u&&(j<I||b<k||g>w||x>S))return null;const v=new Array;let T=!1;const M=null==this.ioConfig.allowPartialFill?s.allowPartialFill:this.ioConfig.allowPartialFill;for(let e=g;e<=j;e++)for(let i=x;i<=b;i++){let r=i;if(!s.disableWrapAround&&u&&null!=h&&f<=i&&(r=i-f-y),e>=I&&r>=k&&w>=e&&S>=r){const i=this._tileFetchQueue.push({pyramidLevel:t,row:e,col:r,options:s},{signal:s.signal});M?v.push(new Promise((t=>{i.then((e=>t(e))).catch((()=>{T=!0,t(null)}))}))):v.push(i)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const _=await Promise.all(v),F={height:(j-g+1)*a,width:(b-x+1)*o},{spatialReference:C}=this.rasterInfo,P=this.getPyramidPixelSize(t),{x:D,y:J}=P;return{extent:new at({xmin:r.x+x*o*D,xmax:r.x+(b+1)*o*D,ymin:r.y-(j+1)*a*J,ymax:r.y-g*a*J,spatialReference:C}),pixelBlocks:_,mosaicSize:F,isPartiallyFilled:T}}_isSameResolution(t,e,i){return Math.abs(t.x-e.x)<i&&Math.abs(t.y-e.y)<i}_fetchRawTile(t,e,i,s){const r=this.rasterInfo.storageInfo.blockBoundary[t];if(!r)return Promise.resolve(null);const{minRow:n,minCol:o,maxCol:a,maxRow:l}=r;if(e<n||i<o||e>l||i>a)return Promise.resolve(null);const m=H(this.rasterId,s.sliceId),c=`${t}/${e}/${i}`;let p=B(m,s.registryId,c);if(null==p){const r=new AbortController;p=this.fetchRawTile(t,e,i,{...s,signal:r.signal}),z(m,s.registryId,c,p,r),p.catch((()=>U(m,s.registryId,c)))}return s.signal&&S(s,(()=>{O(m,s.registryId,c)})),p}_computeMagDirValues(t){const{bandCount:e,dataType:i}=this.rasterInfo;if((2!==e||"vector-magdir"!==i)&&"vector-uv"!==i||2!==t?.length||!t[0]?.length)return null;const s=t[0].length;if("vector-magdir"===i){const e=t[1].map((t=>(t+360)%360));return[t[0],e]}const[r,n]=t,o=[],a=[];for(let t=0;t<s;t++){const[e,i]=q([r[t],n[t]]);o.push(e),a.push(i)}return[o,a]}_getRasterTileAlignmentInfo(t,e){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=st(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:e,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,i,s={}){const r={datumTransformation:s.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};s.srcResolution&&(r.srcResolution=s.srcResolution,this._updateSourceDataInfo(t,r));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:a,pyramidLevel:l}=r,m=o/e,c=a/i,p=l<n&&m*c>=16,u=l===n&&this._requireTooManySrcTiles(o,a,e,i);if(p||u||0===o||0===a){const o=new lt({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/i,spatialReference:t.spatialReference});let a=rt(o,this.rasterInfo.spatialReference,t,r.datumTransformation);const u=!a||s.srcResolution&&a.x+a.y<s.srcResolution.x+s.srcResolution.y;if(p&&s.srcResolution&&u){const t=Math.round(Math.log(Math.max(m,c))/Math.LN2)-1;if(n-l+3>=t){const e=2**t;a={x:s.srcResolution.x*e,y:s.srcResolution.y*e}}}a&&(r.srcResolution=a,this._updateSourceDataInfo(t,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,e,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(t,e,i,s){const{tileInfo:r}=this.rasterInfo.storageInfo,n=t/i,o=e/s;return Math.ceil(t/r.size[0])*Math.ceil(e/r.size[1])>=256*Math.max(1,(i+s)/1024)||n>8||o>8}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const{rasterInfo:i}=this,s=i.spatialReference,{srcResolution:r,datumTransformation:n}=e,{pyramidLevel:o,pyramidResolution:a,excessiveReading:l}=Z(r,i,this.ioConfig.sampling);if(l)return;let m=e.srcExtent||et(t,s,n);if(null==m)return;const c=i.transform;c&&(m=c.inverseTransform(m)),e.srcExtent=m;const{x:p,y:u}=i.storageInfo.origin,h=Math.floor((m.xmin-p)/a.x+.1),d=Math.floor((u-m.ymax)/a.y+.1),f=Math.floor((m.xmax-p)/a.x-.1),y=Math.floor((u-m.ymin)/a.y-.1),x=m.width<.1*a.x?0:f-h+1,g=m.height<.1*a.y?0:y-d+1;e.pyramidLevel=o,e.pyramidResolution=a,e.srcWidth=x,e.srcHeight=g,e.ul={x:h,y:d}}_getRequestOptionsWithSliceId(t){return null!=this.rasterInfo.multidimensionalInfo&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:i,position:s,pyramidLevel:r,useTransposedTile:n}=e,o=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[s])return{location:i,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(null==a||!n){const e=t.pixels.map((t=>t[s])),n={location:i,value:e,pyramidLevel:r},o=this._computeMagDirValues(e.map((t=>[t])));return o?.length&&(n.magdirValue=o.map((t=>t[0]))),n}let l=t.pixels.map((t=>t.slice(s*o,s*o+o))),m=this._computeMagDirValues(l);const{requestSomeSlices:c,identifyOptions:p}=e;let u=_(a,p.transposedVariableName);if(c){const t=F(u,p.multidimensionalDefinition,p.timeExtent);l=l.map((e=>t.map((t=>e[t])))),m=m?.map((e=>t.map((t=>e[t])))),u=t.map((t=>u[t]))}const h=t.noDataValues||this.rasterInfo.noDataValue,d={pixels:l,pixelType:t.pixelType};let f;return null!=h&&(E(d,h),f=d.mask),{location:i,value:null,dataSeries:u.map(((t,e)=>{const i={value:0===f?.[e]?null:l.map((t=>t[e])),multidimensionalDefinition:t.multidimensionalDefinition.map((t=>new y({...t,isSlice:!0})))};return m?.length&&(i.magdirValue=[m[0][e],m[1][e]]),i})),pyramidLevel:r}}};t([l()],It.prototype,"_rasterTileAlignmentInfo",void 0),t([l()],It.prototype,"_tileFetchQueue",void 0),t([l({readOnly:!0})],It.prototype,"_isGlobalWrappableSource",null),t([l({readOnly:!0})],It.prototype,"_hasNoneOrGCSShiftTransform",null),t([l()],It.prototype,"rasterJobHandler",null),t([l({readOnly:!0})],It.prototype,"rasterId",null),t([l(f)],It.prototype,"url",null),t([l({type:String,json:{write:!0}})],It.prototype,"datasetName",void 0),t([l({type:String,json:{write:!0}})],It.prototype,"datasetFormat",void 0),t([l()],It.prototype,"hasUniqueSourceStorageInfo",void 0),t([l()],It.prototype,"rasterInfo",void 0),t([l()],It.prototype,"ioConfig",void 0),t([l()],It.prototype,"sourceJSON",void 0),It=t([p("esri.layers.support.rasterDatasets.BaseRaster")],It);const kt=It;async function St(t,e,i){if("extent"===i.type)return function(t,e,i){const{width:s,height:r}=t,n=new Uint8Array(s*r),o=e.width/s,a=e.height/r;if(i.width/o<.5||i.height/a<.5)return new ct({pixelType:t.pixelType,width:s,height:r,mask:n,pixels:[...t.pixels]});const{xmin:l,xmax:m,ymin:c,ymax:p}=e,{xmin:u,xmax:h,ymin:d,ymax:f}=i,y=Math.max(l,u),x=Math.min(m,h),g=Math.max(c,d),b=Math.min(p,f),j=.5*o,R=.5*a;if(x-y<j||b-g<R||x<l+j||y>m-j||g>p-R||b<c+R)return new ct({pixelType:t.pixelType,width:s,height:r,mask:n,pixels:[...t.pixels]});const I=Math.max(0,(y-l)/o),k=Math.min(s,Math.max(0,(x-l)/o)),S=Math.max(0,(p-b)/a),w=Math.min(r,Math.max(0,(p-g)/a)),v=Math.round(I),T=Math.round(k)-1,M=Math.round(S),_=Math.round(w)-1;if(v===T&&I%1>.5&&k%1<.5||M===_&&S%1>.5&&w%1<.5)return new ct({pixelType:t.pixelType,width:s,height:r,mask:n,pixels:[...t.pixels]});if(0===v&&0===M&&T===s&&_===r)return t;const F=t.mask;for(let t=M;t<=_;t++)for(let e=v;e<=T;e++){const i=t*s+e;n[i]=F?F[i]:255}return new ct({pixelType:t.pixelType,width:s,height:r,mask:n,pixels:[...t.pixels]})}(t,e,i);const{width:s,height:r}=t,n=new Uint8Array(s*r),{contains:o,intersects:a}=await import("../../geometry/geometryEngine.js");return a(e,i)?"polyline"===i.type?function(t,e,i){const{width:s,height:r}=t,n=new Uint8Array(s*r),o=e.width/s,a=e.height/r,{xmin:l,ymax:m}=e,{paths:c}=i,p=t.mask;for(let t=0;t<c.length;t++){const e=c[t];for(let t=0;t<e.length-1;t++){const[i,c]=e[t],[u,h]=e[t+1];let d=Math.floor((m-c)/a),f=Math.floor((m-h)/a);if(f<d){const t=d;d=f,f=t}d=Math.max(0,d),f=Math.min(r-1,f);const y=(u-i)/(h-c);for(let t=d;t<=f;t++){const e=t===d?Math.max(c,h):(r+1-t)*a,m=t===f?Math.min(c,h):e-a;let x=h===c?Math.floor((i-l)/o):Math.floor((y*(e-c)+i-l)/o),g=h===c?Math.floor((u-l)/o):Math.floor((y*(m-c)+i-l)/o);if(g<x){const t=x;x=g,g=t}const b=t*s;x=Math.max(0,x),g=Math.min(s-1,g);for(let t=b+x;t<=b+g;t++)n[t]=p?p[t]:255}}}return new ct({pixelType:t.pixelType,width:s,height:r,mask:n,pixels:[...t.pixels]})}(t,e,i):o(i,e)?t:function(t,e,i){if(!t)return t;const{width:s,height:r}=t,n=e.width/s,o=e.height/r,{xmin:a,ymax:l}=e;let m;if("extent"===i.type){const t=(i.xmin-a)/n,e=(i.xmax-a)/n,s=(l-i.ymax)/o,r=(l-i.ymin)/o;m=[[[t,s],[t,r],[e,r],[e,s],[t,s]]]}else m=i.rings.map((t=>t.map((([t,e])=>[(t-a)/n,(l-e)/o]))));const c=document.createElement("canvas");c.width=s,c.height=r;const p=c.getContext("2d");p.fillStyle="#f00",p.beginPath(),m.forEach((t=>{p.moveTo(t[0][0],t[0][1]);for(let e=0;e<t.length;e++)p.lineTo(t[e][0],t[e][1]);p.closePath()})),p.fill();const u=p.getImageData(0,0,s,r).data,h=t.mask,d=s*r,f=new Uint8Array(d);for(let t=0;t<d;t++)h&&!h[t]||(f[t]=u[4*t+3]>127?255:0);return new ct({pixelType:t.pixelType,width:s,height:r,mask:f,maskIsAlpha:!1,pixels:[...t.pixels]})}(t,e,i):new ct({pixelType:t.pixelType,width:s,height:r,mask:n,maskIsAlpha:!1,pixels:[...t.pixels]})}let wt=class extends kt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async open(t){await this.init();const{rasterFunction:e}=this;this.primaryRasters?.rasters?.length?e.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((t=>t.rasterJobHandler=this.rasterJobHandler)));const{rasters:i,rasterIds:s}=this.primaryRasters,r=i.map((e=>e.rasterInfo?void 0:e.open(t)));await Promise.all(r);const n=i.map((({rasterInfo:t})=>t)),a=e.bind({rasterInfos:n,rasterIds:s});if(e.rawSourceRasterInfos=n,!a.success||0===n.length)throw new o("raster-function:open",`cannot bind the function: ${a.error??""}`);const l="Table"===e.functionName?e:e.functionArguments?.raster;"Table"===l?.functionName&&(e.rasterInfo.attributeTable=pt.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const m=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every((t=>this._hasSameStorageInfo(t,m))),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",e.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(t,e,i,s={}){const{rasters:r,rasterIds:n}=this.primaryRasters;let o=!1;const{interpolation:a}=s,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!s.requestRawData&&l&&(o=1===r.length&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:o});const m=r.map((r=>r.fetchPixels(t,e,i,s))),c=await Promise.all(m),p=c.map((t=>t.pixelBlock)),u=o||s.requestRawData?c.map((t=>t.srcTilePixelSize)):null;if(s.skipRasterFunction||p.every((t=>null==t)))return c[0];const h=c.find((t=>null!=t.pixelBlock))?.extent??t;let d=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:n}):this.rasterFunction.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:n});const{transformGrid:f}=c[0];if(!o||null==d||null==f){const t=s.noClip?null:this.getClippingGeometry(h.spatialReference);return s.noClip||s.requestRawData||null==d||!t||(d=await St(d,h,t)),{...c[0],pixelBlock:d}}const y={rows:f.spacing[0],cols:f.spacing[1]};let x;x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[d],srcMosaicSize:{width:d.width,height:d.height},destDimension:{width:e,height:i},coefs:f.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock:W(d,{width:e,height:i},f.coefficients,y,a);const g=s.noClip?null:this.getClippingGeometry(t.spatialReference);return s.noClip||s.requestRawData||null==x||null==g||(x=await St(x,t,g)),{extent:t,srcExtent:c[0].srcExtent,pixelBlock:x}}getClippingGeometry(t){const e=this._clippingGeometry.get("0");if(!t||!e)return e;const i=this._getSRKey(t);let s=this._clippingGeometry.get(i);return null!=s||(s=t.equals(e.spatialReference)?e:nt(e,t),this._clippingGeometry.set(i,s)),s}_hasSameStorageInfo(t,e){const{storageInfo:i,pixelSize:s,spatialReference:r,extent:n}=t,{storageInfo:o,pixelSize:a,spatialReference:l,extent:m}=e;return s.x===a.x&&s.y===a.y&&r.equals(l)&&n.equals(m)&&i.blockHeight===o.blockHeight&&i.blockWidth===o.blockWidth&&i.maximumPyramidLevel===o.maximumPyramidLevel}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let e=t?.clippingGeometry;if(e&&"inside"===t.clippingType){const{extent:t}=this.rasterInfo,{difference:i,densify:s}=await import("../../geometry/geometryEngine.js");let r=s(R.fromExtent(t),2*(t.width+t.height)/40);r=nt(r,e.spatialReference),e=i(r,e)}this._clippingGeometry.clear(),e&&this._clippingGeometry.set("0",e)}_getSRKey(t){return String(t.wkid??t.wkt??t.wkt2)}};t([l({type:String,json:{write:!0}})],wt.prototype,"datasetFormat",void 0),t([l()],wt.prototype,"tileType",void 0),t([l()],wt.prototype,"rasterFunction",void 0),t([l()],wt.prototype,"primaryRasters",void 0),wt=t([p("esri.layers.support.rasterDatasets.FunctionRaster")],wt);const vt=wt,Tt=R=>{let I=class extends R{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===t[0]?.raster?.datasetFormat}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){"none"===t?.functionName?.toLowerCase()&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}get rasterInfo(){return n(a.getLogger(this),"rasterInfo",{replacement:"serviceRasterInfo",version:"4.29",warnOnce:!0}),this._get("serviceRasterInfo")}set url(t){this._set("url",d(t,a.getLogger(this)))}set renderer(t){null==t&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",t),this.updateRenderer())}readRenderer(t,e,i){const r=e?.layerDefinition?.drawingInfo?.renderer;return s(r,i)||void 0}async convertVectorFieldData(t,e){const{serviceRasterInfo:i}=this;if(null==t||!i)return null;const s=this._rasterJobHandler.instance,r=i.dataType;return s?s.convertVectorFieldData({pixelBlock:t,dataType:r},e):$(t,r)}async computeStatisticsHistograms(t,e){t=m(bt,t).clone();const{serviceRasterInfo:i}=this,{geometry:s}=t;if(null==s)throw new o("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let r=s;const{spatialReference:n}=i;s.spatialReference.equals(n)||(await Q(),r="extent"===s.type?et(s,n):nt(s,n));const a=t.pixelSize??new lt({x:i.pixelSize.x,y:i.pixelSize.y,spatialReference:n}),{extent:l,width:c,height:p}=function(t,e,i,s=!0){const{spatialReference:r}=t,{x:n,y:o}=function(t,e){if(t.spatialReference.equals(e))return t;const i=u(t.spatialReference),s=u(e);if(i===s)return t;const r=i/s;return{x:t.x*r,y:t.y*r}}(i,r);let a,l,m;const c="extent"===e.type?e:e.extent;let{xmin:p,xmax:h,ymax:d,ymin:f}=c;const{xmin:y,ymax:x}=t.extent;return s?(p=y+(p>y?n*Math.round((p-y)/n):0),d=x-(d<x?o*Math.round((x-d)/o):0),h=y+(h>y?n*Math.round((h-y)/n):0),f=x-(f<x?o*Math.round((x-f)/o):0),a=new at({xmin:p,ymax:d,xmax:h,ymin:f,spatialReference:r}),l=Math.round(a.width/n),m=Math.round(a.height/o)):(l=Math.floor((h-p)/n+.8),m=Math.floor((d-f)/o+.8),p=y+(p>y?n*Math.floor((p-y)/n+.1):0),d=x-(d<x?o*Math.floor((x-d)/o+.1):0),h=p+l*n,f=d-m*o,a=new at({xmin:p,ymax:d,xmax:h,ymin:f,spatialReference:r})),{extent:a,width:l,height:m}}(i,r,a),h=await this.fetchPixels(l,c,p,{...e,interpolation:"nearest"});if(null==h.pixelBlock)throw new o("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const d=await St(h.pixelBlock,l,r),f=this._rasterJobHandler.instance;return f?f.computeStatisticsHistograms({pixelBlock:d},e):ht(d)}async createFlowMesh(t,e){const i=this._rasterJobHandler.instance;return i?i.createFlowMesh(t,e):jt(t.meshType,t.simulationSettings,t.flowData,null!=e.signal?e.signal:(new AbortController).signal)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.serviceRasterInfo??{};if(null==e)return t;let i=t.multidimensionalDefinition||this.multidimensionalDefinition;i?.length||(i=C(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const s=t.timeExtent||this.timeExtent;if(null!=i&&null!=s&&(null!=s.start||null!=s.end)){i=i.map((t=>t.clone()));const r=e.variables.find((({name:t})=>t===i[0].variableName))?.dimensions?.find((({name:t})=>"StdTime"===t)),n=i.find((({dimensionName:t})=>"StdTime"===t));if(!r||!n)return{...t,multidimensionalDefinition:null};const{start:o,end:a}=s,l=null==o?null:o.getTime(),m=null==a?null:a.getTime(),c=l??m,p=m??l;if(null!=r.values){const t=r.values.filter((t=>{if(Array.isArray(t)){if(c===p)return t[0]<=c&&t[1]>=c;const e=t[0]<=c&&t[1]>c||t[0]<p&&t[1]>=p,i=t[0]>=c&&t[1]<=p||t[0]<c&&t[1]>p;return e||i}return c===p?t===c:t>=c&&t<=p}));if(t.length){const e=t.sort(((t,e)=>{const i=Array.isArray(t)?t[0]:t,s=Array.isArray(t)?t[1]:t,r=Array.isArray(e)?e[0]:e,n=Array.isArray(e)?e[1]:e;return c===p?i-r:Math.abs(s-p)-Math.abs(n-p)}))[0];n.values=[e]}else i=null}else if(r.hasRegularIntervals&&r.extent){const[t,e]=r.extent;c>e||p<t?i=null:n.values=c===p?[c]:[Math.max(t,c),Math.min(e,p)]}}return null!=i&&P(i,this.multidimensionalSubset)?{...t,multidimensionalDefinition:null}:{...t,multidimensionalDefinition:i}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const t=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&t&&this._set("rasterFunction",g.fromJSON(t)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let t,e=this.raster,i=!1;"Function"===e.datasetFormat?(t=e.primaryRasters.rasters,e=t[0],i=!0):t=[e];const{rasterFunction:s}=this;if(s){const i={raster:e};t.length>1&&t.forEach((t=>i[t.url]=t));const r=ut(s.functionDefinition?.toJSON()??s.toJSON(),i),n=new vt({rasterFunction:r});n.rasterJobHandler=this._rasterJobHandler.instance,await n.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=n}else this.raster=e,this._cachedRasterFunctionJson=null,await e.when();if(this._cachedRendererJson=null,!i&&!s)return;const{bandIds:r}=this,{bandCount:n}=this.raster.rasterInfo,o=r?.length?r.some((t=>t>=n)):n>=3;r&&(o||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:t,symbolizer:e}=this;if(!t||!e||!this.renderer)return;const{rasterInfo:i}=this.raster,s=D(i,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=s?.name,n=dt({...this.renderer.toJSON(),variableName:r});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(n))return;const o=this._rasterJobHandler.instance;o&&(e.rasterInfo=ft(i,r),e.rendererJSON=n,e.bind(),await o.updateSymbolizer(e),this._cachedRendererJson=n)}async applyRenderer(t,e){const i=t?.pixelBlock;if(!(null!=i&&i.pixels&&i.pixels.length>0))return null;let s;await this.updateRenderer();const r=this._rasterJobHandler.instance,n=this.bandIds??[];return s=r?await r.symbolize({...t,simpleStretchParams:e,bandIds:n}):this.symbolizer.symbolize({...t,simpleStretchParams:e,bandIds:n}),s}getTileUrl(t,e,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${t}/${e}/${i}`:""}getCompatibleTileInfo(t,e,i=!1){if(!this.loaded||null==e)return null;if(i&&t.equals(this.spatialReference))return this.tileInfo;const s=h(t);return j.create({size:256,spatialReference:t,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,e,i,s={}){if(k(this),s.requestAsImageElement){const n=this.getTileUrl(t,e,i);return r(n,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then((t=>t.data))}const{serviceRasterInfo:n}=this;if(null!=n.multidimensionalInfo&&null==(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition){const r=s.tileInfo||n.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,e,i,r),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,e,i,s)}async fetchPixels(t,e,i,s={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),e=Math.round(e),i=Math.round(i),this.raster.fetchPixels(t,e,i,s))}async identify(t,e={}){const{raster:i,serviceRasterInfo:s}=this;if(null!=s.multidimensionalInfo&&!(s.hasMultidimensionalTranspose&&(T(e.multidimensionalDefinition)||e.transposedVariableName||e.timeExtent)||null!=(e=this.normalizeRasterFetchOptions(e)).multidimensionalDefinition))return{location:t,value:null};const r=this.multidimensionalSubset?.areaOfInterest;if(r&&!r.contains(t))throw new o("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return i.identify(t,e)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const t=this.serviceRasterInfo?.multidimensionalInfo;if(null==t||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,i=e?.[0]?.variableName;return t.variables.some((t=>t.name===i&&(!e?.[0].dimensionName||t.dimensions.some((t=>"StdTime"===t.name)))))}getStandardTimeValue(t){return new Date(24*(t-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(t){const e=t??this.serviceRasterInfo?.multidimensionalInfo;return J(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=C(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const t=new b;return this._rasterJobHandler.connectionPromise=t.initialize().then((async()=>{k(this),this._rasterJobHandler.instance=t,this.raster.rasterJobHandler=t,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){k(this);const{raster:t}=this,e=yt(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(t="no"){k(this);const{rasterInfo:e}=this.raster;!this.bandIds&&e.bandCount>1&&(this.bandIds=xt(e));const i=D(e,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=i?.name;if(!this.renderer||"override"===t){const t=gt(e,{bandIds:this.bandIds,variableName:s}),i=e.statistics,r=i&&i.length>0?i[0]:null,n=r?.max??0,o=r?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===t.type&&(n>1e24||o<-1e24)&&(t.dynamicRangeAdjustment=!0,t.statistics=null,"none"===t.stretchType&&(t.stretchType="min-max")),this.renderer=t}const r=dt({...this.renderer.toJSON(),variableName:s}),n=ft(e,s);this.symbolizer?(this.symbolizer.rendererJSON=r,this.symbolizer.rasterInfo=n):this.symbolizer=new A({rendererJSON:r,rasterInfo:n});const o=this.symbolizer.bind();if(o.success){if("auto"===t){const{colormap:t}=this.raster.rasterInfo,e=this.renderer;if(null!=t&&"raster-colormap"===e.type){const t=gt(this.raster.rasterInfo);JSON.stringify(t)!==JSON.stringify(e)&&this._configDefaultRenderer("override")}else if("raster-stretch"===e.type){const t=this.bandIds?.length,i=e.statistics?.length;!e.dynamicRangeAdjustment&&i&&t&&i!==t&&this._configDefaultRenderer("override")}}}else a.getLogger(this).warn("imagery-tile-mixin",o.error||"The given renderer is not supported by the layer."),"auto"===t&&this._configDefaultRenderer("override")}};function k(t){if(!t.raster||!t.serviceRasterInfo)throw new o("imagery-tile","no raster")}return t([l({clonable:!1})],I.prototype,"_cachedRendererJson",void 0),t([l({clonable:!1})],I.prototype,"_cachedRasterFunctionJson",void 0),t([l({clonable:!1})],I.prototype,"_compatibleFullExtent",void 0),t([l({clonable:!1})],I.prototype,"_isConstructedFromFunctionRaster",void 0),t([l({clonable:!1})],I.prototype,"_rasterJobHandler",void 0),t([l()],I.prototype,"bandIds",void 0),t([l({json:{origins:{service:{read:{source:"copyrightText"}}}}})],I.prototype,"copyright",void 0),t([l({json:{read:!1}})],I.prototype,"fullExtent",null),t([l()],I.prototype,"interpolation",void 0),t([l()],I.prototype,"ioConfig",void 0),t([l({type:[y],json:{write:!0}})],I.prototype,"multidimensionalDefinition",null),t([l({type:x,json:{write:!0}})],I.prototype,"multidimensionalSubset",void 0),t([l()],I.prototype,"raster",void 0),t([l({type:g,json:{name:"renderingRule",write:!0}})],I.prototype,"rasterFunction",null),t([l({readOnly:!0})],I.prototype,"rasterInfo",null),t([l()],I.prototype,"serviceRasterInfo",void 0),t([l()],I.prototype,"sourceJSON",void 0),t([l({readOnly:!0,type:mt,json:{read:!1}})],I.prototype,"spatialReference",void 0),t([l({type:j})],I.prototype,"tileInfo",void 0),t([l(f)],I.prototype,"url",null),t([l({types:e,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const t="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!t}}},origins:{"web-scene":{types:i,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&"vector-field"!==t.type&&"flow"!==t.type})}}}}})],I.prototype,"renderer",null),t([c("renderer")],I.prototype,"readRenderer",null),t([l({clonable:!1})],I.prototype,"symbolizer",void 0),I=t([p("esri.layers.ImageryTileMixin")],I),I};export{kt as B,vt as F,Tt as ImageryTileMixin};
