// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require ../chunks/tslib.es6 ../core/Error ../core/Loadable ../core/Logger ../core/Promise ../core/promiseUtils ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/has ../core/RandomLCG ../core/accessorSupport/decorators/subclass ../core/libs/gl-matrix-2/factories/vec3f64 ./Extent ./Geometry ./Point ./Polygon ./support/axisAngleDegrees ./support/MeshComponent ./support/meshErrors ./support/MeshGeoreferencedVertexSpace ./support/MeshLocalVertexSpace ./support/MeshTransform ./support/MeshVertexAttributes ./support/meshVertexSpaceUtils ./support/triangulationUtils ./support/meshUtils/bounds ./support/meshUtils/centerAt ./support/meshUtils/georeference ./support/meshUtils/loadExternal ./support/meshUtils/Metadata ./support/meshUtils/offset ./support/meshUtils/primitives ./support/meshUtils/rotate ./support/meshUtils/scale".split(" "),
function(B,g,C,e,k,H,I,J,h,D,X,K,L,M,N,q,O,E,u,l,v,w,x,y,z,P,r,Q,R,S,F,T,n,U,V){var m;D={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:v,local:w}};e=m=class extends e.LoadableMixin(H.EsriPromiseMixin(N)){constructor(a){super(a);this.components=null;this.vertexSpace=new v;this.transform=null;this.metadata=new F.Metadata;this.hasZ=!0;this.hasM=!1;this.vertexAttributes=new y.MeshVertexAttributes;this.type="mesh"}initialize(){if(0===this.metadata.externalSources.length||
this.vertexAttributes.position.length)this.loadStatus="loaded";this.when(()=>{this.addHandles(J.watch(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(a=>a.clone())}),()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){return this.loaded?0<this.vertexAttributes.position.length&&(!this.components||0<this.components.length):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const {components:a,spatialReference:b,vertexAttributes:c,vertexSpace:d}=
this;var f=c.position;if(0===f.length||a&&0===a.length)return new M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:b});if("local"===d.type){const {_untransformedExtent:p,transform:A}=this;return r.getProjectedExtent(p,A,d,b)}if("georeferenced"===d.type&&z.isRelativeVertexSpace(d)){const {transform:p}=this;f=R.project({positions:f,transform:p,vertexSpace:d,inSpatialReference:b,outSpatialReference:b});return r.getExtentFromPositions(f,b)}return r.getExtentFromPositions(f,b)}get _untransformedExtent(){return r.getExtentFromPositions(this.vertexAttributes.position,
this.spatialReference)}get anchor(){const a=z.vertexSpaceOriginToPoint(this.vertexSpace,this.spatialReference);if(null!=a)return a;const {center:b,zmin:c}=this._transformedExtent;return new q({x:b.x,y:b.y,z:c,spatialReference:this.spatialReference})}get origin(){const a=z.vertexSpaceOriginToPoint(this.vertexSpace,this.spatialReference);return null!=a?a:this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(a){if(!this.loaded)return k.getLogger(this).error("addComponent()",
(new l.MeshNotLoadedError).message);this.components||(this.components=[]);this.components.push(u.from(a));this.notifyChange("components")}removeComponent(a){if(!this.loaded)return k.getLogger(this).error("removeComponent()",(new l.MeshNotLoadedError).message);if(this.components&&(a=this.components.indexOf(a),-1!==a)){this.components.splice(a,1);this.notifyChange("components");return}k.getLogger(this).error("removeComponent()",(new l.ComponentNotFoundError).message)}rotate(a,b,c,d){E.composeAxes(a,
b,c,G);U.rotate(this,G,d);return this}offset(a,b,c,d){if(!this.loaded)return k.getLogger(this).error("offset()",(new l.MeshNotLoadedError).message),this;t[0]=a;t[1]=b;t[2]=c;T.offset(this,t,d);return this}scale(a,b){if(!this.loaded)return k.getLogger(this).error("scale()",(new l.MeshNotLoadedError).message),this;V.scale(this,a,b);return this}centerAt(a,b){if(!this.loaded)return k.getLogger(this).error("centerAt()",(new l.MeshNotLoadedError).message),this;Q.centerAt(this,a,b);return this}load(a){const {metadata:{displaySource:b}}=
this;b&&this.addResolvingPromise(S.loadExternal(this,b,a));return Promise.resolve(this)}addExternalSources(a){this.metadata.externalSources.addMany(a)}updateDisplaySource(a){this.metadata.displaySource=a}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(a){let b=null;if(this.components){const c=new Map,d=new Map;b=this.components.map(f=>f.cloneWithDeduplication(c,d))}a={components:b,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),
vertexSpace:a,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new m(a)}cloneShallow(){return new m({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(a){var b=new Promise((d,f)=>B(["./support/meshUtils/exporters/gltf/gltfexport"],d,f));const c=this.load();
b=await Promise.all([b,c]);({toBinaryGLTF:b}=b[0]);return b(this,a)}get memoryUsage(){let a;a=0+this.vertexAttributes.memoryUsage;if(null!=this.components)for(const b of this.components)a+=b.memoryUsage;return a}_clearSources(){this.metadata.clearSources()}static createBox(a,b){if(!(a instanceof q))return k.getLogger("esri.geometry.Mesh").error(".createBox()",(new l.InvalidLocationError).message),null;a=new m(n.convertUnitGeometry(n.createUnitSizeBox(),a,b));return b?.imageFace&&"all"!==b.imageFace?
n.extractSingleFaceOfBox(a,b.imageFace):a}static createSphere(a,b){return a instanceof q?new m(n.convertUnitGeometry(n.createUnitSizeSphere(b?.densificationFactor||0),a,b)):(k.getLogger("esri.geometry.Mesh").error(".createSphere()",(new l.InvalidLocationError).message),null)}static createCylinder(a,b){return a instanceof q?new m(n.convertUnitGeometry(n.createUnitSizeCylinder(b?.densificationFactor||0),a,b)):(k.getLogger("esri.geometry.Mesh").error(".createCylinder()",(new l.InvalidLocationError).message),
null)}static createPlane(a,b){if(!(a instanceof q))return k.getLogger("esri.geometry.Mesh").error(".createPlane()",(new l.InvalidLocationError).message),null;const c=b?.facing??"up",d=n.convertPlaneSizeParameter(c,b?.size);return new m(n.convertUnitGeometry(n.createUnitSizePlane(c),a,{...b,size:d}))}static createFromPolygon(a,b){if(!(a instanceof O))return k.getLogger("esri.geometry.Mesh").error(".createFromPolygon()",(new l.InvalidPolygonError).message),null;const c=P.triangulate(a);return new m({vertexAttributes:new y.MeshVertexAttributes({position:c.position}),
components:[new u({faces:c.faces,shading:"flat",material:b?.material??null})],spatialReference:a.spatialReference,vertexSpace:new v})}static async createFromGLTF(a,b,c){if(!(a instanceof q))throw a=new l.InvalidLocationError,k.getLogger("esri.geometry.Mesh").error(".createfromGLTF()",a.message),a;const {loadGLTFMesh:d}=await I.whenOrAbort(new Promise((f,p)=>B(["./support/meshUtils/loadGLTFMesh"],f,p)),c);return new m(await d(a,b,c))}static async createFromFiles(a,b,c){if(!c?.layer)throw new C("invalid:no-layer",
"SceneLayer required for file to mesh conversion.");return c.layer.convertMesh(b,{location:a,...c})}static createWithExternalSource(a,b,c){var d=c?.extent??null;const {x:f,y:p,z:A,spatialReference:W}=a;a=c?.transform?.clone()??new x;c=c?.vertexSpace??new w({origin:[f,p,A??0]});b={source:b,extent:d};d=new F.Metadata;d.externalSources.push(b);return new m({metadata:d,transform:a,vertexSpace:c,spatialReference:W})}static createIncomplete(a,b){const {x:c,y:d,z:f,spatialReference:p}=a;a=b?.transform?.clone()??
new x;b=b?.vertexSpace??new w({origin:[c,d,f??0]});b=new m({transform:a,vertexSpace:b,spatialReference:p});b.addResolvingPromise(Promise.reject(new C("mesh-incomplete","Mesh resources are not complete")));return b}};g.__decorate([h.property({type:[u],json:{write:!0}})],e.prototype,"components",void 0);g.__decorate([h.property({nonNullable:!0,types:D,constructOnly:!0,json:{write:!0}})],e.prototype,"vertexSpace",void 0);g.__decorate([h.property({type:x,json:{write:!0}})],e.prototype,"transform",void 0);
g.__decorate([h.property({constructOnly:!0})],e.prototype,"metadata",void 0);g.__decorate([h.property()],e.prototype,"hasExtent",null);g.__decorate([h.property()],e.prototype,"_transformedExtent",null);g.__decorate([h.property()],e.prototype,"_untransformedExtent",null);g.__decorate([h.property()],e.prototype,"anchor",null);g.__decorate([h.property()],e.prototype,"origin",null);g.__decorate([h.property({readOnly:!0,json:{read:!1}})],e.prototype,"extent",null);g.__decorate([h.property({readOnly:!0,
json:{read:!1,write:!0,default:!0}})],e.prototype,"hasZ",void 0);g.__decorate([h.property({readOnly:!0,json:{read:!1,write:!0,default:!1}})],e.prototype,"hasM",void 0);g.__decorate([h.property({type:y.MeshVertexAttributes,nonNullable:!0,json:{write:!0}})],e.prototype,"vertexAttributes",void 0);e=m=g.__decorate([K.subclass("esri.geometry.Mesh")],e);const t=L.create(),G=E.create();return e});