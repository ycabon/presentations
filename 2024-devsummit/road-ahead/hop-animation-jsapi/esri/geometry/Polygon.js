// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../chunks/tslib.es6 ../core/arrayUtils ../core/lang ../core/accessorSupport/decorators/property ../core/has ../core/Logger ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./Extent ./Geometry ./Point ./SpatialReference ./support/centroid ./support/contains ./support/coordsUtils ./support/extentUtils ./support/intersectsBase ./support/webMercatorUtils ./support/zmUtils".split(" "),function(k,v,q,m,g,I,w,x,y,z,l,A,B,C,D,E,F,G,r){var p;g=p=class extends z{static fromExtent(a){var b=
a.clone().normalize();a=a.spatialReference;let c=!1,f=!1;for(const d of b)d.hasZ&&(c=!0),d.hasM&&(f=!0);b={rings:b.map(d=>{const e=[[d.xmin,d.ymin],[d.xmin,d.ymax],[d.xmax,d.ymax],[d.xmax,d.ymin],[d.xmin,d.ymin]];if(c&&d.hasZ){var h=d.zmin+.5*(d.zmax-d.zmin);for(let n=0;n<e.length;n++)e[n].push(h)}if(f&&d.hasM)for(d=d.mmin+.5*(d.mmax-d.mmin),h=0;h<e.length;h++)e[h].push(d);return e}),spatialReference:a};c&&(b.hasZ=!0);f&&(b.hasM=!0);return new p(b)}constructor(...a){super(...a);this.rings=[];this.type=
"polygon"}normalizeCtorArgs(a,b){let c=null,f,d,e=null;a&&!Array.isArray(a)?(c=a.rings??null,b||(a.spatialReference?b=a.spatialReference:a.rings||(b=a)),f=a.hasZ,d=a.hasM):c=a;c=c||[];b=b||A.WGS84;c.length&&null!=c[0]?.[0]&&"number"===typeof c[0][0]&&(c=[c]);if(e=c[0]?.[0])void 0===f&&void 0===d?(f=2<e.length,d=3<e.length):void 0===f?f=d?3<e.length:2<e.length:void 0===d&&(d=f?3<e.length:2<e.length);return{rings:c,spatialReference:b,hasZ:f,hasM:d}}get cache(){this.commitProperty("rings");this.commitProperty("hasZ");
this.commitProperty("hasM");this.commitProperty("spatialReference");return{}}get centroid(){const a=B.polygonCentroid(this);if(!a||isNaN(a[0])||isNaN(a[1])||this.hasZ&&isNaN(a[2]))return null;const b=new l;b.x=a[0];b.y=a[1];b.spatialReference=this.spatialReference;this.hasZ&&(b.z=a[2]);return b}get extent(){const {spatialReference:a}=this;var b=E.getPolygonExtent(this);if(!b)return null;b=new y(b);b.spatialReference=a;return b}get isSelfIntersecting(){return F.isSelfIntersecting(this.rings)}writeRings(a,
b){b.rings=q.clone(this.rings)}addRing(a){if(a){var b=this.rings,c=b.length;if(Array.isArray(a[0]))b[c]=a.concat();else{const f=[];for(let d=0,e=a.length;d<e;d++)f[d]=a[d].toArray();b[c]=f}this.notifyChange("rings");return this}}clone(){const a=new p;a.spatialReference=this.spatialReference;a.rings=q.clone(this.rings);a.hasZ=this.hasZ;a.hasM=this.hasM;return a}equals(a){if(this===a)return!0;if(null==a)return!1;var b=this.spatialReference,c=a.spatialReference;if(null!=b!==(null!=c)||null!=b&&null!=
c&&!b.equals(c)||this.rings.length!==a.rings.length)return!1;b=([f,d,e,h],[n,H,t,u])=>f===n&&d===H&&(null==e&&null==t||e===t)&&(null==h&&null==u||h===u);for(c=0;c<this.rings.length;c++)if(!v.equals(this.rings[c],a.rings[c],b))return!1;return!0}contains(a){if(!a)return!1;const b=G.project(a,this.spatialReference);return C.polygonContainsPoint(this,null!=b?b:a)}isClockwise(a){a=Array.isArray(a[0])?a:a.map(b=>this.hasZ?this.hasM?[b.x,b.y,b.z,b.m]:[b.x,b.y,b.z]:[b.x,b.y]);return D.isClockwise(a)}getPoint(a,
b){if(!this._validateInputs(a,b))return null;a=this.rings[a][b];b=this.hasZ;const c=this.hasM;return b&&!c?new l(a[0],a[1],a[2],void 0,this.spatialReference):c&&!b?new l(a[0],a[1],void 0,a[2],this.spatialReference):b&&c?new l(a[0],a[1],a[2],a[3],this.spatialReference):new l(a[0],a[1],this.spatialReference)}insertPoint(a,b,c){if(!this._validateInputs(a,b,!0))return this;r.updateSupportFromPoint(this,c);Array.isArray(c)||(c=c.toArray());this.rings[a].splice(b,0,c);this.notifyChange("rings");return this}removePoint(a,
b){if(!this._validateInputs(a,b))return null;a=new l(this.rings[a].splice(b,1)[0],this.spatialReference);this.notifyChange("rings");return a}removeRing(a){if(!this._validateInputs(a,null))return null;a=this.rings.splice(a,1)[0];const b=this.spatialReference;a=a.map(c=>new l(c,b));this.notifyChange("rings");return a}setPoint(a,b,c){if(!this._validateInputs(a,b))return this;r.updateSupportFromPoint(this,c);Array.isArray(c)||(c=c.toArray());this.rings[a][b]=c;this.notifyChange("rings");return this}_validateInputs(a,
b,c=!1){return null==a||0>a||a>=this.rings.length||null!=b&&(a=this.rings[a],c&&(0>b||b>a.length)||!c&&(0>b||b>=a.length))?!1:!0}toJSON(a){return this.write({},a)}};k.__decorate([m.property({readOnly:!0})],g.prototype,"cache",null);k.__decorate([m.property({readOnly:!0})],g.prototype,"centroid",null);k.__decorate([m.property({readOnly:!0})],g.prototype,"extent",null);k.__decorate([m.property({readOnly:!0})],g.prototype,"isSelfIntersecting",null);k.__decorate([m.property({type:[[[Number]]],json:{write:{isRequired:!0}}})],
g.prototype,"rings",void 0);k.__decorate([x.writer("rings")],g.prototype,"writeRings",null);g=p=k.__decorate([w.subclass("esri.geometry.Polygon")],g);g.prototype.toJSON.isDefaultToJSON=!0;return g});