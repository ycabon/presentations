// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Logger ../../../chunks/vec32 ../../../core/libs/gl-matrix-2/factories/vec3f64 ../MeshComponent ../MeshTransform ../MeshVertexAttributes ../meshVertexSpaceUtils ./georeference".split(" "),function(B,D,A,E,F,G,H,I,C){function J(a){var c=null,b=null;let e=!0,q=!0,g=null;const l=E.create();let f=0;for(const m of a){const {vertexSpace:p,transform:h}=m;null==b&&(b=p,(a=b.origin)&&(g=a));if(b.type!==p.type)return z().error("merge()",`Inconsistent mesh vertex space for provided geometries. One was ${b.type} while another is ${p.type}. Unable to merge geometries.`),
null;null==c||null!=h&&h.equals(c)||(e=!1);null!=h&&null==c&&(c=h);if(a=p.origin)g&&!A.equals(a,g)&&(q=!1),f++,A.add(l,l,a)}if(null==b)throw Error();b=b.clone();if(null==b.origin)return{transform:null,vertexSpace:b,rebake:!1};if(q&&e)return{transform:c?.clone(),vertexSpace:b,rebake:!1};c=A.scale(l,l,1/f);b.origin=c;return{transform:new G,vertexSpace:b,rebake:!0}}function x(a,c,b,e,q){if(c){var g=c.position;if(g)if(c=c[a],b=b[a],null==c){c=e[a];var l=r[a];if(null!=b){for(var f=0;f<g.length;f+=3)for(let m=
0;m<l;m++)b[c++]=q;e[a]=c}}else if(null!=b&&null!=c){q=0;g=e[a];l=c.length;for(f=0;f<l;f++)b[g++]=c[q++];e[a]+=c.length}}}const z=()=>D.getLogger("esri.geometry.support.triangleMeshMerge"),r={position:3,normal:3,tangent:4,uv:2,color:4};B.merge=function(a,c){var b,e;if(0===a.length)return z().error("merge()","Must specify one more geometries to merge"),null;const q=a[0].spatialReference;for(var g of a){if(!g.spatialReference.equals(q))return z().error("merge()","Geometries must all be in the same spatial reference"),
null;if(!g.loaded)return z().error("merge()","Geometries must all be loaded before merging"),null}g=J(a);if(null==g)return null;var l=0,f=0,m=0,p=0,h=0,d=b=!1;var n=e=!1;for(t of a){var k=t.vertexAttributes;if(k?.position&&(k.uv&&(b=!0),k.normal&&(d=!0),k.tangent&&(n=!0),k.color&&(e=!0),d&&b&&e&&n))break}var t=d;for(v of a)d=v.vertexAttributes,d?.position&&(l+=d.position.length,b&&(f+=d.position.length/r.position*r.uv),t&&(m+=d.position.length/r.position*r.normal),e&&(p+=d.position.length/r.position*
r.color),n&&(h+=d.position.length/r.position*r.tangent));var v=new H.MeshVertexAttributes({position:new Float64Array(l),uv:f?new Float32Array(f):null,normal:m?new Float32Array(m):null,tangent:h?new Float32Array(h):null,color:p?new Uint8Array(p):null});l=[];f={position:0,uv:0,normal:0,tangent:0,color:0};m=new Map;p=new Map;for(const w of a){a=w;if(g.rebake){n=a.vertexSpace;h=g.vertexSpace;if(n.type!==h.type)throw Error();n=C.georeferenceApplyTransform(a.vertexAttributes,n,a.transform,a.spatialReference);
t="local"===h.type;a=C.ungeoreference(n,I.vertexSpaceOriginToPoint(h,a.spatialReference),{geographic:t})}else a=a.vertexAttributes;t=a;if(c&&c.reuseMaterials&&w.components)for(const y of w.components)y.material&&m.set(y.material,y.material);a=w;h=f;e=m;b=p;n=l;if(a.components)for(const y of a.components){d=y.cloneWithDeduplication(e,b);k=h.position/3;if(d.faces)for(var u=0;u<d.faces.length;u++)d.faces[u]+=k;else for(d.faces=new Uint32Array(a.vertexAttributes.position.length/3),u=0;u<d.faces.length;u++)d.faces[u]=
u+k;k=d;0<h.normal&&!a.vertexAttributes.normal&&"source"===k.shading&&(k.shading="flat");n.push(d)}else if(a.vertexAttributes&&a.vertexAttributes.position){e=a.vertexAttributes.position.length/3;b=new Uint32Array(e);d=h.position/3;for(k=0;k<e;k++)b[k]=k+d;e=b=new F({faces:b});0<h.normal&&!a.vertexAttributes.normal&&"source"===e.shading&&(e.shading="flat");n.push(b)}x("position",t,v,f,0);x("normal",t,v,f,0);x("tangent",t,v,f,0);x("uv",w.vertexAttributes,v,f,0);x("color",w.vertexAttributes,v,f,255)}return{vertexAttributes:v,
components:l,vertexSpace:g.vertexSpace,transform:g.transform,spatialReference:q}};Object.defineProperty(B,Symbol.toStringTag,{value:"Module"})});