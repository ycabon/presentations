// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require ../../../chunks/tslib.es6 ../../../geometry ../../../kernel ../../../request ../../../TimeExtent ../../../core/arrayUtils ../../../core/Error ../../../core/has ../../../core/jsonMap ../../../core/Loadable ../../../core/Logger ../../../core/object ../../../core/promiseUtils ../../../core/urlUtils ../../../core/uuid ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/decorators/subclass ../../../geometry/Extent ../../../geometry/support/meshVertexSpaceUtils ../../../geometry/support/meshUtils/External ../applyEditsUtils ./support/clientSideDefaults ./support/QueryTask ../../support/arcgisLayerUrl ../../support/featureLayerUtils ../../support/infoFor3D ../../../rest/query/executeQueryJSON ../../../rest/query/operations/editsZScale ../../../rest/support/Query ../../../versionManagement/support/versionManagementUtils ../../../geometry/SpatialReference".split(" "),
function(K,w,v,L,k,M,z,x,E,F,N,G,O,A,H,P,B,Q,R,I,S,n,T,U,V,y,W,X,Y,Z,C,aa){const ba=new F.JSONMap({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),ca=new Set(["Feature Layer","Oriented Imagery Layer","Table","Catalog Layer"]),da=new F.JSONMap({Started:"published",Publishing:"publishing",Stopped:"unavailable"});v=class extends N{constructor(){super(...arguments);this.type="feature-layer";this.refresh=A.debounce(async()=>{await this.load();var a=this.sourceJSON.editingInfo?.lastEditDate;
if(null==a)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}a=a!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:a,updates:a?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}});this._ongoingAssetUploads=new Map}load(a){const b=this._fetchService(this.layer.sourceJSON,{...a}).then(()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,a)).then(()=>this._ensureLatestMetadata(a));this.addResolvingPromise(b);
return Promise.resolve(this)}get queryTask(){const {capabilities:a,parsedUrl:b,dynamicDataSource:c,infoFor3D:e,gdbVersion:d,spatialReference:f,fieldsIndex:h}=this.layer,g=E("featurelayer-pbf")&&a?.query.supportsFormatPBF&&null==e;return new U({url:b.path,pbfSupported:g,fieldsIndex:h,infoFor3D:e,dynamicDataSource:c,gdbVersion:d,sourceSpatialReference:f,queryAttachmentsSupported:a?.operations?.supportsQueryAttachments??!1})}async addAttachment(a,b){await this.load();var {layer:c}=this;await y.ensureLayerCredential(c,
"editing");a=a.attributes[c.objectIdField];c=c.parsedUrl.path+"/"+a+"/addAttachment";const e=this._getLayerRequestOptions();b=this._getFormDataForAttachment(b,e.query);try{const d=await k(c,{body:b});return n.createFeatureEditResult(d.data.addAttachmentResult)}catch(d){throw this._createAttachmentErrorResult(a,d);}}async updateAttachment(a,b,c){await this.load();var {layer:e}=this;await y.ensureLayerCredential(e,"editing");a=a.attributes[e.objectIdField];e=e.parsedUrl.path+"/"+a+"/updateAttachment";
b=this._getLayerRequestOptions({query:{attachmentId:b}});c=this._getFormDataForAttachment(c,b.query);try{const d=await k(e,{body:c});return n.createFeatureEditResult(d.data.updateAttachmentResult)}catch(d){throw this._createAttachmentErrorResult(a,d);}}async applyEdits(a,b){await this.load();const {layer:c}=this;await y.ensureLayerCredential(c,"editing");const e=c.infoFor3D;var d=null!=e,f=d||(b?.globalIdUsed??!1);const h=d?await this._uploadMeshesAndGetAssetMapEditsJSON(a):null;var g=a.addFeatures?.map(r=>
n.getFeatureJSON(this.layer,r,e))??[];g=(await Promise.all(g)).filter(z.isSome);var p=a.updateFeatures?.map(r=>n.getFeatureJSON(this.layer,r,e))??[];p=(await Promise.all(p)).filter(z.isSome);const t=n.getFeatureIds(this.layer,a.deleteFeatures,f);Y.unapplyEditsZUnitScaling(g,p,c.spatialReference);a=await n.getAttachmentEditsJSON(this.layer,a);d=c.capabilities.editing.supportsAsyncApplyEdits&&d;var q=b?.gdbVersion||c.gdbVersion;const l={gdbVersion:q,rollbackOnFailure:b?.rollbackOnFailureEnabled,useGlobalIds:f,
returnEditMoment:b?.returnEditMoment,usePreviousEditMoment:b?.usePreviousEditMoment,async:d};await C.isSafeToEditVersion(this.layer.url,q,!0);q=C.isVersionInEditSession(this.layer.url,q||null);b?.returnServiceEditsOption?(l.edits=JSON.stringify([{id:c.layerId,adds:g,updates:p,deletes:t,attachments:a,assetMaps:h}]),l.returnServiceEditsOption=ba.toJSON(b?.returnServiceEditsOption),l.returnServiceEditsInSourceSR=b?.returnServiceEditsInSourceSR):(l.adds=g.length?JSON.stringify(g):null,l.updates=p.length?
JSON.stringify(p):null,l.deletes=t.length?f?JSON.stringify(t):t.join(","):null,l.attachments=a&&JSON.stringify(a),l.assetMaps=null!=h?JSON.stringify(h):void 0);f=this._getLayerRequestOptions({method:"post",query:l});q&&(f.authMode="immediate",f.query.returnEditMoment=!0,f.query.sessionId=C.currentSessionId);b=b?.returnServiceEditsOption?c.url:c.parsedUrl.path;let m;try{m=d?await this._asyncApplyEdits(b+"/applyEdits",f):await k(b+"/applyEdits",f)}catch(r){if(n.isProtectedOrPrivateVersionError(r))f.authMode=
"immediate",m=d?await this._asyncApplyEdits(b+"/applyEdits",f):await k(b+"/applyEdits",f);else throw r;}!c.capabilities.operations?.supportsEditing&&c.effectiveCapabilities?.operations?.supportsEditing&&await L.id?.findCredential(c.url)?.refreshToken();return this._createEditsResult(m)}async deleteAttachments(a,b){await this.load();var {layer:c}=this;await y.ensureLayerCredential(c,"editing");a=a.attributes[c.objectIdField];c=c.parsedUrl.path+"/"+a+"/deleteAttachments";try{return(await k(c,this._getLayerRequestOptions({query:{attachmentIds:b.join(",")},
method:"post"}))).data.deleteAttachmentResults.map(n.createFeatureEditResult)}catch(e){throw this._createAttachmentErrorResult(a,e);}}fetchRecomputedExtents(a={}){return this.load({signal:a.signal}).then(async()=>{var b=this._getLayerRequestOptions({...a,query:{returnUpdates:!0}});const {layerId:c,url:e}=this.layer;({data:b}=await k(`${e}/${c}`,b));const {id:d,extent:f,fullExtent:h,timeExtent:g}=b;b=f||h;return{id:d,fullExtent:b&&R.fromJSON(b),timeExtent:g&&M.fromJSON({start:g[0],end:g[1]})}})}async queryAttachments(a,
b={}){await this.load();b=this._getLayerRequestOptions(b);return this.queryTask.executeAttachmentQuery(a,b)}async queryFeatures(a,b){await this.load();b=await this.queryTask.execute(a,{...b,query:this._createRequestQueryOptions(b)});a.outStatistics?.length&&b.features.length&&b.features.forEach(c=>{const e=c.attributes;a.outStatistics?.forEach(({outStatisticFieldName:d})=>{if(d){const f=d.toLowerCase();f&&f in e&&d!==f&&(e[d]=e[f],delete e[f])}})});return b}async queryFeaturesJSON(a,b){await this.load();
return this.queryTask.executeJSON(a,{...b,query:this._createRequestQueryOptions(b)})}async queryObjectIds(a,b){await this.load();return this.queryTask.executeForIds(a,{...b,query:this._createRequestQueryOptions(b)})}async queryFeatureCount(a,b){await this.load();return this.queryTask.executeForCount(a,{...b,query:this._createRequestQueryOptions(b)})}async queryExtent(a,b){await this.load();return this.queryTask.executeForExtent(a,{...b,query:this._createRequestQueryOptions(b)})}async queryRelatedFeatures(a,
b){await this.load();return this.queryTask.executeRelationshipQuery(a,{...b,query:this._createRequestQueryOptions(b)})}async queryRelatedFeaturesCount(a,b){await this.load();return this.queryTask.executeRelationshipQueryForCount(a,{...b,query:this._createRequestQueryOptions(b)})}async queryTopFeatures(a,b){await this.load();return this.queryTask.executeTopFeaturesQuery(a,{...b,query:this._createRequestQueryOptions(b)})}async queryTopObjectIds(a,b){await this.load();return this.queryTask.executeForTopIds(a,
{...b,query:this._createRequestQueryOptions(b)})}async queryTopExtents(a,b){await this.load();return this.queryTask.executeForTopExtents(a,{...b,query:this._createRequestQueryOptions(b)})}async queryTopCount(a,b){await this.load();return this.queryTask.executeForTopCount(a,{...b,query:this._createRequestQueryOptions(b)})}async fetchPublishingStatus(){if(!V.isHostedAgolService(this.layer.url))return"unavailable";var a=H.join(this.layer.url,"status");a=await k(a,{query:{f:"json"}});return da.fromJSON(a.data.status)}async uploadAssets(a,
b){const {uploadAssets:c}=await new Promise((e,d)=>K(["./support/uploadAssets"],e,d));return c(a,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},b)}async _asyncApplyEdits(a,b){for(a=(await k(a,b)).data.statusUrl;;){b=(await k(a,{query:{f:"json"},responseType:"json"})).data;switch(b.status){case "Completed":return k(b.resultUrl,{query:{f:"json"},responseType:"json"});case "CompletedWithErrors":throw new x("async-applyEdits-failed","asynchronous applyEdits call failed.");case "Failed ImportChanges":case "InProgress":case "Pending":case "ExportAttachments":case "ExportChanges":case "ExportingData":case "ExportingSnapshot":case "ImportAttachments":case "ProvisioningReplica":case "UnRegisteringReplica":break;
default:throw new x("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)");}await A.after(1E3)}}_createRequestQueryOptions(a){a={...this.layer.customParameters,token:this.layer.apiKey,...a?.query};this.layer.datesInUnknownTimezone&&(a.timeReferenceUnknownClient=!0);return a}async _fetchService(a,b){a||(a={},E("featurelayer-advanced-symbols")&&(a.returnAdvancedSymbols=!0),b?.cacheBust&&(a._ts=Date.now()),{data:a}=await k(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:a,
signal:b?.signal})));this.sourceJSON=await this._patchServiceJSON(a,b?.signal);b=a.type;if(!ca.has(b))throw new x("feature-layer-source:unsupported-type",`Source type "${b}" is not supported`);}async _patchServiceJSON(a,b){if("Table"!==a.type&&a.geometryType&&!a?.drawingInfo?.renderer&&!a.defaultSymbol){const c=T.createDrawingInfo(a.geometryType).renderer;O.setDeepValue("drawingInfo.renderer",c,a)}"esriGeometryMultiPatch"===a.geometryType&&a.infoFor3D&&(a.geometryType="mesh");if(null==a.extent)try{const {data:c}=
await k(this.layer.url,this._getLayerRequestOptions({signal:b}));c.spatialReference&&(a.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:c.spatialReference})}catch(c){A.throwIfAbortError(c)}return a}async _ensureLatestMetadata(a){if(this.layer.userHasUpdateItemPrivileges&&0<this.sourceJSON.cacheMaxAge)return this._fetchService(null,{...a,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(a){var {addAssetFeatures:b}=a;if(!b?.length)return null;a=await this._filterRedundantAssetMaps(b);if(!b?.length)return null;
b=[];const c=new Map;for(const d of a){const {geometry:f}=d;var {vertexSpace:e}=f;I.isRelativeVertexSpace(e)?b.push(f):(e=I.toRelativeVertexSpace(f),c.set(e,f),d.geometry=e,b.push(e))}await this.uploadAssets(b);for(const [d,f]of c)f.addExternalSources(d.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(a),updates:[],deletes:[]}}_getAssetMapEditsJSON(a){const b=[],c=this.layer.globalIdField,e=this.layer.parsedUrl;for(const h of a){var d=h.geometry;({metadata:a}=d);var f=a.getExternalSourcesOnService(e);
a=h.getAttribute(c);if(0===f.length)G.getLogger(this).error(`Skipping feature ${a}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);else{({source:f}=f.find(S.isOriginalExternal)??f[0]);({vertexSpace:d}=d);d="georeferenced"===d.type?["PROJECT_VERTICES"]:[];for(const g of f)1!==g.parts.length?G.getLogger(this).error(`Skipping asset ${g.assetName}. It does not have exactly one part, so we cannot map it to a feature.`):b.push({globalId:P.generateBracedUUID(),
parentGlobalId:a,assetName:g.assetName,assetHash:g.parts[0].partHash,flags:d})}}return b}_createEditsResult(a){var b=a.data;const {layerId:c}=this.layer;a=[];let e=null;if(Array.isArray(b))for(var d of b)a.push({id:d.id,editedFeatures:d.editedFeatures}),d.id===c&&(e={addResults:d.addResults??[],updateResults:d.updateResults??[],deleteResults:d.deleteResults??[],attachments:d.attachments,editMoment:d.editMoment});else e=b;d=n.unpackEditResultData(e);if(0<a.length){d.editedFeatureResults=[];for(const f of a)({editedFeatures:a}=
f),b=a?.spatialReference?new aa(a.spatialReference):null,d.editedFeatureResults.push({layerId:f.id,editedFeatures:n.createEditedFeatures(a,b)})}return d}_createAttachmentErrorResult(a,b){return{objectId:a,globalId:null,error:new x("feature-layer-source:attachment-failure",b.details.messages?.[0]||b.message,{code:b.details.httpStatus||b.details.messageCode})}}_getFormDataForAttachment(a,b){if(a=a instanceof FormData?a:a&&a.elements?new FormData(a):null)for(const c in b){const e=b[c];null!=e&&(a.set?
a.set(c,e):a.append(c,e))}return a}_getLayerRequestOptions(a={}){const {parsedUrl:b,gdbVersion:c,dynamicDataSource:e}=this.layer;return{...a,query:{gdbVersion:c,layer:e?JSON.stringify({source:e}):void 0,...b.query,f:"json",...this._createRequestQueryOptions(a)},responseType:"json"}}async _filterRedundantAssetMaps(a){var {layer:b}=this;const {globalIdField:c,infoFor3D:e,parsedUrl:d}=b;if(null==e||null==c)return a;b=W.getAssetMapTable(e);if(null==b)return a;var f=H.join(d.path,`../${b.id}`);b=[];const h=
[];for(var g of a)0<g.geometry.metadata.getExternalSourcesOnService(d).length?h.push(g):b.push(g);g=h.map(m=>m.getAttribute(c)).filter(z.isSome);if(0===g.length)return a;const {assetMapFieldRoles:{parentGlobalId:p,assetHash:t}}=e,q=new Z;q.where=`${p} IN (${g.map(m=>`'${m}'`)})`;q.outFields=[t,p];q.returnGeometry=!1;f=await X.executeQueryJSON(f,q);const {features:l}=f;return 0===l.length?a:[...b,...h.filter(m=>{const r=m.getAttribute(c);if(!r)return!0;({metadata:m}=m.geometry);const J=l.filter(u=>
u.getAttribute(p)===r);if(0===J.length)return!0;const ea=J.map(u=>u.getAttribute(t));return m.getExternalSourcesOnService(d).flatMap(({source:u})=>u.flatMap(D=>D.parts.map(fa=>fa.partHash))).some(u=>ea.every(D=>u!==D))})]}};w.__decorate([B.property()],v.prototype,"type",void 0);w.__decorate([B.property({constructOnly:!0})],v.prototype,"layer",void 0);w.__decorate([B.property({readOnly:!0})],v.prototype,"queryTask",null);return v=w.__decorate([Q.subclass("esri.layers.graphics.sources.FeatureLayerSource")],
v)});