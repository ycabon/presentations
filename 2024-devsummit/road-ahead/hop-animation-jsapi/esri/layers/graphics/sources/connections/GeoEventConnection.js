// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require ../../../../chunks/tslib.es6 ../../../../geometry ../../../../request ../../../../core/Error ../../../../core/Logger ../../../../core/promiseUtils ../../../../core/urlUtils ../../../../core/has ../../../../core/RandomLCG ../../../../core/accessorSupport/decorators/subclass ./WebSocketConnection ../../../../rest/query/operations/query ../../../../rest/support/Query ../../../../geometry/support/jsonUtils ../../../../geometry/SpatialReference".split(" "),function(p,q,m,r,k,h,t,u,E,F,
v,w,n,x,y,z){const A={maxQueryDepth:5,maxRecordCountFactor:3};m=class extends w.WebSocketConnection{constructor(a){super({...A,...a});this._relatedFeatures=this._buddyServicesQuery=null}async _open(){var a=await this._fetchServiceDefinition(this._config.source);a.timeInfo.trackIdField||h.getLogger(this).warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");a=this._fetchWebSocketUrl(a.streamUrls,
this._config.spatialReference);this._buddyServicesQuery||(this._buddyServicesQuery=this._queryBuddyServices());await this._buddyServicesQuery;await this._tryCreateWebSocket(a);const {filter:b,outFields:c}=this._config;this.destroyed||this._setFilter(b,c)}_onMessage(a){if("attributes"in a){let b;try{b=this._enrich(a),null!=this._featureZScaler&&this._featureZScaler(b.geometry)}catch(c){h.getLogger(this).error(new k("geoevent-connection","Failed to parse message",c));return}this.onFeature(b)}else this.onMessage(a)}async _fetchServiceDefinition(a){return this._serviceDefinition=
a=(await r(a.path,{query:{f:"json",...this._config.customParameters},responseType:"json"})).data}_fetchWebSocketUrl(a,b){const {urls:c,token:d}=a[0];a=this._inferWebSocketBaseUrl(c);return u.addQueryParameters(`${a}/subscribe`,{outSR:""+b.wkid,token:d})}_inferWebSocketBaseUrl(a){if(1===a.length)return a[0];for(const b of a)if(b.includes("wss"))return b;h.getLogger(this).error(new k("geoevent-connection","Unable to infer WebSocket url",a));return null}async _setFilter(a,b){const c=this._websocket;
if(null!=c&&(null!=a||null!=b)){a=JSON.stringify({filter:this._serializeFilter(a,b)});var d=!1,e=t.createResolver();c.onmessage=f=>{f=JSON.parse(f.data);f.filter&&(f.error&&(h.getLogger(this).error(new k("geoevent-connection","Failed to set service filter",f.error)),this._set("errorString",`Could not set service filter - ${f.error}`),e.reject(f.error)),this._setWebSocketJSONParseHandler(c),d=!0,e.resolve())};c.send(a);setTimeout(()=>{d||(this.destroyed||this._websocket!==c||h.getLogger(this).error(new k("geoevent-connection",
"Server timed out when setting filter")),e.reject())},1E4);return e.promise}}_serializeFilter(a,b){const c={};if(null==a&&null==b)return c;if(a?.geometry)try{const d=y.fromJSON(a.geometry);if("extent"!==d.type)throw new k(`Expected extent but found type ${d.type}`);c.geometry=JSON.stringify(d.shiftCentralMeridian())}catch(d){h.getLogger(this).error(new k("geoevent-connection","Encountered an error when setting connection geometryDefinition",d))}a?.where&&"1 \x3d 1"!==a.where&&"1\x3d1"!==a.where&&
(c.where=a.where);null!=b&&(c.outFields=b.join(","));return c}_enrich(a){if(!this._relatedFeatures)return a;const b=this._relatedFeatures.get(a.attributes[this._serviceDefinition.relatedFeatures.joinField]);if(!b)return h.getLogger(this).warn("geoevent-connection","Feature join failed. Is the join field configured correctly?",a),a;const {attributes:c,geometry:d}=b;for(const e in c)a.attributes[e]=c[e];d&&(a.geometry=d);a.geometry||a.centroid||h.getLogger(this).error(new k("geoevent-connection","Found malformed feature - no geometry found",
a));return a}async _queryBuddyServices(){try{const {relatedFeatures:a,keepLatestArchive:b}=this._serviceDefinition,c=this._queryRelatedFeatures(a),d=this._queryArchive(b);await c;const e=await d;if(e)for(const f of e.features)this.onFeature(this._enrich(f))}catch(a){h.getLogger(this).error(new k("geoevent-connection","Encountered an error when querying buddy services",{error:a}))}}async _queryRelatedFeatures(a){a&&(a=await this._queryBuddy(a.featuresUrl),this._addRelatedFeatures(a))}async _queryArchive(a){if(a)return this._queryBuddy(a.featuresUrl)}async _queryBuddy(a){const b=
new (await new Promise((B,C)=>p(["../../../FeatureLayer"],D=>B(Object.freeze(Object.defineProperty({__proto__:null,default:D},Symbol.toStringTag,{value:"Module"}))),C))).default({url:a});var {capabilities:c}=await b.load();const d=c.query.supportsMaxRecordCountFactor,e=c.query.supportsPagination;c=c.query.supportsCentroid;const f=this._config.maxRecordCountFactor;var l=b.capabilities.query.maxRecordCount;l=d?l*f:l;const g=new x;g.outFields=this._config.outFields??["*"];g.where=this._config.filter?.where??
"1\x3d1";g.returnGeometry=!0;g.returnExceededLimitFeatures=!0;g.outSpatialReference=z.fromJSON(this._config.spatialReference);c&&(g.returnCentroid=!0);d&&(g.maxRecordCountFactor=f);if(e)return g.num=l,b.destroy(),this._queryPages(a,g);a=await n.executeQuery(a,g,this._config.sourceSpatialReference);b.destroy();return a.data}async _queryPages(a,b,c=[],d=0){b.start=null!=b.num?d*b.num:null;const {data:e}=await n.executeQuery(a,b,this._config.sourceSpatialReference);if(e.exceededTransferLimit&&d<(this._config.maxQueryDepth??
0))return e.features.forEach(f=>c.push(f)),this._queryPages(a,b,c,d+1);c.forEach(f=>e.features.push(f));return e}_addRelatedFeatures(a){const b=new Map;a=a.features;const c=this._serviceDefinition.relatedFeatures.joinField;for(const d of a)b.set(d.attributes[c],d);this._relatedFeatures=b}};return m=q.__decorate([v.subclass("esri.layers.graphics.sources.connections.GeoEventConnection")],m)});