// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/tslib.es6 ../../geometry ../../Graphic ../../rasterRenderers ../../request ../../core/deprecate ../../core/Error ../../core/lang ../../core/Logger ../../core/reactiveUtils ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../geometry/support/spatialReferenceUtils ../support/commonProperties ../support/DimensionalDefinition ../support/ExportImageServiceParameters ../support/Field ../support/FieldsIndex ../support/imageBitmapUtils ../support/imageryRendererUtils ../support/MosaicRule ../support/MultidimensionalSubset ../support/PixelBlock ../support/rasterEnums ../support/RasterFunction ../support/RasterInfo ../support/RasterJobHandler ../support/rasterDatasets/multidimensionalUtils ../support/rasterFormats/RasterCodec ../support/rasterFunctions/vectorFieldUtils ../../renderers/support/rasterRendererHelper ../../renderers/support/RasterSymbolizer ../../rest/imageService ../../core/has ../support/source/DataLayerSource ../../rest/query/executeQueryJSON ../../config ../../kernel ../../core/unitUtils ../../geometry/ellipsoidUtils ../../geometry/support/aaBoundingBox ../../core/mathUtils ../../geometry/Extent ../../geometry/Geometry ../../geometry/Multipoint ../../geometry/Point ../../geometry/Polygon ../../geometry/Polyline ../../geometry/support/normalizeUtilsCommon ../../geometry/SpatialReference ../../geometry/support/Ellipsoid ../../core/pbf ../../rest/support/FeatureSet ../../rest/support/Query ../../rest/query/support/AttachmentInfo ../../rest/support/AttachmentQuery ../../rest/query/executeForCount ../../rest/query/executeForIds ../../rest/support/RelationshipQuery ../../rest/support/TopFeaturesQuery ../../rest/imageService/fetchRasterInfo ../../rest/imageService/getCatalogItemRasterInfo ../../rest/support/FindImagesParameters ../../rest/support/ImageAngleParameters ../../rest/support/ImageAreaParameters ../../rest/support/ImageBoundaryParameters ../../rest/support/ImageDistanceParameters ../../rest/support/ImageGPSInfoParameters ../../rest/support/ImageHeightParameters ../../rest/support/ImageHistogramParameters ../../rest/support/ImageIdentifyParameters ../../rest/support/ImagePixelLocationParameters ../../rest/support/ImagePointParameters ../../rest/support/ImageSampleParameters ../../rest/support/ImageToMapMultirayParameters ../../rest/support/ImageToMapParameters ../../rest/support/ImageUrlParameters ../../rest/support/MapToImageParameters ../../rest/support/MeasureFromImageParameters ../../views/2d/engine/flow/dataUtils".split(" "),
function(X,h,Va,ia,N,B,Y,r,Z,J,ja,ka,n,v,A,la,H,aa,ba,ma,na,F,oa,ca,pa,G,qa,O,C,E,ra,sa,I,P,ta,K,ua,w,Wa,Xa,va,Ya,Za,$a,ab,bb,cb,Q,db,eb,fb,R,gb,hb,S,ib,jb,wa,T,kb,lb,xa,ya,mb,nb,U,za,Aa,Ba,Ca,Da,Ea,Fa,Ga,V,da,Ha,Ia,Ja,Ka,La,Ma,Na,ea,Oa){function Pa(f){return f?(f=JSON.stringify(f).match(/"rasterFunction":"(.*?")/gi)?.map(u=>u.replace('"rasterFunction":"',"").replace('"',"")))?f.join("/"):null:null}const Qa=new Set("png png8 png24 png32 jpg bmp gif jpgpng lerc tiff".split(" ")),Ra=n.ensureRange(v.ensureNumber,
{min:0,max:255});X.ArcGISImageService=f=>{function u(a){return a?.path??""}f=class extends f{constructor(){super(...arguments);this._functionRasterInfos={};this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null};this._serviceSupportsMosaicRule=this._cachedRendererJson=null;this._rasterAttributeTableFieldPrefix="Raster.";this.adjustAspectRatio=null;this.bandIds=void 0;this.capabilities=null;this.compressionQuality=void 0;this.compressionTolerance=.01;this.fullExtent=this.fields=this.rasterInfo=
this.exportImageServiceParameters=this.definitionExpression=this.defaultMosaicRule=this.copyright=null;this.hasMultidimensions=!1;this.imageMaxWidth=this.imageMaxHeight=4100;this.interpolation=void 0;this.maxScale=this.minScale=0;this.noData=this.multidimensionalSubset=this.multidimensionalInfo=null;this.noDataInterpretation=void 0;this.objectIdField=null;this.geometryType="polygon";this.typeIdField=null;this.types=[];this.pixelFilter=null;this.raster=void 0;this.sourceType=null;this.viewId=void 0;
this.url=this.sourceJSON=this.serviceRasterInfo=this.pixelType=this.spatialReference=this.serviceDataType=this.rasterFunctionInfos=this.symbolizer=null;this.version=void 0}initialize(){this._set("exportImageServiceParameters",new na.ExportImageServiceParameters({layer:this}))}readServiceSupportsMosaicRule(a,b){return this._isMosaicRuleSupported(b)}get _rasterFunctionNamesIndex(){const a=new Map;if(!this.rasterFunctionInfos||null!=this.rasterFunctionInfos&&1>this.rasterFunctionInfos.length)return a;
null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.forEach(b=>{a.set(b.name.toLowerCase().replaceAll(/ /gi,"_"),b.name)});return a}readBandIds(a,b){if(Array.isArray(a)&&0<a.length&&a.every(c=>"number"===typeof c))return a}readCapabilities(a,b){return this._readCapabilities(b)}writeCompressionQuality(a,b,c){null!=a&&"lerc"!==this.format&&(b[c]=a)}writeCompressionTolerance(a,b,c){"lerc"===this.format&&null!=a&&(b[c]=a)}readDefaultMosaicRule(a,b){return this._serviceSupportsMosaicRule?G.fromJSON(b):
null}get fieldsIndex(){return this.fields?new oa(this.fields):null}set format(a){a&&Qa.has(a.toLowerCase())&&this._set("format",a.toLowerCase())}readFormat(a,b){return"esriImageServiceDataTypeVector-UV"===b.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===b.serviceDataType?"lerc":null!=this.pixelFilter?"lerc":"jpgpng"}readMinScale(a,b){return null!=b.minLOD&&null!=b.maxLOD?a:0}readMaxScale(a,b){return null!=b.minLOD&&null!=b.maxLOD?a:0}set mosaicRule(a){a?.mosaicMethod&&(a=G.fromJSON({...a.toJSON(),
mosaicMethod:a.mosaicMethod,mosaicOperation:a.mosaicOperation}));this._set("mosaicRule",a)}readMosaicRule(a,b){return(a=a||b.mosaicRule)?G.fromJSON(a):this._isMosaicRuleSupported(b)?G.fromJSON(b):null}writeMosaicRule(a,b,c){a=this.mosaicRule;const d=this.definitionExpression;a?d&&d!==a.where&&(a=a.clone(),a.where=d):d&&(a=new G({where:d}));this._isValidCustomizedMosaicRule(a)&&(b[c]=a.toJSON())}writeNoData(a,b,c){null!=a&&"number"===typeof a&&(b[c]=Ra(a))}readObjectIdField(a,b){a||=b.fields.find(c=>
"esriFieldTypeOID"===c.type||"oid"===c.type)?.name;return a}get parsedUrl(){return ka.urlToObject(this.url)}readSourceType(a,b){return this._isMosaicDataset(b)?"mosaic-dataset":"raster-dataset"}set renderer(a){this.loaded&&(a=this._configRenderer(a));this._set("renderer",a)}readRenderer(a,b,c){a=b?.layerDefinition?.drawingInfo?.renderer;c=N.read(a,c);if(null==c)return null;"vector-field"===c.type&&b.symbolTileSize&&!a.symbolTileSize&&(c.symbolTileSize=b.symbolTileSize);pa.isSupportedRendererType(c)||
J.getLogger(this).warn("ArcGISImageService","Imagery layer doesn't support given renderer type.");return c}writeRenderer(a,b,c){b.layerDefinition=b.layerDefinition||{};b.layerDefinition.drawingInfo=b.layerDefinition.drawingInfo||{};b.layerDefinition.drawingInfo.renderer=a.toJSON();"vector-field"===a.type&&(b.symbolTileSize=a.symbolTileSize)}get rasterFields(){const a=this._rasterAttributeTableFieldPrefix;var b=new F({name:"Raster.ItemPixelValue",alias:"Item Pixel Value",domain:null,editable:!1,length:50,
type:"string"});const c=new F({name:"Raster.ServicePixelValue",alias:"Service Pixel Value",domain:null,editable:!1,length:50,type:"string"}),d=new F({name:"Raster.ServicePixelValue.Raw",alias:"Raw Service Pixel Value",domain:null,editable:!1,length:50,type:"string"});let g=this.fields?Z.clone(this.fields):[];g.push(c);this.capabilities?.operations.supportsQuery&&this.fields&&0<this.fields.length&&g.push(b);10.4<=this.version&&null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.some(e=>"none"===
e.name.toLowerCase())&&g.push(d);null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.filter(e=>"none"!==e.name.toLowerCase()).forEach(e=>{g.push(new F({name:"Raster.ServicePixelValue."+e.name,alias:e.name,domain:null,editable:!1,length:50,type:"string"}))});this._isVectorDataSet()&&(g.push(new F({name:"Raster.Magnitude",alias:"Magnitude",domain:null,editable:!1,type:"double"})),g.push(new F({name:"Raster.Direction",alias:"Direction",domain:null,editable:!1,type:"double"})));({attributeTable:b}=
this.rasterInfo??{});null!=b&&(b=b.fields.filter(e=>"esriFieldTypeOID"!==e.type&&"value"!==e.name.toLowerCase()).map(e=>{const m=Z.clone(e);m.name=a+e.name;return m}),g=g.concat(b));return g}get renderingRule(){Y.deprecatedProperty(J.getLogger(this),"renderingRule",{replacement:"rasterFunction",version:"4.27",warnOnce:!0});return this.rasterFunction}set renderingRule(a){Y.deprecatedProperty(J.getLogger(this),"renderingRule",{replacement:"rasterFunction",version:"4.27",warnOnce:!0});this._set("rasterFunction",
a)}set rasterFunction(a){a?.rasterFunction&&(a=E.fromJSON({...a.toJSON(),rasterFunction:a.rasterFunction,rasterFunctionArguments:a.rasterFunctionArguments}));this._set("rasterFunction",a)}readRasterFunction(a,b){a=b.rasterFunctionInfos;return b.renderingRule||a?.length&&"None"!==a[0].name?this._isRFTJson(b.renderingRule)?E.fromJSON({rasterFunctionDefinition:b.renderingRule}):E.fromJSON(b.renderingRule||{rasterFunctionInfos:b.rasterFunctionInfos}):null}readSpatialReference(a,b){return(a=a||b.extent.spatialReference)?
S.fromJSON(a):null}readPixelType(a){return C.pixelTypeKebabDict.fromJSON(a)||a}writePixelType(a,b,c){if(null==this.serviceRasterInfo||this.pixelType!==this.serviceRasterInfo.pixelType)b[c]=C.pixelTypeKebabDict.toJSON(a)}readVersion(a,b){(a=b.currentVersion)||(a=b.hasOwnProperty("fields")||b.hasOwnProperty("timeInfo")?10:9.3);return a}applyFilter(a){let b=a;this.pixelFilter&&(b=this._clonePixelData(a),this.pixelFilter(b));return b}async applyRenderer(a,b){var c=a;const {renderer:d,symbolizer:g,pixelFilter:e,
bandIds:m}=this;if(!this._isPicture()&&d&&g&&!e){c=JSON.stringify(this._cachedRendererJson)!==JSON.stringify(d.toJSON());const k=this._rasterJobHandler.instance;k?(c&&(g.bind(),await k.updateSymbolizer(g,b),this._cachedRendererJson=d.toJSON()),b=await k.symbolize({bandIds:m,...a},b),c={extent:a.extent,pixelBlock:b}):c={extent:a.extent,pixelBlock:g.symbolize({bandIds:m,...a})}}return c}destroy(){this._shutdownJobHandler()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--;
0>=this._rasterJobHandler.refCount&&this._shutdownJobHandler()}async computeAngles(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputeAngles)throw new r("imagery-layer:compute-angles","this operation is not supported on the input image service");a=v.ensureClass(Ba,a).clone();return w.computeAngles(this.url,a,this._getRequestOptions(b))}async computePixelSpaceLocations(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputePixelLocation)throw new r("imagery-layer:compute-pixel-space-locations",
"this operation is not supported on the input image service");a=v.ensureClass(Ha,a).clone();return w.computePixelSpaceLocations(this.url,a,this._getRequestOptions(b))}async computeHistograms(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputeHistograms)throw new r("imagery-layer:compute-histograms","this operation is not supported on the input image service");a=v.ensureClass(V,a).clone();this._applyMosaicAndRenderingRules(a);return w.computeHistograms(this.url,a,this._getRequestOptions(b))}async computeStatisticsHistograms(a,
b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsComputeStatisticsHistograms)throw new r("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");a=v.ensureClass(V,a).clone();this._applyMosaicAndRenderingRules(a);return w.computeStatisticsHistograms(this.url,a,this._getRequestOptions(b))}async measureHeight(a,b){const c=await this._fetchCapabilities(b?.signal);if(!("base-and-top"===a.operationType?c.mensuration.supportsHeightFromBaseAndTop:
"base-and-top-shadow"===a.operationType?c.mensuration.supportsHeightFromBaseAndTopShadow:c.mensuration.supportsHeightFromTopAndTopShadow))throw new r("imagery-layer:measure-height","this operation is not supported on the input image service");a=v.ensureClass(Ga,a).clone();this._applyMosaicAndRenderingRules(a);return w.measureHeight(this.url,a,this._getRequestOptions(b))}async measureAreaAndPerimeter(a,b){const c=await this._fetchCapabilities(b?.signal);if(!c.mensuration.supportsAreaAndPerimeter||
a.is3D&&!c.mensuration.supports3D)throw new r("imagery-layer:measure-area-and-perimeter","this operation is not supported on the input image service");a=v.ensureClass(Ca,a).clone();this._applyMosaicAndRenderingRules(a);return w.measureAreaAndPerimeter(this.url,a,this._getRequestOptions(b))}async measureDistanceAndAngle(a,b){const c=await this._fetchCapabilities(b?.signal);if(!c.mensuration.supportsDistanceAndAngle||a.is3D&&!c.mensuration.supports3D)throw new r("imagery-layer:measure-distance-and-angle",
"this operation is not supported on the input image service");a=v.ensureClass(Ea,a).clone();this._applyMosaicAndRenderingRules(a);return w.measureDistanceAndAngle(this.url,a,this._getRequestOptions(b))}async measurePointOrCentroid(a,b){const c=await this._fetchCapabilities(b?.signal);if(!c.mensuration.supportsPointOrCentroid||a.is3D&&!c.mensuration.supports3D)throw new r("imagery-layer:measure-point-or-centroid","this operation is not supported on the input image service");a=v.ensureClass(Ia,a).clone();
this._applyMosaicAndRenderingRules(a);return w.measurePointOrCentroid(this.url,a,this._getRequestOptions(b))}async measureLengthFromImage(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsMeasureFromImage)throw new r("imagery-layer:measure-length-from-image","this operation is not supported on the input image service");if("polyline"!==a.geometry.type)throw new r("imagery-layer:measure-length-from-image","this input geometry must be a polyline");a=v.ensureClass(ea,a).clone();return w.measureLengthFromImage(this.url,
a,this._getRequestOptions(b))}async measureAreaFromImage(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsMeasureFromImage)throw new r("imagery-layer:measure-area-from-image","this operation is not supported on the input image service");if("polygon"!==a.geometry.type)throw new r("imagery-layer:measure-area-from-image","this input geometry must be a polygon");a=v.ensureClass(ea,a).clone();return w.measureAreaFromImage(this.url,a,this._getRequestOptions(b))}getField(a){const {fieldsIndex:b}=
this;return null!=b?b.get(a):void 0}getFieldDomain(a,b){return(a=this.getField(a))?a.domain:null}async fetchImage(a,b,c,d={}){if(null==a||null==b||null==c)throw new r("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required.");if(this.renderer||this.symbolizer){var g=await this._generateRasterInfo(this.rasterFunction,{signal:d.signal});g&&(this.rasterInfo=g)}g=this.getExportImageServiceParameters(a,b,c,d.timeExtent);if(null==
g){if(d.requestAsImageElement&&this._canRequestImageElement(this.format))return a=document.createElement("canvas"),a.width=b,a.height=c,d.returnImageBitmap?{imageBitmap:await ca.createBitmap(a,`${u(this.parsedUrl)}/exportImage`,d.signal)}:{imageOrCanvasElement:a};const {bandIds:m,rasterInfo:k}=this;d=(m?.length||k.bandCount)??0;g=b*c;var e=k.pixelType;const p=[];for(let l=0;l<d;l++)p.push(O.createEmptyBand(e,g));return{pixelData:{pixelBlock:new O({width:b,height:c,pixels:p,mask:new Uint8Array(g),
pixelType:e}),extent:a}}}e=!!d.requestAsImageElement&&!this.pixelFilter;return this._requestArrayBuffer({imageServiceParameters:g,imageProps:{extent:a,width:b,height:c,format:this.format},requestAsImageElement:e,returnImageBitmap:e&&!!d.returnImageBitmap,signal:d.signal})}fetchKeyProperties(a){return B(u(this.parsedUrl)+"/keyProperties",{query:this._getQueryParams({renderingRule:10.3<=this.version?a?.rasterFunction:null})}).then(b=>b.data)}fetchRasterAttributeTable(a){return 10.1>this.version?Promise.reject(new r("#fetchRasterAttributeTable()",
"Failed to get rasterAttributeTable")):B(u(this.parsedUrl)+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:10.3<=this.version?a?.rasterFunction:null})}).then(b=>wa.fromJSON(b.data))}getCatalogItemRasterInfo(a,b){const c=this._getQueryParams();b={...b,query:c};return za.getCatalogItemRasterInfo(u(this.parsedUrl),a,b)}async getCatalogItemICSInfo(a,b){var {data:c}=await B(u(this.parsedUrl)+"/"+a+"/info/ics",{query:this._getQueryParams(),...b});if(c=c?.ics){var d=null;try{d=(await B(u(this.parsedUrl)+
"/"+a+"/info",{query:this._getQueryParams(),...b})).data.extent}catch{}if(!d||!d.spatialReference)return{ics:c,icsToPixelTransform:null,icsExtent:null,northDirection:null};var g=10.7<=this.version?B(u(this.parsedUrl)+"/"+a+"/info/icstopixel",{query:this._getQueryParams(),...b}).then(q=>q.data).catch(()=>({})):{},e=d.spatialReference,m={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[d]}),inSR:aa.srToRESTValue(e),outSR:"0:"+a};m=B(u(this.parsedUrl)+"/project",{query:this._getQueryParams(m),
...b}).then(q=>q.data).catch(()=>({}));var k=(d.xmin+d.xmax)/2,p=(d.ymax-d.ymin)/6;d=d.ymin+p;var l=[];for(let q=0;5>q;q++)l.push({x:k,y:d+p*q});a={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:l}),inSR:aa.srToRESTValue(e),outSR:"0:"+a};b=B(u(this.parsedUrl)+"/project",{query:this._getQueryParams(a),...b}).then(q=>q.data).catch(()=>({}));a=await Promise.all([g,m,b]);b=a[0].ipxf;null==b&&(g=c.geodataXform?.xf_0,"topup"===g?.name?.toLowerCase()&&6===g?.coefficients?.length&&
(b={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:g.coefficients,cellsizeRatio:0,type:"GeometricXform"}}));if(g=Q.fromJSON(a[1]?.geometries?.[0]))g.spatialReference=new S({wkid:0,imageCoordinateSystem:c});a=a[2].geometries?a[2].geometries.filter(q=>null!=q?.x&&null!=q.y&&"NaN"!==q.x&&"NaN"!==q.y):[];m=a.length;if(3>m)return{ics:c,icsToPixelTransform:b,icsExtent:g,northDirection:null};d=p=k=e=0;for(l=0;l<m;l++)e+=a[l].x,k+=a[l].y,p+=a[l].x*a[l].x,d+=a[l].x*a[l].y;
m=(m*d-e*k)/(m*p-e*e);e=0;k=a[4].x>a[0].x;a=a[4].y>a[0].y;Infinity===m?e=a?90:270:0===m?e=k?0:180:0<m?e=k?180*Math.atan(m)/Math.PI:180*Math.atan(m)/Math.PI+180:0>m&&(e=a?180+180*Math.atan(m)/Math.PI:360+180*Math.atan(m)/Math.PI);return{ics:c,icsToPixelTransform:b,icsExtent:g,northDirection:e}}}async generateRasterInfo(a,b){a=v.ensureClass(E,a);if(this.serviceRasterInfo&&(!a||"none"===a.functionName?.toLowerCase()||this._isVectorFieldResampleFunction(a)))return this.serviceRasterInfo;const c=Pa(a);
if(!c)throw new r("imagery-layer:generate-raster-info","the rendering rule is not supported");if(this._functionRasterInfos[c])return this._functionRasterInfos[c];const d=this._getQueryParams();b={...b,query:d};a=U.generateRasterInfo(u(this.parsedUrl),a,b);this._functionRasterInfos[c]=a;try{return await a}catch(g){throw this._functionRasterInfos[c]=null,g;}}getExportImageServiceParameters(a,b,c,d){a=a.clone().shiftCentralMeridian();const g=w.getImageSpatialReferenceQueryParameter(a.spatialReference,
u(this.parsedUrl));this.pixelType!==this.serviceRasterInfo.pixelType&&(this.exportImageServiceParameters.pixelType=this.pixelType);const e=this.exportImageServiceParameters.toJSON(),{bandIds:m,noData:k}=e;var {renderingRule:p}=e,l=this.rasterFunction?.rasterFunctionDefinition,q=!this.renderer||"raster-stretch"===this.renderer.type;m?.length&&this._hasRasterFunction(this.rasterFunction)&&!l&&q?(l={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:m}},"Stretch"===p.rasterFunction?(l.rasterFunctionArguments.Raster=
p.rasterFunctionArguments.Raster,p.rasterFunctionArguments.Raster=l):"Colormap"===p.rasterFunction?(q=p.rasterFunctionArguments.Raster,"Stretch"===q?.rasterFunction?(l.rasterFunctionArguments.Raster=q.rasterFunctionArguments.Raster,q.rasterFunctionArguments.Raster=l):(l.rasterFunctionArguments.Raster=q,p.rasterFunctionArguments.Raster=l)):(l.rasterFunctionArguments.Raster=p,p=l),e.bandIds=void 0):e.bandIds=m?.join(",");k instanceof Array&&0<k.length&&(e.noData=k.join(","));d=this._processMultidimensionalIntersection(null,
d,this.exportImageServiceParameters.mosaicRule);if(d.isOutSide)return null;e.mosaicRule=null!=d.mosaicRule?JSON.stringify(d.mosaicRule):null;d=d.timeExtent;e.renderingRule=this._getRenderingRuleString(E.fromJSON(p));p={};if(null!=d){const {start:t,end:x}=d.toJSON();if(t&&x&&t===x)p.time=""+t;else if(null!=t||null!=x)p.time=`${null==t?"null":t},${null==x?"null":x}`}return{bbox:a.xmin+","+a.ymin+","+a.xmax+","+a.ymax,bboxSR:g,imageSR:g,size:b+","+c,...e,...p}}async getSamples(a,b){if(!(await this._fetchCapabilities(b?.signal))?.operations.supportsGetSamples)throw new r("imagery-layer:get-samples",
"getSamples operation is not supported on the input image service");a=v.ensureClass(Ja,a).clone();const {raster:c}=this;c&&null==a.raster&&(a.raster=c);return w.getSamples(this.url,a,this._getRequestOptions(b))}async identify(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsIdentify)throw new r("imagery-layer:identify","identify operation is not supported on the input image service");a=v.ensureClass(da,a).clone();10.91>this.version&&"extent"===a.geometry?.type&&(a.geometry=R.fromExtent(a.geometry));
const c=this._processMultidimensionalIntersection(a.geometry,a.timeExtent,a.mosaicRule||this.mosaicRule);if(c.isOutSide)throw new r("imagery-layer:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");a.timeExtent=c.timeExtent;a.mosaicRule=c.mosaicRule;const {raster:d,rasterFunction:g}=this;g&&null==a.rasterFunction&&(a.rasterFunction=g);d&&null==a.raster&&(a.raster=d);return w.identify(this.url,a,this._getRequestOptions(b))}async imageToMap(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsImageToMap)throw new r("imagery-layer:image-to-map",
"imageToMap operation is not supported on the input image service");a=v.ensureClass(La,a);return w.imageToMap(u(this.parsedUrl),a,this._getRequestOptions(b))}async imageToMapMultiray(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsImageToMapMultiray)throw new r("imagery-layer:image-to-map-multiray","imageToMapMultiray operation is not supported on the input image service");a=v.ensureClass(Ka,a);return w.imageToMapMultiray(u(this.parsedUrl),a,this._getRequestOptions(b))}async mapToImage(a,
b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsMapToImage)throw new r("imagery-layer:map-to-image","mapToImage operation is not supported on the input image service");a=v.ensureClass(Na,a);return w.mapToImage(u(this.parsedUrl),a,this._getRequestOptions(b))}async findImages(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsFindImages)throw new r("imagery-layer:find-images","findImages operation is not supported on the input image service");a=v.ensureClass(Aa,
a);return w.findImages(u(this.parsedUrl),a,this._getRequestOptions(b))}async getImageUrl(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsGetImageUrl)throw new r("imagery-layer:get-image-url","getImageUrl operation is not supported on the input image service");a=v.ensureClass(Ma,a);return w.getImageUrl(u(this.parsedUrl),a,this._getRequestOptions(b))}createQuery(){const a=new T;a.outFields=["*"];a.returnGeometry=!0;a.where=this.definitionExpression||"1\x3d1";return a}async queryBoundary(a,
b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsQueryBoundary)throw new r("imagery-layer:query-boundary","queryBoundary operation is not supported on the input image service");a=v.ensureClass(Da,a??{outSpatialReference:this.spatialReference}).clone();return w.queryBoundary(u(this.parsedUrl),a,this._getRequestOptions(b))}async queryRasters(a,b){({query:a,requestOptions:b}=await this._prepareForQuery(a,b));return va.executeQueryJSON(this.url,a,b)}async queryObjectIds(a,b){({query:a,
requestOptions:b}=await this._prepareForQuery(a,b));return ya.executeForIds(this.url,a,b)}async queryGPSInfo(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsQueryGPSInfo)throw new r("imagery-layer:query-gps-info","queryGPSInfo operation is not supported on the input image service");a=v.ensureClass(Fa,a??{outSpatialReference:this.spatialReference}).clone();return w.queryGPSInfo(u(this.parsedUrl),a,this._getRequestOptions(b))}async queryRasterCount(a,b){({query:a,requestOptions:b}=
await this._prepareForQuery(a,b));return xa.executeForCount(this.url,a,b)}async queryVisibleRasters(a,b){if(!a)throw new r("imagery-layer: query-visible-rasters","missing query parameter");await this.load();const {pixelSize:c,returnDomainValues:d,returnTopmostRaster:g,showNoDataRecords:e}=b||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let m=!1;var k=null,p=null;const l=this._rasterFunctionNamesIndex;if(null!=a.outFields&&(m=a.outFields.some(z=>!z.toLowerCase().includes("raster.servicepixelvalue")),
10.4<=this.version)){p=a.outFields.filter(y=>y.toLowerCase().includes("raster.servicepixelvalue")&&24<y.length).map(y=>{y=y.slice(25);return[this._updateRenderingRulesFunctionName(y,l),y]});k=p.map(y=>new E({functionName:y[0]}));p=p.map(y=>y[1]);const {rasterFunction:z}=this;0===k.length?z?.functionName?(k.push(z),p.push(z.functionName)):k=null:z?.functionName&&!k.some(y=>y.functionName===z.functionName)&&(k.push(z),p.push(z.functionName))}const q=null==a.outSpatialReference||a.outSpatialReference.equals(this.spatialReference);
var {multidimensionalSubset:t}=this;let x=a.timeExtent||this.timeExtent;if(t){const {isOutside:z,intersection:y}=I.intersectMultimensionalSubset(t,{geometry:a.geometry,timeExtent:a.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(z)throw new r("imagery-layer:query-visible-rasters","the request cannot be fulfilled when falling outside of the multidimensional subset");null!=y?.timeExtent&&(x=y.timeExtent)}t=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,
x);let D=a.geometry;10.91>this.version&&"extent"===D?.type&&(D=R.fromExtent(D));k=this._getQueryParams({geometry:D,timeExtent:x,mosaicRule:t,rasterFunction:10.4>this.version?this.rasterFunction:null,rasterFunctions:k,pixelSize:c,returnCatalogItems:m,returnGeometry:q,raster:this.raster,maxItemCount:g?1:null});delete k.f;k=new da(k);try{await this._generateRasterInfo(this.rasterFunction);const z=await w.identify(this.url,k,{signal:b?.signal,query:{...this.customParameters}}),y=a.outFields,Sa=null!=
z.value&&z.value.toLowerCase().includes("nodata");if(!m||q||!z?.catalogItems?.features.length||!e&&Sa)return this._processVisibleRastersResponse(z,{returnDomainValues:d,templateRRFunctionNames:p,showNoDataRecords:e,templateFields:y});const L=this.objectIdField||"ObjectId",fa=z.catalogItems?.features??[],Ta=fa.map(M=>M.attributes?.[L]),Ua=new T({objectIds:Ta,returnGeometry:!0,outSpatialReference:a.outSpatialReference,outFields:[L]}),ha=await this.queryRasters(Ua);ha?.features?.length&&ha.features.forEach(M=>
{fa.forEach(W=>{W.attributes[L]===M.attributes[L]&&(W.geometry=new R(M.geometry),null!=a.outSpatialReference&&(W.geometry.spatialReference=a.outSpatialReference))})});return this._processVisibleRastersResponse(z,{returnDomainValues:d,templateRRFunctionNames:p,showNoDataRecords:e,templateFields:y})}catch{throw new r("imagery-layer:query-visible-rasters","encountered error when querying visible rasters");}}async fetchVariableStatisticsHistograms(a,b){var c=B(u(this.parsedUrl)+"/statistics",{query:this._getQueryParams({variable:a}),
signal:b}).then(d=>d.data?.statistics);a=B(u(this.parsedUrl)+"/histograms",{query:this._getQueryParams({variable:a}),signal:b}).then(d=>d.data?.histograms);c=await Promise.all([c,a]);c[0]&&c[0].forEach(d=>{d.avg=d.mean;d.stddev=d.standardDeviation});return{statistics:c[0]||null,histograms:c[1]||null}}async createFlowMesh(a,b){const c=this._rasterJobHandler.instance;return c?c.createFlowMesh(a,b):Oa.createFlowMesh(a.meshType,a.simulationSettings,a.flowData,null!=b.signal?b.signal:(new AbortController).signal)}getMultidimensionalSubsetVariables(a){return I.getSubsetVariablesFromMdInfo(this.multidimensionalSubset,
a??this.serviceRasterInfo.multidimensionalInfo)}async _fetchService(a){await this._fetchServiceInfo(a);this.rasterInfo||(this.rasterInfo=this.serviceRasterInfo);const b=this.sourceJSON,c=null!=this.serviceRasterInfo?Promise.resolve(this.serviceRasterInfo):U.fetchServiceRasterInfo(u(this.parsedUrl),b,{signal:a,query:this._getQueryParams()}).then(g=>{this._set("serviceRasterInfo",g);this._set("multidimensionalInfo",g.multidimensionalInfo);U.patchServiceInfo(g,b);return g});a=this._hasRasterFunction(this.rasterFunction)?
this._generateRasterInfo(this.rasterFunction,{signal:a}):null;const d=this._getRasterFunctionInfos();return Promise.all([c,a,d]).then(g=>{g[1]?this._set("rasterInfo",g[1]):this._set("rasterInfo",g[0]);g[2]&&this._set("rasterFunctionInfos",g[2]);this.renderer&&!this._isSupportedRenderer(this.renderer)&&(this._set("renderer",null),J.getLogger(this).warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer"));this._set("renderer",this._configRenderer(this.renderer));
this.addHandles([ja.watch(()=>this.rasterFunction,e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then(m=>{m&&(this.rasterInfo=m)})})]);({serviceRasterInfo:g}=this);null!=g.multidimensionalInfo&&this._updateMultidimensionalDefinition(g)})}_combineMosaicRuleWithTimeExtent(a,b){var c=this.timeInfo,{multidimensionalInfo:d}=this.serviceRasterInfo;if(null==a||null==d||null==b||null==c?.startField)return a;const {startField:g}=c,e=d.variables.some(l=>
l.dimensions.some(q=>q.name===g))?g:"StdTime";a=a.clone();if("mosaic-dataset"===this.sourceType)return a.multidimensionalDefinition=a.multidimensionalDefinition?.filter(l=>l.dimensionName!==e),this._cleanupMultidimensionalDefinition(a);a.multidimensionalDefinition=a.multidimensionalDefinition||[];c=a.multidimensionalDefinition.filter(l=>l.dimensionName===e);d=null!=b.start?b.start.getTime():null;b=null!=b.end?b.end.getTime():null;const m=null==d||null==b||d===b,k=m?[d||b]:[[d,b]],p=10.8<=this.version;
c.length?c.forEach(l=>{l.dimensionName===e&&(p?(l.dimensionName=null,l.isSlice=!1,l.values=[]):(l.isSlice=m,l.values=k))}):p||(b=a.multidimensionalDefinition.filter(l=>null!=l.variableName&&null==l.dimensionName),b.length?b.forEach(l=>{l.dimensionName=e;l.isSlice=m;l.values=k}):a.multidimensionalDefinition.push(new ma({variableName:"",dimensionName:e,isSlice:m,values:k})));return this._cleanupMultidimensionalDefinition(a)}_cleanupMultidimensionalDefinition(a){if(null==a)return null;a.multidimensionalDefinition&&
(a.multidimensionalDefinition=a.multidimensionalDefinition.filter(b=>!(!b.variableName&&!b.dimensionName)),0===a.multidimensionalDefinition.length&&(a.multidimensionalDefinition=null));return"mosaic-dataset"!==this.sourceType&&null==a.multidimensionalDefinition?null:a}async _prepareForQuery(a,b){if(!(await this._fetchCapabilities(b?.signal)).operations.supportsQuery)throw new r("imagery-layer:query-rasters","query operation is not supported on the input image service");a=null!=a?v.ensureClass(T,a):
this.createQuery();b=this._getRequestOptions(b);this.raster&&(b.query={...b.query,raster:this.raster});return{query:a,requestOptions:b}}async _initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const a=new sa;this._rasterJobHandler.connectionPromise=a.initialize().then(()=>{this._rasterJobHandler.instance=a},()=>{});await this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy();
this._rasterJobHandler.instance=null;this._rasterJobHandler.connectionPromise=null;this._rasterJobHandler.refCount=0;this._cachedRendererJson=null}_isSupportedRenderer(a){const {rasterInfo:b,rasterFunction:c}=this;return"unique-value"===a.type&&this._hasRasterFunction(c)&&1===b?.bandCount&&["u8","s8"].includes(b.pixelType)||null!=b&&null!=a&&K.getSupportedRendererTypes(b).includes(a.type)}async _fetchCapabilities(a){if(this.capabilities)return this.capabilities;await this._fetchServiceInfo(a);return this.capabilities}async _fetchServiceInfo(a){let b=
this.sourceJSON;if(!b){const {data:c,ssl:d}=await B(u(this.parsedUrl),{query:this._getQueryParams(),signal:a});this.sourceJSON=b=c;d&&(this.url=this.url.replace(/^http:/i,"https:"))}if(-1<b.capabilities?.toLowerCase().split(",").map(c=>c.trim()).indexOf("tilesonly"))throw new r("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(b,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(a){return a.serviceSourceType?"esriImageServiceSourceTypeMosaicDataset"===
a.serviceSourceType:0<a.fields?.length}_isMosaicRuleSupported(a){if(!a)return!1;const b=this._isMosaicDataset(a);a=10.71<=a.currentVersion&&a.hasMultidimensions&&!(1<a.fields?.length);return b||a}_isVectorFieldResampleFunction(a){if(null==a)return!1;const {functionName:b,functionArguments:c}=a;a="resample"===b?.toLowerCase();const d=c?.ResampleType||c?.resampleType;return a&&(7===d||10===d)}_isPicture(){return!this.format||this.format.includes("jpg")||this.format.includes("png")}_configRenderer(a){var b=
this._isPicture();const {rasterInfo:c}=this;if(!b&&!this.pixelFilter||this._isVectorDataSet())!this.bandIds&&3<=c.bandCount&&(!(b=K.getDefaultBandCombination(c))||3===c.bandCount&&0===b[0]&&1===b[1]&&2===b[2]||(this.bandIds=b)),a||=K.createDefaultRenderer(c,{bandIds:this.bandIds,variableName:this.rasterFunction?null:this.mosaicRule?.multidimensionalDefinition?.[0].variableName}),b=K.normalizeRendererJSON(a.toJSON()),this.symbolizer?(this.symbolizer.rendererJSON=b,this.symbolizer.rasterInfo=c):this.symbolizer=
new ua({rendererJSON:b,rasterInfo:c}),this.symbolizer.bind().success||(this.symbolizer=null);return a}_clonePixelData(a){return null==a?a:{extent:a.extent&&a.extent.clone(),pixelBlock:null!=a.pixelBlock?a.pixelBlock.clone():null}}_getQueryParams(a){null!=a?.renderingRule&&"string"!==typeof a.renderingRule&&(a.renderingRule=this._getRenderingRuleString(a.renderingRule));const {raster:b,viewId:c}=this;return{raster:b,viewId:c,f:"json",...a,...this.customParameters}}_getRequestOptions(a){return{...a,
query:{...a?.query,...this.customParameters}}}_decodePixelBlock(a,b,c){return this._rasterJobHandler.instance?this._rasterJobHandler.instance.decode({data:a,options:b}):P.decode(a,b,c)}async _getRasterFunctionInfos(a){const b=this.sourceJSON.rasterFunctionInfos;return this.loaded?b:b&&10.3<=this.version?1===b.length&&"none"===b[0].name.toLowerCase()?b:(await B(u(this.parsedUrl)+"/rasterFunctionInfos",{query:this._getQueryParams(),signal:a})).data?.rasterFunctionInfos:null}_canRequestImageElement(a){return!this.pixelFilter&&
(!a||a.includes("png"))}async _requestArrayBuffer(a){const {imageProps:b,requestAsImageElement:c,returnImageBitmap:d,signal:g}=a;if(c&&this._canRequestImageElement(b.format)){var e=`${u(this.parsedUrl)}/exportImage`;({data:a}=await B(e,{responseType:d?"blob":"image",query:this._getQueryParams({f:"image",...this.refreshParameters,...a.imageServiceParameters}),signal:g}));return a instanceof Blob?{imageBitmap:await ca.createBitmap(a,e,g),params:b}:{imageOrCanvasElement:a,params:b}}e=this._initJobHandler();
a=B(u(this.parsedUrl)+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams({f:"image",...a.imageServiceParameters}),signal:g});a=(await Promise.all([a,e]))[0].data;var m=e=b.format||"jpgpng";"bsq"!==m&&"bip"!==m&&(m=P.getFormat(a));if(!m)throw new r("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,new Uint8Array(a)));m="gif"===e||"bmp"===e||e.includes("png")&&("png"===m||"jpg"===m);const k={signal:g};return{pixelData:{pixelBlock:await (m?
P.decode(a,{useCanvas:!0,...b},k):this._decodePixelBlock(a,{width:b.width,height:b.height,planes:null,pixelType:null,noDataValue:null,format:e},k)),extent:b.extent},params:b}}_generateRasterInfo(a,b){return this.generateRasterInfo(a,b).catch(()=>null)}_isValidCustomizedMosaicRule(a){return a&&JSON.stringify(a.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(a){if(!this._isValidCustomizedMosaicRule(this.mosaicRule)&&(a=I.getDefaultMultidimensionalDefinition(a,
{multidimensionalSubset:this.multidimensionalSubset}),null!=a&&0<a.length)){this.mosaicRule=this.mosaicRule||new G;const b=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&"none"!==this.rasterFunction.functionName?.toLowerCase()&&a.forEach(c=>c.variableName="");a=a.filter(({variableName:c,dimensionName:d})=>c&&"*"!==c||d);!b?.length&&a.length&&(this.mosaicRule.multidimensionalDefinition=a)}}_processVisibleRastersResponse(a,b){b=b||{};const c=a.value,
{templateRRFunctionNames:d,showNoDataRecords:g,returnDomainValues:e,templateFields:m}=b;b=a.processedValues;var k=a.catalogItems?.features;let p=a.properties?.Values?.map(D=>D.replaceAll(/ /gi,", "))||[];var l=this.objectIdField||"ObjectId",q="string"===typeof c&&c.toLowerCase().includes("nodata");a=[];!c||k||q||(k={},k[l]=0,k=new ia(this.fullExtent,null,k),p=[c],k=[k]);if(!k)return[];this._updateResponseFieldNames(k,m);q&&!g&&(k=[]);for(l=0;l<k.length;l++){q=k[l];if(null!=c){var t=p[l];var x=this.rasterFunction&&
b&&0<b.length&&d&&0<d.length&&d.includes(this.rasterFunction.functionName)?b[d.indexOf(this.rasterFunction.functionName)]:c;if("nodata"===t.toLowerCase()&&!g)continue;q.attributes["Raster.ItemPixelValue"]=t;q.attributes["Raster.ServicePixelValue"]=x;this._updateFeatureWithMagDirValues(q,t);const D=this.fields&&0<this.fields.length;x=this.rasterFunction&&null!=this.serviceRasterInfo.attributeTable?D?t:c:x;this.rasterFunction||(x=D?t:c);this._updateFeatureWithRasterAttributeTableValues(q,x)}q.sourceLayer=
q.layer=this;e&&this._updateFeatureWithDomainValues(q);if(d&&b&&d.length===b.length)for(t=0;t<d.length;t++)q.attributes["Raster.ServicePixelValue."+d[t]]=b[t];a.push(k[l])}return a}_processMultidimensionalIntersection(a,b,c){const {multidimensionalSubset:d}=this;if(!d)return c=this._combineMosaicRuleWithTimeExtent(c,b),{isOutSide:!1,timeExtent:b,mosaicRule:c};if(d){const {isOutside:g,intersection:e}=I.intersectMultimensionalSubset(d,{geometry:a,timeExtent:b});if(g)return{isOutSide:!0,timeExtent:null,
mosaicRule:null};null!=e?.timeExtent&&(b=e.timeExtent)}c=this._combineMosaicRuleWithTimeExtent(c,b);return c?.multidimensionalDefinition&&({isOutside:a}=I.intersectMultimensionalSubset(d,{multidimensionalDefinition:c.multidimensionalDefinition}),a)?{isOutSide:!0,timeExtent:null,mosaicRule:null}:{isOutSide:!1,timeExtent:b,mosaicRule:c}}_updateFeatureWithRasterAttributeTableValues(a,b){const c=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(null!=c){var {features:d,fields:g}=
c,e=g.map(k=>k.name).find(k=>"value"===k.toLowerCase());if(e){var m=d.filter(k=>k.attributes[e]===(null!=b?parseInt(b,10):null));m&&m[0]&&g.forEach(k=>{a.attributes[this._rasterAttributeTableFieldPrefix+k.name]=m[0].attributes[k.name]})}}}_updateFeatureWithMagDirValues(a,b){if(this._isVectorDataSet()){var c=b.split(/,\s*/).map(d=>parseFloat(d));b=c.map(d=>[d]);c=c.map(d=>({minValue:d,maxValue:d,noDataValue:null}));b=new O({height:1,width:1,pixelType:"f32",pixels:b,statistics:c});null!=this.pixelFilter&&
this.pixelFilter({pixelBlock:b,extent:new Q(0,0,0,0,this.spatialReference)});b="esriImageServiceDataTypeVector-MagDir"===this.serviceDataType?[b.pixels[0][0],b.pixels[1][0]]:ta.uvComponentToVector([b.pixels[0][0],b.pixels[1][0]]);a.attributes["Raster.Magnitude"]=b[0];a.attributes["Raster.Direction"]=b[1]}}_updateFeatureWithDomainValues(a){const b=this.fields&&this.fields.filter(c=>c.domain&&"coded-value"===c.domain.type);null!=b&&b.forEach(c=>{const d=a.attributes[c.name];if(null!=d){const g=c.domain.codedValues.find(e=>
e.code===d);g&&(a.attributes[c.name]=g.name)}})}_updateResponseFieldNames(a,b){if(b&&!(1>b.length)){var c=this.fieldsIndex;null!=c&&a.forEach(d=>{if(d?.attributes)for(const g of b){const e=c.get(g)?.name;e&&e!==g&&(d.attributes[g]=d.attributes[e],delete d.attributes[e])}})}}_getRenderingRuleString(a){if(a){a=a.toJSON();a=a.rasterFunctionDefinition??a;if(a.thumbnail||a.thumbnailEx)a.thumbnail=a.thumbnailEx=null;return JSON.stringify(a)}return null}_hasRasterFunction(a){return null!=a?.functionName&&
"none"!==a.functionName.toLowerCase()}_updateRenderingRulesFunctionName(a,b){if(a&&!(1>a.length)){if("Raw"===a)return a.replace("Raw","None");var c=a.toLowerCase().replaceAll(/ /gi,"_");return b.has(c)?b.get(c):a}}_isRFTJson(a){return a?.name&&a.arguments&&a.function&&a.hasOwnProperty("functionType")}_isVectorDataSet(){return"esriImageServiceDataTypeVector-UV"===this.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===this.serviceDataType}_applyMosaicAndRenderingRules(a){const {raster:b,mosaicRule:c,
rasterFunction:d}=this;d&&a instanceof V&&null==a.rasterFunction&&(a.rasterFunction=d);c&&null==a.mosaicRule&&(a.mosaicRule=c);b&&null==a.raster&&(a.raster=b)}_readCapabilities(a){var b=a.capabilities?a.capabilities.toLowerCase().split(",").map(x=>x.trim()):["image","catalog"];const {currentVersion:c,advancedQueryCapabilities:d,maxRecordCount:g}=a,e=b.includes("image"),m="esriImageServiceDataTypeElevation"===a.serviceDataType;var k=!(!a.spatialReference&&!a.extent?.spatialReference);const p=b.includes("edit");
k=b.includes("mensuration")&&k;const l=null==a.mensurationCapabilities?[]:a.mensurationCapabilities.toLowerCase().split(",").map(x=>x.trim()),q=k&&l.includes("basic"),t=this._isMosaicDataset(a)&&b.includes("catalog");b=b.includes("download");return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:e,supportsExportImage:e,supportsIdentify:e,supportsImageToMap:11.2<=c&&t,supportsImageToMapMultiray:11.2<=c&&t,supportsMapToImage:11.2<=c&&t,supportsFindImages:11.2<=c&&t,supportsGetImageUrl:11.2<=
c&&b,supportsMeasure:k,supportsMeasureFromImage:11.2<=c,supportsDownload:b,supportsQuery:t&&a.fields&&0<a.fields.length,supportsGetSamples:10.2<=c&&e,supportsProject:10.3<=c&&e,supportsComputeStatisticsHistograms:10.4<=c&&e,supportsQueryBoundary:10.6<=c&&e,supportsCalculateVolume:10.7<=c&&m,supportsComputePixelLocation:10.7<=c&&t,supportsComputeAngles:10.91<=c,supportsQueryGPSInfo:11.2<=c&&t,supportsAdd:p,supportsDelete:p,supportsEditing:p,supportsUpdate:p,supportsCalculate:!1,supportsTruncate:!1,
supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:g,maxRecordCountFactor:void 0,supportsStatistics:!!d?.supportsStatistics,supportsOrderBy:!!d?.supportsOrderBy,supportsDistinct:!!d?.supportsDistinct,supportsPagination:!!d?.supportsPagination,supportsStandardizedQueriesOnly:!!d?.useStandardizedQueries,
supportsPercentileStatistics:!!d?.supportsPercentileStatistics,supportsCentroid:!!d?.supportsReturningGeometryCentroid,supportsDistance:!!d?.supportsQueryWithDistance,supportsExtent:!!d?.supportsReturningQueryExtent,supportsGeometryProperties:!!d?.supportsReturningGeometryProperties,supportsHavingClause:!!d?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:!1,supportsTopFeaturesQuery:!1,
supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!d?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0},mensuration:{supportsDistanceAndAngle:q,supportsAreaAndPerimeter:q,
supportsPointOrCentroid:q,supportsHeightFromBaseAndTop:k&&l.includes("base-top height"),supportsHeightFromBaseAndTopShadow:k&&l.includes("base-top shadow height"),supportsHeightFromTopAndTopShadow:k&&l.includes("top-top shadow height"),supports3D:k&&l.includes("3d")}}}};h.__decorate([n.property({clonable:!1})],f.prototype,"_functionRasterInfos",void 0);h.__decorate([n.property({clonable:!1})],f.prototype,"_rasterJobHandler",void 0);h.__decorate([n.property({clonable:!1})],f.prototype,"_cachedRendererJson",
void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"_serviceSupportsMosaicRule",void 0);h.__decorate([A.reader("_serviceSupportsMosaicRule",["currentVersion","fields"])],f.prototype,"readServiceSupportsMosaicRule",null);h.__decorate([n.property({readOnly:!0})],f.prototype,"_rasterAttributeTableFieldPrefix",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"_rasterFunctionNamesIndex",null);h.__decorate([n.property()],f.prototype,"adjustAspectRatio",void 0);h.__decorate([n.property({type:[v.Integer],
json:{write:!0}})],f.prototype,"bandIds",void 0);h.__decorate([A.reader("bandIds")],f.prototype,"readBandIds",null);h.__decorate([n.property({readOnly:!0,json:{read:!1}})],f.prototype,"capabilities",void 0);h.__decorate([A.reader("service","capabilities",["capabilities","currentVersion","serviceDataType"])],f.prototype,"readCapabilities",null);h.__decorate([n.property({type:Number})],f.prototype,"compressionQuality",void 0);h.__decorate([H.writer("compressionQuality")],f.prototype,"writeCompressionQuality",
null);h.__decorate([n.property({type:Number})],f.prototype,"compressionTolerance",void 0);h.__decorate([H.writer("compressionTolerance")],f.prototype,"writeCompressionTolerance",null);h.__decorate([n.property({json:{read:{source:"copyrightText"}}})],f.prototype,"copyright",void 0);h.__decorate([n.property({readOnly:!0,dependsOn:["_serviceSupportsMosaicRule"]})],f.prototype,"defaultMosaicRule",void 0);h.__decorate([A.reader("defaultMosaicRule",["defaultMosaicMethod"])],f.prototype,"readDefaultMosaicRule",
null);h.__decorate([n.property({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],f.prototype,"definitionExpression",void 0);h.__decorate([n.property({readOnly:!0,constructOnly:!0})],f.prototype,"exportImageServiceParameters",void 0);h.__decorate([n.property()],f.prototype,"rasterInfo",void 0);h.__decorate([n.property({readOnly:!0,type:[F]})],f.prototype,"fields",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"fieldsIndex",null);h.__decorate([n.property({type:"png png8 png24 png32 jpg bmp gif jpgpng lerc tiff".split(" "),
json:{write:!0}})],f.prototype,"format",null);h.__decorate([A.reader("service","format",["serviceDataType"])],f.prototype,"readFormat",null);h.__decorate([n.property({type:Q})],f.prototype,"fullExtent",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"hasMultidimensions",void 0);h.__decorate([n.property({json:{read:{source:"maxImageHeight"}}})],f.prototype,"imageMaxHeight",void 0);h.__decorate([n.property({json:{read:{source:"maxImageWidth"}}})],f.prototype,"imageMaxWidth",void 0);h.__decorate([n.property({type:String,
json:{type:C.interpolationKebab.jsonValues,read:C.interpolationKebab.read,write:C.interpolationKebab.write}})],f.prototype,"interpolation",void 0);h.__decorate([n.property()],f.prototype,"minScale",void 0);h.__decorate([A.reader("service","minScale")],f.prototype,"readMinScale",null);h.__decorate([n.property()],f.prototype,"maxScale",void 0);h.__decorate([A.reader("service","maxScale")],f.prototype,"readMaxScale",null);h.__decorate([n.property({type:G})],f.prototype,"mosaicRule",null);h.__decorate([A.reader("mosaicRule",
["mosaicRule","defaultMosaicMethod"])],f.prototype,"readMosaicRule",null);h.__decorate([H.writer("mosaicRule")],f.prototype,"writeMosaicRule",null);h.__decorate([n.property()],f.prototype,"multidimensionalInfo",void 0);h.__decorate([n.property({type:qa,json:{write:!0}})],f.prototype,"multidimensionalSubset",void 0);h.__decorate([n.property({json:{type:v.Integer}})],f.prototype,"noData",void 0);h.__decorate([H.writer("noData")],f.prototype,"writeNoData",null);h.__decorate([n.property({type:String,
json:{type:C.noDataInterpretationKebab.jsonValues,read:C.noDataInterpretationKebab.read,write:C.noDataInterpretationKebab.write}})],f.prototype,"noDataInterpretation",void 0);h.__decorate([n.property({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],f.prototype,"objectIdField",void 0);h.__decorate([A.reader("objectIdField")],f.prototype,"readObjectIdField",null);h.__decorate([n.property({readOnly:!0})],f.prototype,"geometryType",void 0);h.__decorate([n.property({})],f.prototype,"typeIdField",
void 0);h.__decorate([n.property({})],f.prototype,"types",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"parsedUrl",null);h.__decorate([n.property({type:Function})],f.prototype,"pixelFilter",void 0);h.__decorate([n.property()],f.prototype,"raster",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"sourceType",void 0);h.__decorate([A.reader("sourceType",["serviceSourceType","fields"])],f.prototype,"readSourceType",null);h.__decorate([n.property()],f.prototype,"viewId",void 0);
h.__decorate([n.property({types:N.rasterRendererTypes,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:N.websceneRasterRendererTypes,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(a){return{enabled:a&&"vector-field"!==a.type&&"flow"!==a.type}}}}}}})],f.prototype,"renderer",null);h.__decorate([A.reader("renderer")],f.prototype,"readRenderer",null);h.__decorate([H.writer("renderer")],f.prototype,"writeRenderer",null);h.__decorate([n.property({clonable:!1})],
f.prototype,"symbolizer",void 0);h.__decorate([n.property(ba.opacity)],f.prototype,"opacity",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"rasterFields",null);h.__decorate([n.property({constructOnly:!0})],f.prototype,"rasterFunctionInfos",void 0);h.__decorate([n.property({type:E})],f.prototype,"renderingRule",null);h.__decorate([n.property({type:E,json:{name:"renderingRule"}})],f.prototype,"rasterFunction",null);h.__decorate([A.reader("rasterFunction",["renderingRule","rasterFunctionInfos"])],
f.prototype,"readRasterFunction",null);h.__decorate([n.property({readOnly:!0})],f.prototype,"serviceDataType",void 0);h.__decorate([n.property({readOnly:!0,type:S})],f.prototype,"spatialReference",void 0);h.__decorate([A.reader("spatialReference",["spatialReference","extent"])],f.prototype,"readSpatialReference",null);h.__decorate([n.property({json:{type:C.pixelTypeKebabDict.jsonValues}})],f.prototype,"pixelType",void 0);h.__decorate([A.reader("pixelType")],f.prototype,"readPixelType",null);h.__decorate([H.writer("pixelType")],
f.prototype,"writePixelType",null);h.__decorate([n.property({constructOnly:!0,type:ra})],f.prototype,"serviceRasterInfo",void 0);h.__decorate([n.property()],f.prototype,"sourceJSON",void 0);h.__decorate([n.property(ba.url)],f.prototype,"url",void 0);h.__decorate([n.property({readOnly:!0})],f.prototype,"version",void 0);h.__decorate([A.reader("version",["currentVersion","fields","timeInfo"])],f.prototype,"readVersion",null);return f=h.__decorate([la.subclass("esri.layers.mixins.ArcGISImageService")],
f)};Object.defineProperty(X,Symbol.toStringTag,{value:"Module"})});