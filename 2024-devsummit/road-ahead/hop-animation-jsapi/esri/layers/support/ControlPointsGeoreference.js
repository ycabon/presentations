// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../core/Accessor ../../core/Error ../../core/JSONSupport ../../core/Logger ../../core/perspectiveUtils ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/has ../../core/RandomLCG ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/libs/gl-matrix-2/math/mat3 ../../core/libs/gl-matrix-2/factories/mat3f64 ../../core/libs/gl-matrix-2/math/vec2 ../../core/libs/gl-matrix-2/factories/vec2f64 ../../geometry/Point ../../geometry/Polygon ../../geometry/projection ../../geometry/SpatialReference ./GeoreferenceBase".split(" "),
function(m,E,U,k,Q,n,J,x,ea,fa,V,R,W,X,K,h,l,y,Y,S,Z,aa){function g(a){return null!=a?.sourcePoint&&null!=a.mapPoint}function r(a,b,d){h.set(a,d.sourcePoint.x,d.sourcePoint.y);h.set(b,d.mapPoint.x,d.mapPoint.y)}function ba(a,b,d){r(t,u,b);r(v,w,d);h.rotate(F,v,t,L);h.rotate(z,t,v,L);h.rotate(G,w,u,-L);h.rotate(A,u,w,-L);b=u;d=w;var e=G,c=A;return n.getProjectiveTransform(a,I(N,t,v,F,z),I(O,b,d,e,c))}function ca(a,b,d,e){r(t,u,b);r(v,w,d);r(F,G,e);h.lerp(z,t,v,.5);h.rotate(z,F,z,Math.PI);h.lerp(A,
u,w,.5);h.rotate(A,G,A,Math.PI);b=u;d=w;e=G;var c=A;return n.getProjectiveTransform(a,I(N,t,v,F,z),I(O,b,d,e,c))}function T(a,b,d,e,c){r(t,u,b);r(v,w,d);r(F,G,e);r(z,A,c);b=u;d=w;e=G;c=A;return n.getProjectiveTransform(a,I(N,t,v,F,z),I(O,b,d,e,c))}function I(a,b,d,e,c){a[0]=b[0];a[1]=b[1];a[2]=d[0];a[3]=d[1];a[4]=e[0];a[5]=e[1];a[6]=c[0];a[7]=c[1];return a}const P=K.create(),f=l.create();E=class extends E{constructor(){super(...arguments);this.mapPoint=this.sourcePoint=null}};m.__decorate([x.property()],
E.prototype,"sourcePoint",void 0);m.__decorate([x.property({type:y})],E.prototype,"mapPoint",void 0);E=m.__decorate([R.subclass("esri.layers.support.ControlPoint")],E);k=class extends k.JSONSupportMixin(aa){constructor(a){super(a);this.controlPoints=null;this.height=0;this.type="control-points";this.width=0}readControlPoints(a,b){const d=Z.fromJSON(b.spatialReference),e=K.fromValues(...b.coefficients,1);return a.map(c=>{h.set(f,c.x,c.y);n.transformProjective(f,f,e);return{sourcePoint:c,mapPoint:new y({x:f[0],
y:f[1],spatialReference:d})}})}writeControlPoints(a,b,d,e){null==this.transform?(a=new U("web-document-write:invalid-georeference","Invalid 'controlPoints', 'width', 'height' configuration.",{layer:e?.layer,georeference:this}),e?.messages?e.messages.push(a):Q.getLogger(this).error(a.name,a.message)):null!=a&&g(a[0])&&(b.controlPoints=a.map(c=>{c=c.sourcePoint;return{x:c.x,y:c.y}}),b.spatialReference=a[0].mapPoint.spatialReference.toJSON(),b.coefficients=this.transform.slice(0,8))}get coords(){if(null==
this.controlPoints)return null;const a=this._updateTransform(P);if(null==a||!g(this.controlPoints[0]))return null;var b=this.width,d=this.height,e=this.controlPoints[0].mapPoint.spatialReference;const c=l.fromValues(0,d),p=l.fromValues(0,0),B=l.fromValues(b,0);b=l.fromValues(b,d);n.transformProjective(c,c,a);n.transformProjective(p,p,a);n.transformProjective(B,B,a);n.transformProjective(b,b,a);return new Y({rings:[[c,p,B,b,c]],spatialReference:e})}set coords(a){if(null!=this.controlPoints&&g(this.controlPoints[0])){var b=
this.controlPoints[0].mapPoint.spatialReference;a=this.projectOrWarn(a,b);if(null!=a){var {width:d,height:e}=this,{rings:[[c,p,B,M]]}=a;a={sourcePoint:J.createScreenPoint(0,e),mapPoint:new y({x:c[0],y:c[1],spatialReference:b})};var q={sourcePoint:J.createScreenPoint(0,0),mapPoint:new y({x:p[0],y:p[1],spatialReference:b})},C={sourcePoint:J.createScreenPoint(d,0),mapPoint:new y({x:B[0],y:B[1],spatialReference:b})},D={sourcePoint:J.createScreenPoint(d,e),mapPoint:new y({x:M[0],y:M[1],spatialReference:b})};
g(a)&&g(q)&&g(C)&&g(D)&&(T(P,a,q,C,D),this.controlPoints=this.controlPoints.map(({sourcePoint:H})=>{h.set(f,H.x,H.y);n.transformProjective(f,f,P);return{sourcePoint:H,mapPoint:new y({x:f[0],y:f[1],spatialReference:b})}}))}}}get inverseTransform(){return null==this.transform?null:X.invert(K.create(),this.transform)}get transform(){return this._updateTransform()}toMap(a){if(null==a||null==this.transform||null==this.controlPoints||!g(this.controlPoints[0]))return null;h.set(f,a.x,a.y);a=this.controlPoints[0].mapPoint.spatialReference;
n.transformProjective(f,f,this.transform);return new y({x:f[0],y:f[1],spatialReference:a})}toSource(a){if(null==a||null==this.inverseTransform||null==this.controlPoints||!g(this.controlPoints[0]))return null;const b=this.controlPoints[0].mapPoint.spatialReference;a=a.normalize();a=S.projectOrLoad(a,b).geometry;if(null==a)return null;h.set(f,a.x,a.y);n.transformProjective(f,f,this.inverseTransform);return J.createScreenPoint(f[0],f[1])}toSourceNormalized(a){a=this.toSource(a);null!=a&&(a.x/=this.width,
a.y/=this.height);return a}_updateTransform(a){const {controlPoints:b,width:d,height:e}=this;if(!(null!=b&&0<d&&0<e))return null;const [c,p,B,M]=b;if(!g(c))return null;var q=c.mapPoint.spatialReference;const C=this._projectControlPoint(p,q),D=this._projectControlPoint(B,q);q=this._projectControlPoint(M,q);if(!(C.valid&&D.valid&&q.valid&&g(C.controlPoint)))return null;null==a&&(a=K.create());let H=null;H=g(D.controlPoint)&&g(q.controlPoint)?T(a,c,C.controlPoint,D.controlPoint,q.controlPoint):g(D.controlPoint)?
ca(a,c,C.controlPoint,D.controlPoint):ba(a,c,C.controlPoint);return H.every(da=>0===da)?null:H}_projectControlPoint(a,b){if(!g(a))return{valid:!0,controlPoint:a};const {sourcePoint:d,mapPoint:e}=a,{geometry:c,pending:p}=S.projectOrLoad(e,b);return p?{valid:!1,controlPoint:null}:p||c?{valid:!0,controlPoint:{sourcePoint:d,mapPoint:c}}:(Q.getLogger(this).warn("map point could not be projected to the spatial reference",{georeference:this,controlPoint:a,sourceSpatialReference:e.spatialReference,targetSpatialReference:b}),
{valid:!1,controlPoint:null})}};m.__decorate([x.property({type:[E],json:{write:{allowNull:!1,isRequired:!0}}})],k.prototype,"controlPoints",void 0);m.__decorate([V.reader("controlPoints")],k.prototype,"readControlPoints",null);m.__decorate([W.writer("controlPoints")],k.prototype,"writeControlPoints",null);m.__decorate([x.property()],k.prototype,"coords",null);m.__decorate([x.property({json:{write:!0}})],k.prototype,"height",void 0);m.__decorate([x.property({readOnly:!0})],k.prototype,"inverseTransform",
null);m.__decorate([x.property({readOnly:!0})],k.prototype,"transform",null);m.__decorate([x.property({json:{write:!0}})],k.prototype,"width",void 0);k=m.__decorate([R.subclass("esri.layers.support.ControlPointsGeoreference")],k);const t=l.create(),v=l.create(),F=l.create(),z=l.create(),u=l.create(),w=l.create(),G=l.create(),A=l.create(),L=Math.PI/2,N=Array(8).fill(0),O=Array(8).fill(0);return k});