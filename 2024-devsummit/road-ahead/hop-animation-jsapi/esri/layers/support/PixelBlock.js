// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../core/Error ../../core/JSONSupport ../../core/lang ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ./SimpleBandStatistics ./rasterFormats/pixelRangeUtils".split(" "),function(p,w,m,x,u,q,y,z,v,A){var t;m=t=class extends m.JSONSupport{static createEmptyBand(a,b){return new (t.getPixelArrayConstructor(a))(b)}static combineBandMasks(a){if(2>a.length)return a[0];
const b=a[0].length,g=(new Uint8Array(b)).fill(255);for(let h=0;h<a.length;h++){const f=a[h];for(let c=0;c<b;c++)f[c]||(g[c]=0)}return g}static getPixelArrayConstructor(a){let b;switch(a){case "u1":case "u2":case "u4":case "u8":b=Uint8Array;break;case "u16":b=Uint16Array;break;case "u32":b=Uint32Array;break;case "s8":b=Int8Array;break;case "s16":b=Int16Array;break;case "s32":b=Int32Array;break;case "f32":b=Float32Array;break;case "f64":b=Float64Array;break;case "c64":case "c128":case "unknown":b=
Float32Array}return b}constructor(a){super(a);this.height=this.width=null;this.pixelType="f32";this.mask=this.validPixelCount=null;this.premultiplyAlpha=this.maskIsAlpha=!1;this.statistics=null;this.depthCount=1}castPixelType(a){if(!a)return"f32";a=a.toLowerCase();["u1","u2","u4"].includes(a)?a="u8":"unknown u8 s8 u16 s16 u32 s32 f32 f64".split(" ").includes(a)||(a="f32");return a}getPlaneCount(){return this.pixels?.length}addData(a){if(!a.pixels||a.pixels.length!==this.width*this.height)throw new w("pixelblock:invalid-or-missing-pixels",
"add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]);this.statistics||(this.statistics=[]);this.pixels.push(a.pixels);this.statistics.push(a.statistics??new v.SimpleBandStatistics)}getAsRGBA(){const a=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case "s8":case "s16":case "u16":case "s32":case "u32":case "f32":case "f64":this._fillFromNon8Bit(a);break;default:this._fillFrom8Bit(a)}return new Uint8ClampedArray(a)}getAsRGBAFloat(){const a=
new Float32Array(this.width*this.height*4);this._fillFrom32Bit(a);return a}updateStatistics(){if(this.pixels){this.statistics=this.pixels.map(g=>this._calculateBandStatistics(g,this.mask));var a=this.mask,b=0;if(null!=a)for(let g=0;g<a.length;g++)a[g]&&b++;else b=this.width*this.height;this.validPixelCount=b}}clamp(a){if(a&&"f64"!==a&&"f32"!==a&&this.pixels){var [b,g]=A.getPixelValueRange(a),h=this.pixels,f=this.width*this.height,c=h.length,d=[];for(let e=0;e<c;e++){var k=t.createEmptyBand(a,f);var l=
h[e];for(let r=0;r<f;r++){var n=l[r];k[r]=n>g?g:n<b?b:n}d.push(k)}this.pixels=d;this.pixelType=a}}extractBands(a){const {pixels:b,statistics:g}=this;if(null==a||0===a.length||!b||0===b.length)return this;var h=b.length;const f=a.some(e=>e>=b.length),c=h===a.length&&!a.some((e,r)=>e!==r);if(f||c)return this;h=this.bandMasks?.length===h?a.map(e=>this.bandMasks[e]):void 0;let {mask:d,validPixelCount:k}=this;const {width:l,height:n}=this;h?.length&&(d=t.combineBandMasks(h),k=d.filter(e=>!!e).length);
return new t({pixelType:this.pixelType,width:l,height:n,mask:d,bandMasks:h,validPixelCount:k,maskIsAlpha:this.maskIsAlpha,pixels:a.map(e=>b[e]),statistics:g&&a.map(e=>g[e])})}clone(){const a=new t({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});null!=this.mask&&(a.mask=this.mask instanceof Uint8Array?new Uint8Array(this.mask):this.mask.slice(0));this.bandMasks&&(a.bandMasks=this.bandMasks.map(h=>new Uint8Array(h)));
let b;const g=t.getPixelArrayConstructor(this.pixelType);if(this.pixels&&0<this.pixels.length){a.pixels=[];const h=!!this.pixels[0].slice;for(b=0;b<this.pixels.length;b++)a.pixels[b]=h?this.pixels[b].slice(0,this.pixels[b].length):new g(this.pixels[b])}if(this.statistics)for(a.statistics=[],b=0;b<this.statistics.length;b++)a.statistics[b]=x.clone(this.statistics[b]);a.premultiplyAlpha=this.premultiplyAlpha;return a}_fillFrom8Bit(a){const {mask:b,maskIsAlpha:g,premultiplyAlpha:h,pixels:f}=this;if(a&&
f?.length){var c,d;var k=c=d=f[0];3<=f.length?(c=f[1],d=f[2]):2===f.length&&(c=f[1]);var l=new Uint32Array(a),n=this.width*this.height;if(k.length!==n)u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");else if(null!=b&&b.length===n)if(g)for(a=0;a<n;a++){const e=b[a];if(e){const r=e/255;l[a]=h?e<<24|d[a]*r<<16|c[a]*r<<8|k[a]*r:e<<24|d[a]<<16|c[a]<<8|k[a]}}else for(a=0;a<n;a++)b[a]&&(l[a]=-16777216|d[a]<<16|c[a]<<8|k[a]);else for(a=0;a<n;a++)l[a]=-16777216|
d[a]<<16|c[a]<<8|k[a]}else u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.")}_fillFromNon8Bit(a){const {pixels:b,mask:g,statistics:h}=this;if(a&&b?.length){var f=this.pixelType,c=1,d=0;c=1;if(h&&0<h.length){for(var k of h)null!=k.minValue&&(d=Math.min(d,k.minValue)),null!=k.maxValue&&null!=k.minValue&&(c=Math.max(c,k.maxValue-k.minValue));c=255/c}else c=255,"s8"===f?(d=-128,c=127):"u16"===f?c=65535:"s16"===f?(d=-32768,c=32767):"u32"===f?c=4294967295:
"s32"===f?(d=-2147483648,c=2147483647):"f32"===f?(d=-3.4*1E39,c=3.4*1E39):"f64"===f&&(d=-Number.MAX_VALUE,c=Number.MAX_VALUE),c=255/(c-d);a=new Uint32Array(a);f=this.width*this.height;var l,n,e;k=l=n=b[0];if(k.length!==f)return u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(2<=b.length)if(l=b[1],3<=b.length&&(n=b[2]),null!=g&&g.length===f)for(e=0;e<f;e++)g[e]&&(a[e]=-16777216|(n[e]-d)*c<<16|(l[e]-d)*c<<8|(k[e]-d)*c);else for(e=0;e<f;e++)a[e]=-16777216|
(n[e]-d)*c<<16|(l[e]-d)*c<<8|(k[e]-d)*c;else if(null!=g&&g.length===f)for(e=0;e<f;e++)l=(k[e]-d)*c,g[e]&&(a[e]=-16777216|l<<16|l<<8|l);else for(e=0;e<f;e++)l=(k[e]-d)*c,a[e]=-16777216|l<<16|l<<8|l}else u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.")}_fillFrom32Bit(a){const {pixels:b,mask:g}=this;if(!a||!b?.length)return u.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let h,f,c,d;h=f=c=b[0];
3<=b.length?(f=b[1],c=b[2]):2===b.length&&(f=b[1]);const k=this.width*this.height;if(h.length!==k)return u.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let l=0;if(null!=g&&g.length===k)for(d=0;d<k;d++)a[l++]=h[d],a[l++]=f[d],a[l++]=c[d],a[l++]=g[d]&1;else for(d=0;d<k;d++)a[l++]=h[d],a[l++]=f[d],a[l++]=c[d],a[l++]=1}_calculateBandStatistics(a,b){let g=Infinity,h=-Infinity;const f=a.length;let c,d=0;if(null!=b)for(c=0;c<f;c++)b[c]&&(d=a[c],g=d<g?
d:g,h=d>h?d:h);else for(c=0;c<f;c++)d=a[c],g=d<g?d:g,h=d>h?d:h;return new v.SimpleBandStatistics(g,h)}};p.__decorate([q.property({json:{write:!0}})],m.prototype,"width",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"height",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"pixelType",void 0);p.__decorate([y.cast("pixelType")],m.prototype,"castPixelType",null);p.__decorate([q.property({json:{write:!0}})],m.prototype,"validPixelCount",void 0);p.__decorate([q.property({json:{write:!0}})],
m.prototype,"mask",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"maskIsAlpha",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"pixels",void 0);p.__decorate([q.property()],m.prototype,"premultiplyAlpha",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"statistics",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"depthCount",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"noDataValues",void 0);p.__decorate([q.property({json:{write:!0}})],
m.prototype,"bandMasks",void 0);return m=t=p.__decorate([z.subclass("esri.layers.support.PixelBlock")],m)});