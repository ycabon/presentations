// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require exports ../../core/Error ../../core/urlUtils ./arcgisLayerUrl ./associatedFeatureServiceUtils ./fetchService ./layerUtils ./lazyLayerLoader ../../support/requestPresets".split(" "),function(y,p,z,q,r,A,B,t,C,l){function u(a,b){return a?a.find(c=>c.id===b):null}async function D(a,b,c){function f(k,g,h,m){g={...c,layerId:g,sublayerTitleMode:"service-name"};null!=k&&(g.url=k);null!=h&&(g.sourceJSON=h);return m(g)}const e=b.sublayerConstructorProvider;for(const {id:k,serverUrl:g}of b.layers){var d=
u(b.sublayerInfos,k);const h=(d&&e?.(d))??b.Constructor;d=f(g,k,d,m=>new h(m));a.add(d)}if(b.tables.length){const k=await n("FeatureLayer");b.tables.forEach(({id:g,serverUrl:h})=>{g=f(h,g,u(b.tableInfos,g),m=>new k(m));a.tables.add(g)})}}async function E(a,b){var c=r.parse(a);null==c&&(c=await F(a,b));if(null==c)throw new z("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:a});const {serverType:f,sublayer:e}=c;var d={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",
VectorTileServer:"VectorTileLayer"};const k="FeatureServer"===f;var g="SceneServer"===f;const h={parsedUrl:c,Constructor:null,layerId:k||g?e??void 0:void 0,layers:[],tables:[]};switch(f){case "MapServer":c=null!=e?"FeatureLayer":await G(a,b)?"TileLayer":"MapImageLayer";break;case "ImageServer":c=await l.fetchArcGISServiceJSON(a,{customParameters:b});const {tileInfo:m,cacheType:v}=c;c=m?"LERC"!==m?.format?.toUpperCase()||v&&"elevation"!==v.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";
break;case "SceneServer":d=await l.fetchArcGISServiceJSON(c.url.path,{customParameters:b});c="SceneLayer";if(d){const w=d?.layers;"Voxel"===d?.layerType?c="VoxelLayer":w?.length&&(d=w[0]?.layerType,null!=d&&null!=t.sceneServiceLayerTypeToClassName[d]&&(c=t.sceneServiceLayerTypeToClassName[d]))}break;case "3DTilesServer":c="IntegratedMesh3DTilesLayer";break;case "FeatureServer":c="FeatureLayer";null!=e&&(d=await l.fetchArcGISServiceJSON(a,{customParameters:b}),h.sourceJSON=d,"Oriented Imagery Layer"===
d.type&&(c="OrientedImageryLayer"));break;default:c=d[f]}if(H[c]&&null==e)if(a=await I(a,f,b),k&&(h.sublayerInfos=a.layerInfos,h.tableInfos=a.tableInfos),1!==a.layers.length+a.tables.length)h.layers=a.layers,h.tables=a.tables,k&&a.layerInfos?.length&&(h.sublayerConstructorProvider=await J(a.layerInfos));else if(k||g)g=a.layerInfos?.[0]??a.tableInfos?.[0],h.layerId=a.layers[0]?.id??a.tables[0]?.id,h.sourceJSON=g,k&&"Oriented Imagery Layer"===g?.type&&(c="OrientedImageryLayer");h.Constructor=await n(c);
return h}async function F(a,b){b=await l.fetchArcGISServiceJSON(a,{customParameters:b});let c=null,f=null;var e=b.type;"Feature Layer"===e||"Table"===e?(c="FeatureServer",f=b.id??null):"indexedVector"===e?c="VectorTileServer":b.hasOwnProperty("mapName")?c="MapServer":b.hasOwnProperty("bandCount")&&b.hasOwnProperty("pixelSizeX")?c="ImageServer":b.hasOwnProperty("maxRecordCount")&&b.hasOwnProperty("allowGeometryUpdates")?c="FeatureServer":b.hasOwnProperty("streamUrls")?c="StreamServer":x(b)?(c="SceneServer",
f=b.id):b.hasOwnProperty("layers")&&x(b.layers?.[0])&&(c="SceneServer");if(!c)return null;e=null!=f?r.parseNonStandardSublayerUrl(a):null;return{title:null!=e&&b.name||q.getFilename(a),serverType:c,sublayer:f,url:{path:null!=e?e.serviceUrl:q.urlToObject(a).path}}}function x(a){return null!=a&&a.hasOwnProperty("store")&&a.hasOwnProperty("id")&&"number"===typeof a.id}async function I(a,b,c){let f=!1,e;switch(b){case "FeatureServer":a=await B.fetchFeatureService(a,{customParameters:c});f=!!a.layersJSON;
a=a.layersJSON||a.serviceJSON;break;case "SceneServer":b=await K(a,c);a=b.serviceInfo;e=b.tableServerUrl;break;default:a=await l.fetchArcGISServiceJSON(a,{customParameters:c})}b=a?.layers;a=a?.tables;return{layers:b?.map(d=>({id:d.id})).reverse()||[],tables:a?.map(d=>({serverUrl:e,id:d.id})).reverse()||[],layerInfos:f?b:[],tableInfos:f?a:[]}}async function K(a,b){const c=await l.fetchArcGISServiceJSON(a,{customParameters:b});if(!c.layers?.[0])return{serviceInfo:c};try{const {serverUrl:f}=await A.findAssociatedFeatureService(a),
e=await l.fetchArcGISServiceJSON(f,{customParameters:b}).catch(()=>null);e&&(c.tables=e.tables);return{serviceInfo:c,tableServerUrl:f}}catch{return{serviceInfo:c}}}async function n(a){return(0,C.layerLookupMap[a])()}async function G(a,b){return(await l.fetchArcGISServiceJSON(a,{customParameters:b})).tileInfo}async function J(a){const b=[],c=[];a.forEach(d=>{({type:d}=d);"Oriented Imagery Layer"===d?(b.push(d),c.push(n("OrientedImageryLayer"))):(b.push(d),c.push(n("FeatureLayer")))});if(c.length){var f=
await Promise.all(c),e=new Map;b.forEach((d,k)=>{e.set(d,f[k])});return d=>e.get(d.type)}}const H={FeatureLayer:!0,SceneLayer:!0};p.fromUrl=async function(a){const b=await E(a.url,a.properties?.customParameters);a={...a.properties,url:a.url};if(0===b.layers.length+b.tables.length)return null!=b.layerId&&(a.layerId=b.layerId),null!=b.sourceJSON&&(a.sourceJSON=b.sourceJSON),new b.Constructor(a);const c=new (await new Promise((f,e)=>y(["../GroupLayer"],d=>f(Object.freeze(Object.defineProperty({__proto__:null,
default:d},Symbol.toStringTag,{value:"Module"}))),e))).default({title:b.parsedUrl.title});await D(c,b,a);return c};Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});