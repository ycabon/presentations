// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require ../../../chunks/tslib.es6 ../../../core/Error ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/Logger ../../../core/RandomLCG ../../../core/accessorSupport/decorators/subclass ../../../geometry/Polygon ./BaseRaster ../rasterFunctions/clipUtils ../rasterFunctions/pixelUtils ../rasterFunctions/rasterProjectionHelper ../../../rest/support/FeatureSet".split(" "),function(w,q,x,r,p,D,E,y,z,A,u,B,v,C){p=class extends A{constructor(){super(...arguments);this.datasetFormat=
"Function";this.tileType="Raster";this.rasterFunction=null;this._clippingGeometry=new Map}async open(a){await this.init();const {rasterFunction:b}=this;this.primaryRasters?.rasters?.length?b.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=b.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(d=>d.rasterJobHandler=this.rasterJobHandler));const {rasters:e,rasterIds:c}=this.primaryRasters;var g=e.map(d=>d.rasterInfo?void 0:d.open(a));await Promise.all(g);g=
e.map(({rasterInfo:d})=>d);var l=b.bind({rasterInfos:g,rasterIds:c});b.rawSourceRasterInfos=g;if(!l.success||0===g.length)throw new x("raster-function:open",`cannot bind the function: ${l.error??""}`);l="Table"===b.functionName?b:b.functionArguments?.raster;"Table"===l?.functionName&&(b.rasterInfo.attributeTable=C.fromJSON(l.functionArguments.attributeTableAsRecordSet));await this.syncJobHandler();const f=g[0];this.hasUniqueSourceStorageInfo=1===g.length||g.slice(1).every(d=>this._hasSameStorageInfo(d,
f));this.set("sourceJSON",e[0].sourceJSON);this.set("rasterInfo",b.rasterInfo);await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(a,b,e,c={}){const {rasters:g,rasterIds:l}=this.primaryRasters;var f=!1,{interpolation:d}=c,k=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!c.requestRawData&&k&&(f=1===g.length&&!c.skipRasterFunction,c={...c,interpolation:"bilinear",requestRawData:f});k=g.map(m=>
m.fetchPixels(a,b,e,c));k=await Promise.all(k);var h=k.map(m=>m.pixelBlock),n=f||c.requestRawData?k.map(m=>m.srcTilePixelSize):null;if(c.skipRasterFunction||h.every(m=>null==m))return k[0];const t=k.find(m=>null!=m.pixelBlock)?.extent??a;h=this.rasterJobHandler?await this.rasterJobHandler.process({extent:t,primaryPixelBlocks:h,primaryPixelSizes:n,primaryRasterIds:l}):this.rasterFunction.process({extent:t,primaryPixelBlocks:h,primaryPixelSizes:n,primaryRasterIds:l});({transformGrid:n}=k[0]);if(!f||
null==h||null==n)return d=c.noClip?null:this.getClippingGeometry(t.spatialReference),c.noClip||c.requestRawData||null==h||!d||(h=await u.clip(h,t,d)),{...k[0],pixelBlock:h};f={rows:n.spacing[0],cols:n.spacing[1]};d=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[h],srcMosaicSize:{width:h.width,height:h.height},destDimension:{width:b,height:e},coefs:n.coefficients,sampleSpacing:f,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:d,alignmentInfo:void 0,blockWidths:null},
c)).pixelBlock:B.approximateTransform(h,{width:b,height:e},n.coefficients,f,d);f=c.noClip?null:this.getClippingGeometry(a.spatialReference);c.noClip||c.requestRawData||null==d||null==f||(d=await u.clip(d,a,f));return{extent:a,srcExtent:k[0].srcExtent,pixelBlock:d}}getClippingGeometry(a){const b=this._clippingGeometry.get("0");if(!a||!b)return b;const e=this._getSRKey(a);let c=this._clippingGeometry.get(e);if(null!=c)return c;c=a.equals(b.spatialReference)?b:v.projectPolygon(b,a);this._clippingGeometry.set(e,
c);return c}_hasSameStorageInfo(a,b){const {storageInfo:e,pixelSize:c,spatialReference:g,extent:l}=a,{storageInfo:f,pixelSize:d,spatialReference:k,extent:h}=b;return c.x===d.x&&c.y===d.y&&g.equals(k)&&l.equals(h)&&e.blockHeight===f.blockHeight&&e.blockWidth===f.blockWidth&&e.maximumPyramidLevel===f.maximumPyramidLevel}async _updateClipGeometry(){var a=this.rasterFunction.getClippingGeometries()[0];let b=a?.clippingGeometry;if(b&&"inside"===a.clippingType){({extent:a}=this.rasterInfo);const {difference:e,
densify:c}=await new Promise((g,l)=>w(["../../../geometry/geometryEngine"],g,l));a=c(z.fromExtent(a),2*(a.width+a.height)/40);a=v.projectPolygon(a,b.spatialReference);b=e(a,b)}this._clippingGeometry.clear();b&&this._clippingGeometry.set("0",b)}_getSRKey(a){return String(a.wkid??a.wkt??a.wkt2)}};q.__decorate([r.property({type:String,json:{write:!0}})],p.prototype,"datasetFormat",void 0);q.__decorate([r.property()],p.prototype,"tileType",void 0);q.__decorate([r.property()],p.prototype,"rasterFunction",
void 0);q.__decorate([r.property()],p.prototype,"primaryRasters",void 0);return p=q.__decorate([y.subclass("esri.layers.support.rasterDatasets.FunctionRaster")],p)});