// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../geometry ../../../core/Error ../../../core/maybe ../../../core/urlUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/Logger ../../../core/RandomLCG ../../../core/accessorSupport/decorators/subclass ../RasterInfo ../RasterStorageInfo ../TileInfo ../TilemapCache ./BaseRaster ../rasterFunctions/pixelUtils ../rasterTransforms/GCSShiftTransform ../../../rest/imageService/fetchRasterInfo ../../../geometry/SpatialReference ../../../geometry/Point ../../../geometry/Extent".split(" "),
function(y,r,z,C,D,A,S,T,U,E,F,G,t,H,I,J,K,B,L,M,N){function O(a,b){if(!a)return null;const {minScale:c,maxScale:d,minLOD:f,maxLOD:h}=b;if(null!=f&&null!=h)return t.fromJSON({...a,lods:a.lods.filter(({level:e})=>null!=e&&e>=f&&e<=h)});if(0!==c&&0!==d){const e=c?Math.round(1E4*c)/1E4:Infinity,k=d?Math.round(1E4*d)/1E4:-Infinity;return t.fromJSON({...a,lods:a.lods.filter(g=>{g=Math.round(1E4*g.scale)/1E4;return g<=e&&g>=k})})}return t.fromJSON(a)}r=class extends I{constructor(){super(...arguments);
this._levelOffset=0;this._slices=this._tilemapCache=null;this.datasetFormat="RasterTileServer";this.tileType=null}async open(a){await this.init();var b=a?.signal;a=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:b});a.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));this.sourceJSON=a=a.data;if(!a)throw new z("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!a.tileInfo)throw new z("imageserverraster:open","use ImageryLayer to open non-tiled image services");
this._fixScaleInServiceInfo();var c="jpg jpeg png png8 png24 png32 mixed".split(" ");this.tileType=a.cacheType;null==this.tileType&&(c.includes(a.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===a.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster");this.datasetName=a.name?.slice(a.name.indexOf("/")+1)??"";b=await this._fetchRasterInfo({signal:b});if(null==b)throw new z("image-server-raster:open","cannot initialize image service");B.patchServiceInfo(b,a);c="Map"===
this.tileType?O(a.tileInfo,a):t.fromJSON(a.tileInfo);C.assertIsSome(c);const [d,f]=this._computeMinMaxLOD(b,c),{extent:h,pixelSize:e}=b,k=.5/b.width*e.x,g=Math.max(e.x,e.y),{lods:l}=c;if("Map"!==this.tileType&&0!==a.maxScale||Math.abs(e.x-e.y)>k||!l.some(m=>Math.abs(m.resolution-g)<k))e.x=e.y=d.resolution,b.width=Math.ceil((h.xmax-h.xmin)/e.x-.1),b.height=Math.ceil((h.ymax-h.ymin)/e.y-.1);const q=d.level-f.level,[u,v]=c.size,p=[],n=[];l.forEach((m,w)=>{m.level>=f.level&&m.level<=d.level&&p.push({x:m.resolution,
y:m.resolution});w<l.length-1&&n.push(Math.round(10*m.resolution/l[w+1].resolution)/10)});p.sort((m,w)=>m.x-w.x);const P=this.computeBlockBoundary(h,u,v,c.origin,p,q),Q=1<p.length?p.slice(1):null;var x;a.transposeInfo&&(x={tileSize:[a.transposeInfo.rows,a.transposeInfo.cols],packetSize:b.keyProperties?._yxs.PacketSize??0});const R=1>=n.length||3<=n.length&&n.slice(0,-1).every(m=>m===n[0])?n[0]??2:Math.round(10/(f.resolution/d.resolution)**(-1/q))/10;b.storageInfo=new G({blockWidth:c.size[0],blockHeight:c.size[1],
pyramidBlockWidth:c.size[0],pyramidBlockHeight:c.size[1],pyramidResolutions:Q,pyramidScalingFactor:R,compression:c.format,origin:c.origin,firstPyramidLevel:1,maximumPyramidLevel:q,tileInfo:c,transposeInfo:x,blockBoundary:P});this._fixGCSShift(b);this._set("rasterInfo",b);a.capabilities.toLowerCase().includes("tilemap")&&(x={tileInfo:b.storageInfo.tileInfo,parsedUrl:D.urlToObject(this.url),url:this.url,tileServers:[]},this._tilemapCache=new H.TilemapCache({layer:x}))}async fetchRawTile(a,b,c,d={}){const {storageInfo:f,
extent:h}=this.rasterInfo;var {transposeInfo:e}=f,k=null!=e&&!!d.transposedVariableName;if(this._slices&&!k&&null==d.sliceId)return null;({data:d}=await this.request(`${this.url}/tile/${k?0:f.maximumPyramidLevel-a+this._levelOffset}/${b}/${c}`,{query:this._slices?k?{variable:d.transposedVariableName}:{sliceId:d.sliceId||0}:null,responseType:"array-buffer",signal:d.signal}));if(!d)return null;e=k?e.tileSize:f.tileInfo.size;k=await this.decodePixelBlock(d,{width:e[0],height:e[1],planes:null,pixelType:null,
isPoint:"Elevation"===this.tileType,returnInterleaved:k,noDataValue:this.rasterInfo.noDataValue});if(null==k)return null;e=f.blockBoundary[a];if("jpg"!==f.compression||c>e.minCol&&c<e.maxCol&&b>e.minRow&&b<e.maxRow)return k;const {origin:g,blockWidth:l,blockHeight:q}=f,{x:u,y:v}=this.getPyramidPixelSize(a);var p=Math.round((h.xmin-g.x)/u)%l;a=Math.round((h.xmax-g.x)/u)%l||l;var n=Math.round((g.y-h.ymax)/v)%q;d=Math.round((g.y-h.ymin)/v)%q||q;p=c===e.minCol?p:0;n=b===e.minRow?n:0;J.setValidBoundary(k,
{x:p,y:n},{width:(c===e.maxCol?a:l)-p,height:(b===e.maxRow?d:q)-n});return k}getSliceIndex(a){if(!this._slices||null==a||0===a.length)return null;for(let b=0;b<this._slices.length;b++){const c=this._slices[b].multidimensionalDefinition;if(c.length===a.length&&!c.some(d=>{var f=a.find(e=>d.variableName===e.variableName&&e.dimensionName===d.dimensionName);if(!f)return!0;const h=Array.isArray(d.values[0])?`${d.values[0][0]}-${d.values[0][1]}`:d.values[0];f=Array.isArray(f.values[0])?`${f.values[0][0]}-${f.values[0][1]}`:
f.values[0];return h!==f}))return b}return null}async fetchVariableStatisticsHistograms(a,b){var c=this.request(this.url+"/statistics",{query:{variable:a,f:"json"},signal:b}).then(d=>d.data?.statistics);a=this.request(this.url+"/histograms",{query:{variable:a,f:"json"},signal:b}).then(d=>d.data?.histograms);c=await Promise.all([c,a]);c[0]&&c[0].forEach(d=>{d.avg=d.mean;d.stddev=d.standardDeviation});c[1]?.[0]?.counts?.length||(c[1]=null);return{statistics:c[0]||null,histograms:c[1]||null}}async computeBestPyramidLevelForLocation(a,
b={}){if(!this._tilemapCache)return 0;a=this.identifyPixelLocation(a,0,b.datumTransformation);if(null===a)return null;let c=0;var {maximumPyramidLevel:d}=this.rasterInfo.storageInfo;d=d-c+this._levelOffset;const f=a.srcLocation;for(;0<=d;){try{if("available"===await this._tilemapCache.fetchAvailability(d,a.row,a.col,b))break}catch{}d--;c++;a=this.identifyPixelLocation(f,c,b.datumTransformation);if(null===a)return null}return-1===d||null==a?null:c}async _fetchRasterInfo(a){var b=this.sourceJSON;if("Map"===
this.tileType){a=b.fullExtent||b.extent;var c=Math.ceil((a.xmax-a.xmin)/b.pixelSizeX-.1);const d=Math.ceil((a.ymax-a.ymin)/b.pixelSizeY-.1),f=L.fromJSON(b.spatialReference||a.spatialReference);b=new M({x:b.pixelSizeX,y:b.pixelSizeY,spatialReference:f});return new F({width:c,height:d,bandCount:3,extent:N.fromJSON(a),spatialReference:f,pixelSize:b,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}({signal:c}=a);a=B.fetchServiceRasterInfo(this.url,this.sourceJSON,{signal:c,query:this.ioConfig.customFetchParameters});
b=b.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:c}).then(d=>d.data?.slices).catch(()=>null):null;b=await Promise.all([a,b]);this._slices=b[1];return b[0]}_fixScaleInServiceInfo(){const {sourceJSON:a}=this;a.minScale&&0>a.minScale&&(a.minScale=0);a.maxScale&&0>a.maxScale&&(a.maxScale=0)}_fixGCSShift(a){const {extent:b,spatialReference:c}=a;-1<b.xmin&&181<b.xmax&&c?.wkid&&c.isGeographic&&(a.nativeExtent=a.extent,a.transform=new K,a.extent=a.transform.forwardTransform(b))}_computeMinMaxLOD(a,
b){const {pixelSize:c}=a,d=.5/a.width*c.x;({lods:a}=b);var f=b.lodAt(Math.max.apply(null,a.map(g=>g.level)));b=b.lodAt(Math.min.apply(null,a.map(g=>g.level)));var {tileType:h}=this;if("Map"===h)return this._levelOffset=a[0].level,[f,b];if("Raster"===h)return[a.find(g=>g.resolution===c.x)??f,b];const {minScale:e,maxScale:k}=this.sourceJSON;h=f;0<k&&((h=a.find(g=>Math.abs(g.scale-k)<d))||(h=a.filter(g=>g.scale>k).sort((g,l)=>g.scale>l.scale?1:-1)[0]??f));f=b;0<e&&(f=a.find(g=>Math.abs(g.scale-e)<d)??
b,this._levelOffset=f.level-b.level);return[h,f]}};y.__decorate([A.property({type:String,json:{write:!0}})],r.prototype,"datasetFormat",void 0);y.__decorate([A.property()],r.prototype,"tileType",void 0);return r=y.__decorate([E.subclass("esri.layers.support.rasterDatasets.ImageServerRaster")],r)});