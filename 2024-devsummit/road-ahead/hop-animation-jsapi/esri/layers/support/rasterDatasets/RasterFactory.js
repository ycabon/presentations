// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../../core/Error ./CloudRaster ./CovJSONRaster ./ImageAuxRaster ./ImageServerRaster ./InMemoryRaster ./MRFRaster ./TIFFRaster".split(" "),function(m,p,q,h,r,t,u,v){const b=new Map;b.set("CRF",{desc:"Cloud Raster Format",constructor:p});b.set("MRF",{desc:"Meta Raster Format",constructor:u});b.set("TIFF",{desc:"GeoTIFF",constructor:v});b.set("RasterTileServer",{desc:"Raster Tile Server",constructor:r});b.set("JPG",{desc:"JPG Raster Format",constructor:h});b.set("PNG",{desc:"PNG Raster Format",
constructor:h});b.set("GIF",{desc:"GIF Raster Format",constructor:h});b.set("BMP",{desc:"BMP Raster Format",constructor:h});b.set("CovJSON",{desc:"COVJSON Raster Format",constructor:q});b.set("MEMORY",{desc:"In Memory Raster Format",constructor:t});class w{static get supportedFormats(){const c=new Set;b.forEach((d,e)=>c.add(e));return c}static async open(c){const {url:d,ioConfig:e,source:k,sourceJSON:x}=c;let a=c.datasetFormat??e?.datasetFormat;null==a&&(d.includes(".")?a=d.slice(d.lastIndexOf(".")+
1).toUpperCase():"coverage"===k?.type?.toLowerCase()?a="CovJSON":k?.extent&&k.pixelblocks&&(a="MEMORY"));"OVR"===a||"TIF"===a?a="TIFF":"JPG"===a||"JPEG"===a||"JFIF"===a?a="JPG":"COVJSON"===a&&(a="CovJSON");d.toLowerCase().includes("/imageserver")&&!d.toLowerCase().includes("/wcsserver")&&(a="RasterTileServer");var l={bandIds:null,sampling:null};const g={url:d,source:k,sourceJSON:x,datasetFormat:a,ioConfig:e??l};Object.keys(g).forEach(f=>{null==g[f]&&delete g[f]});if(a){if(!this.supportedFormats.has(a))throw new m("rasterfactory:open",
"not a supported format "+a);if("CRF"===a&&!e?.enableCRF)throw new m("rasterfactory:open",`cannot open raster: ${d}`);l=new (b.get(a).constructor)(g);await l.open({signal:c.signal});return l}const y=Array.from(b.keys()).filter(f=>"CovJSON"!==f&&"Memory"!==f);let z=0;const n=()=>{a=y[z++];if(!a||"CRF"===a&&!e?.enableCRF)return null;const f=new (b.get(a).constructor)(g);return f.open({signal:c.signal}).then(()=>f).catch(()=>n())};return n()}static register(c,d,e){b.has(c.toUpperCase())||b.set(c.toUpperCase(),
{desc:d,constructor:e})}}return w});