// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require ../chunks/tslib.es6 ../geometry ../Graphic ../request ../core/Error ../core/Loadable ../core/Logger ../core/MultiOriginJSONSupport ../core/promiseUtils ../core/urlUtils ../core/accessorSupport/decorators/property ../core/has ../core/RandomLCG ../core/accessorSupport/decorators/subclass ../geometry/Extent ../geometry/support/jsonUtils ../layers/mixins/EditBusLayer ../layers/support/arcgisLayerUrl ./support/TopologyValidationJobInfo ./support/utils ../versionManagement/support/versionManagementUtils ../geometry/SpatialReference".split(" "),
function(p,d,c,y,v,t,z,A,B,C,D,e,J,K,E,F,G,q,w,H,I,r,x){const u=a=>Object.freeze(Object.defineProperty({__proto__:null,default:a},Symbol.toStringTag,{value:"Module"}));c=class extends B.MultiOriginJSONMixin(z){static fromPortalItem(a){return I.networkFromPortalItem(a)}constructor(a){super(a);this.historicMoment=this.gdbVersion=this.sourceJSON=this.type=this.spatialReference=this.fullExtent=this.dataElement=this.layerUrl=this.title=this.id=null;this._applyEditsHandler=b=>{const {serviceUrl:g,gdbVersion:f,
result:k}=b;b=g===this.featureServiceUrl;const h=q.versionMatches(g,f,this.gdbVersion);b&&h&&k.then(l=>{r.isVersionInEditSession(g,f)&&(this.historicMoment=l.historicMoment)})};this._updateMomentHandler=b=>{const {serviceUrl:g,gdbVersion:f,moment:k}=b;b=g===this.featureServiceUrl;const h=q.versionMatches(g,f,this.gdbVersion);b&&h&&(this.historicMoment=k)};this.when().then(()=>{this.addHandles([q.onApplyEditsEvent(this._applyEditsHandler),q.onUpdateMomentEvent(this._updateMomentHandler)])},()=>{})}initialize(){this.when().catch(a=>
{C.isAbortError(a)||A.getLogger(this).error("#load()",`Failed to load layer (title: '${this.title??"no title"}', id: '${this.id??"no id"}')`,{error:a})})}get datasetName(){return this.dataElement?.name??null}get owner(){return this.dataElement?.userIdentity??null}get schemaGeneration(){return this.dataElement?.schemaGeneration??null}get parsedUrl(){return D.urlToObject(this.layerUrl)}get featureServiceUrl(){return w.parse(this.parsedUrl.path).url.path}get networkServiceUrl(){return this.featureServiceUrl.replace(/\/FeatureServer/i,
"/UtilityNetworkServer")}get layerId(){return w.parse(this.parsedUrl.path).sublayer}get networkSystemLayers(){return null}async load(a){this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl,this.layerId.toString(),a));this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl,a));return this}getLayerIdBySourceId(a){if(this.dataElement){const b=this.dataElement.domainNetworks;for(const g of b){for(const f of g.edgeSources??[])if(f.sourceId===a)return f.layerId;for(const f of g.junctionSources??
[])if(f.sourceId===a)return f.layerId}}return null}async queryNamedTraceConfigurations(a,b){const [{queryNamedTraceConfigurations:g},{default:f}]=await Promise.all([new Promise((h,l)=>p(["../rest/networks/queryNamedTraceConfigurations"],h,l)),new Promise((h,l)=>p(["../rest/networks/support/QueryNamedTraceConfigurationsParameters"],m=>h(u(m)),l))]),k=this.networkServiceUrl;a=f.from(a);return(await g(k,a,{...b}))?.namedTraceConfigurations}async validateTopology(a,b){if(!a.validateArea)throw new t("network:undefined-validateArea",
"the network must have validateArea defined in the validate network topology parameters.");const [{validateNetworkTopology:g},{default:f}]=await Promise.all([new Promise((l,m)=>p(["../rest/networks/validateNetworkTopology"],l,m)),new Promise((l,m)=>p(["../rest/networks/support/ValidateNetworkTopologyParameters"],n=>l(u(n)),m))]);var k=f.from(a);r.isVersionInEditSession(this.featureServiceUrl,this.gdbVersion||null)&&(k.sessionID=r.currentSessionId);k.gdbVersion=this.gdbVersion;var h=this.networkServiceUrl;
a=q.emitApplyEditsEvent(this.featureServiceUrl,null,this.gdbVersion,!0);b=await g(h,k,{...b});if(b?.serviceEdits){k=[];for(const l of b.serviceEdits){({editedFeatures:h}=l);const m=h?.spatialReference?new x(h.spatialReference):null;k.push({layerId:l.layerId,editedFeatures:{adds:h?.adds?.map(n=>this._createEditedFeature(n,m))||[],updates:h?.updates?.map(n=>({original:this._createEditedFeature(n[0],m),current:this._createEditedFeature(n[1],m)}))||[],deletes:h?.deletes?.map(n=>this._createEditedFeature(n,
m))||[],spatialReference:m}})}a.resolve({edits:null,addedFeatures:[],updatedFeatures:[],deletedFeatures:[],addedAttachments:[],updatedAttachments:[],deletedAttachments:[],editedFeatures:k,exceededTransferLimit:!1,historicMoment:b.moment})}return b}async submitTopologyValidationJob(a,b){if(!a.validateArea)throw new t("network:undefined-validateArea","the network must have validateArea defined in the validate network topology parameters.");if(!this.gdbVersion)throw new t("network:undefined-gdb-version",
"version must be defined");const [{submitValidateNetworkTopologyJob:g},{default:f}]=await Promise.all([new Promise((l,m)=>p(["../rest/networks/validateNetworkTopology"],l,m)),new Promise((l,m)=>p(["../rest/networks/support/ValidateNetworkTopologyParameters"],n=>l(u(n)),m))]),k=f.from(a);r.isVersionInEditSession(this.featureServiceUrl,this.gdbVersion||null)&&(k.sessionID=r.currentSessionId);k.gdbVersion=this.gdbVersion;const h=this.networkServiceUrl;a=this.featureServiceUrl?q.emitApplyEditsEvent(this.featureServiceUrl,
null,this.gdbVersion,!0):void 0;b=await g(h,k,{...b});return new H({statusUrl:b,editsResolver:a})}_createEditedFeature(a,b){return new y({attributes:a.attributes,geometry:G.fromJSON({...a.geometry,spatialReference:b})})}async _fetchLayerMetaData(a,b){a=await v(a,{responseType:"json",query:{f:"json"},...b});this.sourceJSON=a.data;this.read(a.data,{origin:"service"})}async _fetchDataElement(a,b,g){this.dataElement||(a=await v(`${a}/queryDataElements`,{responseType:"json",query:{layers:JSON.stringify([b]),
f:"json"},...g}).then(f=>f.data.layerDataElements?.[0]))&&this.read(a,{origin:"service"})}};d.__decorate([e.property({type:String,nonNullable:!0,json:{origins:{"web-map":{read:!0,write:{isRequired:!0}},service:{read:!0}},read:!1}})],c.prototype,"id",void 0);d.__decorate([e.property({type:String,nonNullable:!0,json:{origins:{"web-map":{read:!0,write:{isRequired:!0}},service:{read:{source:"name"}}},read:!1}})],c.prototype,"title",void 0);d.__decorate([e.property({type:String,nonNullable:!0,json:{origins:{"web-map":{read:{source:"url"},
write:{target:"url",isRequired:!0}}},read:!1}})],c.prototype,"layerUrl",void 0);d.__decorate([e.property({type:Object,json:{origins:{service:{read:!0}},read:!1}})],c.prototype,"dataElement",void 0);d.__decorate([e.property({type:F,json:{origins:{service:{read:{source:"extent"}}},read:!1}})],c.prototype,"fullExtent",void 0);d.__decorate([e.property({type:x,json:{origins:{service:{read:{source:"extent.spatialReference"}}},read:!1}})],c.prototype,"spatialReference",void 0);d.__decorate([e.property({type:["utility",
"trace"],readOnly:!0,json:{read:!1,write:!1}})],c.prototype,"type",void 0);d.__decorate([e.property({readOnly:!0})],c.prototype,"datasetName",null);d.__decorate([e.property({readOnly:!0})],c.prototype,"owner",null);d.__decorate([e.property({readOnly:!0})],c.prototype,"schemaGeneration",null);d.__decorate([e.property({readOnly:!0})],c.prototype,"parsedUrl",null);d.__decorate([e.property({readOnly:!0})],c.prototype,"featureServiceUrl",null);d.__decorate([e.property({readOnly:!0})],c.prototype,"networkServiceUrl",
null);d.__decorate([e.property({readOnly:!0})],c.prototype,"layerId",null);d.__decorate([e.property()],c.prototype,"sourceJSON",void 0);d.__decorate([e.property({readOnly:!0})],c.prototype,"networkSystemLayers",null);d.__decorate([e.property()],c.prototype,"gdbVersion",void 0);d.__decorate([e.property({type:Date})],c.prototype,"historicMoment",void 0);return c=d.__decorate([E.subclass("esri.networks.Network")],c)});