// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../core/colorUtils ../../core/JSONSupport ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/has ../../core/RandomLCG ../../core/accessorSupport/decorators/subclass ../../layers/support/RasterInfo ../../layers/support/rasterFunctions/pixelUtils ../../layers/support/rasterFunctions/stretchUtils ../../layers/support/rasterFunctions/surfaceUtils ./colorRampUtils ./rasterRendererChecks".split(" "),function(v,D,u,A,w,H,I,E,F,q,r,y,B,z){function C(a){return q.isValidPixelBlock(a)&&
0!==a.validPixelCount}u=class extends u.JSONSupport{constructor(a){super(a)}bind(){const {rendererJSON:a}=this;if(!a)return{success:!1};this.lookup={rendererJSON:{}};let b;switch(a.type){case "uniqueValue":b=this._updateUVRenderer(a);break;case "rasterColormap":b=this._updateColormapRenderer(a);break;case "rasterStretch":b=this._updateStretchRenderer(a);break;case "classBreaks":b=this._updateClassBreaksRenderer(a);break;case "rasterShadedRelief":b=this._updateShadedReliefRenderer(a);break;case "vectorField":b=
this._updateVectorFieldRenderer();break;case "flowRenderer":b=this._updateFlowRenderer()}return b}symbolize(a){let b=a?.pixelBlock;if(!C(b))return b;if(a.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch(b,a.simpleStretchParams);try{3<b.pixels.length&&(b=b.extractBands(a.bandIds??[0,1,2]));let d;switch(this.rendererJSON.type){case "uniqueValue":case "rasterColormap":d=this._symbolizeColormap(b);break;case "classBreaks":d=this._symbolizeClassBreaks(b);break;case "rasterStretch":d=
this._symbolizeStretch(b,a.bandIds);break;case "rasterShadedRelief":const h=a.extent;d=this._symbolizeShadedRelief(b,{isGCS:h.spatialReference.isGeographic,resolution:{x:(h.xmax-h.xmin)/b.width,y:(h.ymax-h.ymin)/b.height}})}return d}catch(d){return A.getLogger(this).error("symbolize",d.message),b}}simpleStretch(a,b){if(!C(a))return a;try{return 3<a.pixels.length&&(a=a.extractBands([0,1,2])),r.stretch(a,{...b,isRenderer:!0})}catch(d){return A.getLogger(this).error("symbolize",d.message),a}}generateWebGLParameters(a){if(["uniqueValue",
"rasterColormap","classBreaks"].includes(this.rendererJSON.type)){const {indexedColormap:c,offset:k}=this.lookup.colormapLut||{};return{colormap:c,colormapOffset:k,type:"lut"}}const {pixelBlock:b,isGCS:d,resolution:h,bandIds:l}=a;({rendererJSON:a}=this);return"rasterStretch"===a.type?this._generateStretchWebGLParams(b,a,l):"rasterShadedRelief"===a.type?this._generateShadedReliefWebGLParams(a,d,h??void 0):"vectorField"===a.type?this._generateVectorFieldWebGLParams(a):null}_isLUTChanged(a){if(!this.lookup||
!this.lookup.rendererJSON)return!0;if("colorRamp"in this.rendererJSON){const b=this.rendererJSON.colorRamp;if(a)return JSON.stringify(b)!==JSON.stringify(this.lookup.rendererJSON.colorRamp);({...this.rendererJSON});({...this.lookup.rendererJSON})}return JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON)}_symbolizeColormap(a){return this._isLUTChanged()&&!this.bind().success?a:q.colorize(a,this.lookup.colormapLut)}_symbolizeClassBreaks(a){const {canUseIndexedLUT:b}=this._analyzeClassBreaks(this.rendererJSON);
return this._isLUTChanged()&&!this.bind().success?a:b?q.colorize(a,this.lookup.colormapLut):q.remapColor(a,this.lookup.remapLut??[])}_symbolizeStretch(a,b){const {rasterInfo:d}=this,{pixelType:h,bandCount:l}=d,c=this.rendererJSON;var k=["u8","u16","s8","s16"].includes(h);let f;var {dra:g}=c;({gamma:e}=this.lookup);if("histogramEqualization"===c.stretchType){k=g?null:this.lookup?.histogramLut;b=r.getStretchCutoff(c,{rasterInfo:d,pixelBlock:a,bandIds:b,returnHistogramLut:!k});var e=r.stretch(a,{...b,
gamma:e,isRenderer:!0});e=q.lookupPixels(e,{lut:g?b.histogramLut:k,offset:0})}else if(k){if(g)g=r.getStretchCutoff(c,{rasterInfo:d,pixelBlock:a,bandIds:b}),f=r.createStretchLUT({pixelType:h,...g,gamma:e,rounding:"floor"});else{if(this._isLUTChanged()&&!this.bind().success)return a;f=this.lookup?this.lookup.stretchLut:null}if(!f)return a;1<l&&null!=b&&b.length===a?.pixels.length&&f?.lut.length===l&&(f={lut:b.map(m=>f.lut[m]),offset:f.offset});e=q.lookupPixels(a,f)}else g=r.getStretchCutoff(c,{rasterInfo:d,
pixelBlock:a,bandIds:b}),e=r.stretch(a,{...g,gamma:e,isRenderer:!0});if(c.colorRamp){if(this._isLUTChanged(!0)&&!this.bind().success)return a;e=q.colorize(e,this.lookup?.colormapLut)}return e}_symbolizeShadedRelief(a,b){var d=this.rendererJSON;b=y.hillshade(a,{...d,...b});if(!d.colorRamp||this._isLUTChanged(!0)&&!this.bind().success)return b;d=this.lookup?this.lookup.hsvMap:null;if(!d)return b;y.tintHillshade(b,a,d,this.rasterInfo.statistics?.[0]??{min:0,max:8E3});return b}_isVectorFieldData(){const {bandCount:a,
dataType:b}=this.rasterInfo;return 2===a&&("vector-magdir"===b||"vector-uv"===b)}_updateVectorFieldRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}}_updateFlowRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}}_updateUVRenderer(a){const {bandCount:b,
attributeTable:d,pixelType:h}=this.rasterInfo,l=a.field1;if(!l)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const c=a.defaultSymbol;var k=1===b&&["u8","s8"].includes(h);if(!z.isUVRendererSupported(this.rasterInfo,l)&&!k)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const f=[];if(null!=d){const g=d.fields.find(e=>"value"===e.name.toLowerCase());if(!g)return{success:!1,
error:"Unsupported data; the data's raster attribute table does not have a value field."};d.features.forEach(e=>{const m=a.uniqueValueInfos?.find(p=>String(p.value)===String(e.attributes[l]))?.symbol?.color;m?f.push([e.attributes[g.name]].concat(m)):c&&f.push([e.attributes[g.name]].concat(c.color))})}else{if("value"!==l.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.'};a.uniqueValueInfos?.forEach(g=>
{const e=g?.symbol?.color;e?f.push([parseInt(""+g.value,10)].concat(e)):c&&f.push([parseInt(""+g.value,10)].concat(c?.color))})}if(0===f.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};k=q.createColormapLUT({colormap:f});this.lookup={rendererJSON:a,colormapLut:k};this.canRenderInWebGL=this._isColormapSupportedByWebGL(k?.indexedColormap);return{success:!0}}_updateColormapRenderer(a){if(!z.isColormapRendererSupported(this.rasterInfo))return{success:!1,
error:"Unsupported data; the data source does not have a colormap."};var b=a.colormapInfos.map(d=>[d.value].concat(d.color)).sort((d,h)=>d[0]-h[0]);if(!b||0===b.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};b=q.createColormapLUT({colormap:b});this.lookup={rendererJSON:a,colormapLut:b};this.canRenderInWebGL=this._isColormapSupportedByWebGL(b?.indexedColormap);return{success:!0}}_updateShadedReliefRenderer(a){if(!z.isShadedReliefRendererSupported(this.rasterInfo))return{success:!1,
error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.`};if(a.colorRamp){var b=B.convertColorRampToColormap(a.colorRamp,{interpolateAlpha:!0});b=q.createColormapLUT({colormap:b});const d=[],h=b.indexedColormap;for(let l=0;l<h.length;l+=4){const c=D.toHSV({r:h[l],g:h[l+1],b:h[l+2]});d.push([c.h/60,c.s/100,255*c.v/100])}this.lookup={rendererJSON:a,colormapLut:b,hsvMap:d}}else this.lookup=null;this.canRenderInWebGL=!0;
return{success:!0}}_analyzeClassBreaks(a){const {attributeTable:b,pixelType:d}=this.rasterInfo,h=null!=b?b.fields.find(k=>"value"===k.name.toLowerCase()):null,l=null!=b?b.fields.find(k=>k.name.toLowerCase()===a.field.toLowerCase()):null,c=null!=h&&null!==l;return{canUseIndexedLUT:["u8","u16","s8","s16"].includes(d)||c,tableValueField:h,tableBreakField:l}}_updateClassBreaksRenderer(a){var {attributeTable:b}=this.rasterInfo;const {canUseIndexedLUT:d,tableValueField:h,tableBreakField:l}=this._analyzeClassBreaks(a);
var c=a.classBreakInfos;if(!c?.length)return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};c=c.sort((m,p)=>m.classMaxValue-p.classMaxValue);var k=c[c.length-1],f=a.minValue;if(!d){var g=[];for(var e=0;e<c.length;e++)g.push({value:c[e].classMinValue??f,mappedColor:c[e].symbol.color}),f=c[e].classMaxValue;g.push({value:k.classMaxValue,mappedColor:k.symbol.color});this.lookup={rendererJSON:a,remapLut:g};this.canRenderInWebGL=!1;return{success:!0}}g=
[];if(null!=b&&null!=h&&null!==l&&h!==l){k=h.name;const m=l.name,p=c[c.length-1],{classMaxValue:n}=p;f=a.minValue;for(e of b.features){b=e.attributes[k];const t=e.attributes[m],x=t===n?p:t<f?null:c.find(({classMaxValue:G})=>G>t);x&&g.push([b].concat(x.symbol.color))}}else{f=Math.floor(a.minValue);for(e=0;e<c.length;e++){for(b=c[e];f<b.classMaxValue;f++)g.push([f].concat(b.symbol.color));f=Math.ceil(b.classMaxValue)}k.classMaxValue===f&&g.push([k.classMaxValue].concat(k.symbol.color))}c=q.createColormapLUT({colormap:g,
fillUnspecified:!1});this.lookup={rendererJSON:a,colormapLut:c};this.canRenderInWebGL=this._isColormapSupportedByWebGL(c?.indexedColormap);return{success:!0}}_isColormapSupportedByWebGL(a){return!!a?.length&&16384>=a.length}_isHistogramRequired(a){return"percentClip"===a||"histogramEqualization"===a}_isValidRasterStatistics(a){return null!=a&&0<a.length&&null!=a[0].min&&null!=a[0].max}_updateStretchRenderer(a){let {stretchType:b,dra:d}=a;if(!("none"===b||a.statistics?.length||this._isValidRasterStatistics(this.rasterInfo.statistics)||
d))return{success:!1,error:"Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used."};var h=a.histograms||this.rasterInfo.histograms;!this._isHistogramRequired(a.stretchType)||h?.length||d||(b="minMax");const {computeGamma:l,useGamma:c,colorRamp:k}=a;let {gamma:f}=a;c&&l&&!f?.length&&(f=r.computeGammaValues(this.rasterInfo.pixelType,a.statistics?.length?a.statistics:this.rasterInfo.statistics));var g=this.rasterInfo.pixelType;const e=!d&&["u8","u16",
"s8","s16"].includes(g);"histogramEqualization"===b?(g=h.map(m=>r.createHistogramEqualizationLUT(m)),this.lookup={rendererJSON:a,histogramLut:g}):e&&(h=r.getStretchCutoff(a,{rasterInfo:this.rasterInfo}),g=r.createStretchLUT({pixelType:g,...h,gamma:c?f:null,rounding:"floor"}),this.lookup={rendererJSON:a,stretchLut:g});k&&!this._isStretchColorRampNoop(k)&&(g=B.convertColorRampToColormap(k,{interpolateAlpha:!0}),this.lookup||(this.lookup={rendererJSON:a}),this.lookup.colormapLut=q.createColormapLUT({colormap:g}),
this.lookup.rendererJSON=a);this.lookup.gamma=c&&f?.length?f:null;this.canRenderInWebGL=!0;return{success:!0}}_isStretchColorRampNoop(a){return"algorithmic"===a.type&&["0,0,0,255","0,0,0"].includes(a.fromColor.join(","))&&["255,255,255,255","255,255,255"].includes(a.toColor.join(","))}_generateStretchWebGLParams(a,b,d){let h=null,l=null;var c=this.lookup?.colormapLut;b.colorRamp&&c&&(h=c.indexedColormap,l=c.offset);"histogramEqualization"===b.stretchType&&(b={...b,stretchType:"minMax"});({gamma:c}=
this.lookup);const k=!!(b.useGamma&&c&&c.some(x=>1!==x)),{minCutOff:f,maxCutOff:g,outMin:e,outMax:m}=r.getStretchCutoff(b,{rasterInfo:this.rasterInfo,pixelBlock:a,bandIds:d});var p=0;null!=a&&(p=a.getPlaneCount(),2===p&&(a=a.clone(),a.statistics=[a.statistics[0]],a.pixels=[a.pixels[0]]));({bandCount:a}=this.rasterInfo);d=Math.min(3,d?.length||p||a,a);a=new Float32Array(d);p=h||k?1:255;let n;for(n=0;n<f.length;n++)a[n]=g[n]===f[n]?0:(m-e)/(g[n]-f[n])/p;const t=new Float32Array(d);if(k&&c)for(n=0;n<
d;n++)t[n]=1<c[n]?2<c[n]?6.5+(c[n]-2)**2.5:6.5+100*(2-c[n])**4:1;return{bandCount:d,outMin:e/p,outMax:m/p,minCutOff:f,maxCutOff:g,factor:a,useGamma:k,gamma:k?c:[1,1,1],gammaCorrection:k?t:[1,1,1],colormap:h,colormapOffset:l,stretchType:b.stretchType,type:"stretch"}}_generateShadedReliefWebGLParams(a,b=!1,d={x:0,y:0}){let h=null,l=null;const c=this.lookup?.colormapLut;a.colorRamp&&c&&(h=c.indexedColormap,l=c.offset);b=y.calculateHillshadeParams({...a,isGCS:b,resolution:d});d=this.rasterInfo.statistics?.[0];
return{...b,minValue:d?.min??0,maxValue:d?.max??8E3,hillshadeType:"traditional"===a.hillshadeType?0:1,type:"hillshade",colormap:h,colormapOffset:l}}_generateVectorFieldWebGLParams(a){const {style:b,inputUnit:d,outputUnit:h,visualVariables:l,symbolTileSize:c,flowRepresentation:k}=a;let f;var g=this.rasterInfo.statistics?.[0].min??0,e=this.rasterInfo.statistics?.[0].max??50,m=l?.find(t=>"sizeInfo"===t.type)??{type:"sizeInfo",field:"Magnitude",maxDataValue:e,maxSize:.8*c,minDataValue:g,minSize:.2*c},
p=m.minDataValue??g,n=m.maxDataValue??e;e=null!=m.maxSize&&null!=m.minSize?[m.minSize/c,m.maxSize/c]:[.2,.8];"wind_speed"===b&&(e[0]=e[1]=(e[0]+e[1])/2);g=null!=p&&null!=n?[p,n]:null;if("classified_arrow"===b)if(null!=p&&null!=n&&null!=m)for(f=[],p=(m.maxDataValue-m.minDataValue)/5,n=0;6>n;n++)f.push(m.minDataValue+p*n);else f=[0,1E-6,3.5,7,10.5,14];m="flow_to"===k===("ocean_current_kn"===b||"ocean_current_m"===b)?0:Math.PI;p=l?.find(t=>"rotationInfo"===t.type);return{breakValues:f,dataRange:g,inputUnit:d,
outputUnit:h,symbolTileSize:c,symbolPercentRange:e,style:b||"single_arrow",rotation:m,rotationType:this.rasterInfo.storageInfo?.tileInfo&&"vector-uv"===this.rasterInfo.dataType?"geographic":p?.rotationType||a.rotationType,type:"vectorField"}}};v.__decorate([w.property({json:{write:!0}})],u.prototype,"rendererJSON",void 0);v.__decorate([w.property({type:F,json:{write:!0}})],u.prototype,"rasterInfo",void 0);v.__decorate([w.property({json:{write:!0}})],u.prototype,"lookup",void 0);v.__decorate([w.property()],
u.prototype,"canRenderInWebGL",void 0);return u=v.__decorate([E.subclass("esri.renderers.support.RasterSymbolizer")],u)});