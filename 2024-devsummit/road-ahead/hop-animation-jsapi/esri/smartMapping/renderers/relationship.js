// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../core/Error ../../core/lang ../../intl/messages ../../renderers/support/AuthoringInfo ../../renderers/support/AuthoringInfoClassBreakInfo ../../renderers/support/AuthoringInfoFieldInfo ./type ./support/utils ../support/binningUtils ../support/adapters/support/layerUtils ../symbology/relationship ../../symbols/support/utils".split(" "),function(w,h,F,G,H,A,B,I,r,J,t,u,K){async function L(a){if(!(a?.layer&&a.view&&a.field1&&a.field2))throw new h("relationship-renderer:missing-parameters",
"'layer', 'view', 'field1' and 'field2' parameters are required");a.forBinning&&J.verifyBinningParams(a,"relationship-renderer");const b={...a,layer:a.layer,field1:a.field1,field2:a.field2};b.symbolType??(b.symbolType="2d");b.defaultSymbolEnabled??(b.defaultSymbolEnabled=!0);b.classificationMethod??(b.classificationMethod="quantile");b.numClasses??(b.numClasses=3);b.focus??(b.focus=null);if(!M.has(b.classificationMethod))throw new h("relationship-renderer:invalid-parameters",`classification method ${b.classificationMethod} is not supported`);
if(2>b.numClasses||4<b.numClasses)throw new h("relationship-renderer:invalid-parameters","'numClasses' must be 2, 3 or 4");if(a.focus&&!N.has(a.focus))throw new h("relationship-renderer:invalid-parameters","'focus' must be 'HH', 'HL', 'LH', 'LL' or null");var c=a.forBinning?t.binningCapableLayerTypes:t.featureCapableLayerTypes;a=t.createLayerAdapter(b.layer,c,a.forBinning);if(!a)throw new h("relationship-renderer:invalid-parameters","'layer' must be one of these types: "+t.getLayerTypeLabels(c).join(", "));
b.layer=a;await a.load(null!=b.signal?{signal:b.signal}:null);c=a.geometryType;const d=b.symbolType.includes("3d");b.outlineOptimizationEnabled="polygon"===c?b.outlineOptimizationEnabled:!1;b.sizeOptimizationEnabled="point"===c||"multipoint"===c||"polyline"===c?b.sizeOptimizationEnabled:!1;if("mesh"===c)b.symbolType="3d-volumetric",b.colorMixMode=b.colorMixMode||"replace",b.edgesType=b.edgesType||"none";else{if("3d-volumetric-uniform"===b.symbolType&&"point"!==c)throw new h("relationship-renderer:not-supported",
"3d-volumetric-uniform symbols are supported for point layers only");if(d&&"polygon"===c)throw new h("relationship-renderer:not-supported","3d symbols are not supported for polygon layers");if(b.symbolType.includes("3d-volumetric")&&(!b.view||"3d"!==b.view.type))throw new h("relationship-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");}const {field1:e,field2:f}=b;c=[e.field,f.field];e.normalizationField&&
c.push(e.normalizationField);f.normalizationField&&c.push(f.normalizationField);if(a=r.verifyBasicFieldValidity(a,c,"relationship-renderer:invalid-parameters"))throw a;return b}async function O(a){if(!a?.renderer||!a.numClasses)throw new h("update-relationship-renderer:missing-parameters","'renderer' and 'numClasses' parameters are required");const {field1:b,field2:c,renderer:d,numClasses:e,colors:f}=a,g=e**2;if((b||c)&&!(b&&c&&b.field&&c.field))throw new h("update-relationship-renderer:missing-parameters",
"'field1' and 'field2' parameters are required");if(b&&!b.classBreakInfos||c&&!c.classBreakInfos)throw new h("update-relationship-renderer:missing-parameters","'field1.classBreakInfos' and 'field2.classBreakInfos' are required");if(!d.authoringInfo)throw new h("update-relationship-renderer:missing-parameters","'renderer.authoringInfo' is required");if(d.uniqueValueInfos?.length!==g)throw new h("update-relationship-renderer:invalid-parameters",`Renderer must have ${g} unique value infos to support ${e} classes`);
if(f&&f.length!==g)throw new h("update-relationship-renderer:invalid-parameters",`The scheme must have ${g} colors`);return a}async function P(a){let b=a.relationshipScheme,c=null;var d=null;d=await r.getBasemapInfo(a.basemap,a.view);c=null!=d.basemapId?d.basemapId:null;d=null!=d.basemapTheme?d.basemapTheme:null;if(b)return{scheme:u.cloneScheme(b),basemapId:c,basemapTheme:d};if(a=u.getSchemes({basemapTheme:d,geometryType:a.geometryType,theme:a.theme,worldScale:a.worldScale,view:a.view}))b=a.primaryScheme,
c=a.basemapId,d=a.basemapTheme;return{scheme:b,basemapId:c,basemapTheme:d}}function C(a,b){a=F.clone(Q[a]);return u.flatten2DArray(a,b)}function R(a,b){return C(a,b).map(c=>({value:c,count:0}))}function D(a,b,c,d){const {field:e,normalizationField:f}=a,{field:g,normalizationField:k}=b;a=c.map(l=>[l.minValue,l.maxValue]);d=d.map(l=>[l.minValue,l.maxValue]);b=S[a.length];return`\n  var field1 = $feature['${e}'];\n  var field2 = $feature['${g}'];\n  var hasNormField1 = ${f?"true":"false"};\n  var hasNormField2 = ${k?
"true":"false"};\n  var normField1 = ${f?`$feature['${f}']`:"null"};\n  var normField2 = ${k?`$feature['${k}']`:"null"};\n\n  if (\n    IsEmpty(field1) ||\n    IsEmpty(field2) ||\n    (hasNormField1 && (IsEmpty(normField1) || normField1 == 0)) ||\n    (hasNormField2 && (IsEmpty(normField2) || normField2 == 0))\n  ) {\n    return null;\n  }\n\n  var value1 = IIf(hasNormField1, (field1 / normField1), field1);\n  var value2 = IIf(hasNormField2, (field2 / normField2), field2);\n\n  var breaks1 = ${JSON.stringify(a)};\n  var breaks2 = ${JSON.stringify(d)};\n  var classCodes = ${JSON.stringify(b)};\n\n  function getClassCode(value, breaks) {\n    var code = null;\n\n    for (var i in breaks) {\n      var info = breaks[i];\n      if (value >= info[0] && value <= info[1]) {\n        code = classCodes[i];\n        break;\n      }\n    }\n\n    return code;\n  }\n\n  var code1 = getClassCode(value1, breaks1);\n  var code2 = getClassCode(value2, breaks2);\n\n  var classValue = IIf(IsEmpty(code1) || IsEmpty(code2), null, code1 + code2);\n  return classValue;\n  `}
async function T(a,b,c){var d=await G.fetchMessageBundle("esri/smartMapping/t9n/smartMapping");const {basemap:e,classificationMethod:f,field1:g,field2:k,focus:l,numClasses:m,signal:p}=a;var n=a.layer,q=b.classBreakInfos;const x=c.classBreakInfos;if(m!==q.length||q.length!==x.length)throw new h("relationship-renderer:error","incompatible class breaks");var y=R(m,l);const U=D(a.field1,a.field2,q,x),z=(await P({basemap:e,geometryType:n.geometryType,theme:"default",relationshipScheme:a.relationshipScheme,
worldScale:!!a.symbolType?.includes("3d-volumetric"),view:a.view})).scheme;a=await I.createRenderer({layer:n,basemap:e,valueExpression:U,valueExpressionTitle:d.relationship.legendTitle,numTypes:-1,sortEnabled:!1,defaultSymbolEnabled:a.defaultSymbolEnabled,typeScheme:{colors:u.getColors(z,m,l),...z},statistics:{uniqueValueInfos:y},legendOptions:a.legendOptions,outlineOptimizationEnabled:a.outlineOptimizationEnabled,sizeOptimizationEnabled:a.sizeOptimizationEnabled,symbolType:a.symbolType,colorMixMode:a.colorMixMode,
edgesType:a.edgesType,view:a.view,signal:p});n=a.renderer;y=n.uniqueValueInfos;d=d.relationship;for(const E of y??[])E.label=d[E.value];q=new H({type:"relationship",classificationMethod:f,numClasses:m,focus:l,field1:{field:g.field,normalizationField:g.normalizationField,label:g.label,classBreakInfos:q.map(v)},field2:{field:k.field,normalizationField:k.normalizationField,label:k.label,classBreakInfos:x.map(v)}});n.authoringInfo=q;return{renderer:n,classBreaks:{field1:b,field2:c},uniqueValueInfos:a.uniqueValueInfos,
relationshipScheme:z,basemapId:a.basemapId,basemapTheme:a.basemapTheme}}function V(a,b,c){const d=C(b,c);a.sort((e,f)=>{e=d.indexOf(e.value);f=d.indexOf(f.value);let g=0;e<f?g=-1:e>f&&(g=1);return g})}function W(a,b){const c=a.authoringInfo;c.numClasses=b.numClasses;c.focus=b.focus||null;c.focus||delete c.focus;const {field1:d,field2:e}=b;c.field1=new B.AuthoringInfoFieldInfo({field:d.field,normalizationField:d.normalizationField,label:d.label,classBreakInfos:d.classBreakInfos.map(f=>new A.AuthoringInfoClassBreakInfo(v(f)))});
c.field2=new B.AuthoringInfoFieldInfo({field:e.field,normalizationField:e.normalizationField,label:e.label,classBreakInfos:e.classBreakInfos.map(f=>new A.AuthoringInfoClassBreakInfo(v(f)))});a.authoringInfo=c}const M=new Set(["equal-interval","natural-breaks","quantile"]),N=new Set(["HH","HL","LH","LL"]),Q={2:[["HL","HH"],["LL","LH"]],3:[["HL","HM","HH"],["ML","MM","MH"],["LL","LM","LH"]],4:[["HL","HM1","HM2","HH"],["M2L","M2M1","M2M2","M2H"],["M1L","M1M1","M1M2","M1H"],["LL","LM1","LM2","LH"]]},
S={2:["L","H"],3:["L","M","H"],4:["L","M1","M2","H"]},v=a=>({minValue:a.minValue,maxValue:a.maxValue});w.createRenderer=async function(a){a=await L(a);const {layer:b,classificationMethod:c,field1:d,field2:e,numClasses:f,view:g,signal:k}=a,l={layer:b,classificationMethod:c,field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationField?"field":null,minValue:e.minValue,maxValue:e.maxValue,analyzeData:!(null!=e.minValue&&null!=e.maxValue),numClasses:f,view:g,signal:k},[m,
p]=await Promise.all([r.getClassBreaks({layer:b,classificationMethod:c,field:d.field,normalizationField:d.normalizationField,normalizationType:d.normalizationField?"field":null,minValue:d.minValue,maxValue:d.maxValue,analyzeData:!(null!=d.minValue&&null!=d.maxValue),numClasses:f,view:g,signal:k}),r.getClassBreaks(l)]);if(!m||!p)throw new h("relationship-renderer:error","error when calculating class breaks");return T(a,m.result,p.result)};w.updateRenderer=async function(a){a=await O(a);const {field1:b,
field2:c,renderer:d,numClasses:e,focus:f,colors:g}=a,k=d.clone();k.valueExpression=D(b,c,b.classBreakInfos,c.classBreakInfos);const l=k.uniqueValueInfos??[];V(l,e,f);if(g){const m=r.createColors(g,g.length);l.forEach((p,n)=>K.applyColorToSymbol(p.symbol,m[n]))}W(k,a);return k};Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});