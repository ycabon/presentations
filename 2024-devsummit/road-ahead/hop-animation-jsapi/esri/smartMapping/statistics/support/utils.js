// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/Error ../../../core/screenUtils ../../../core/timeUtils ../../../geometry/SpatialReference ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/fieldUtils ../../../renderers/support/heatmapUtils ../../support/utils ../../../statistics/utils ../../../support/arcadeOnDemand ../../../geometry/Point".split(" "),function(n,U,w,L,C,M,N,G,D,H,O,z,P,Q){function I(a){a=R.exec(a);if(!a)return null;
const {hh:b,mm:c,ss:d,ms:f}=a.groups;return Number(b)*C.millisecondsPerTimeUnit.hours+Number(c)*C.millisecondsPerTimeUnit.minutes+Number(d)*C.millisecondsPerTimeUnit.seconds+Number(f||0)}function J(a,b){a=null!=a?a:"";null!=b&&b&&(a=a?"("+a+") AND ("+b+")":b);return a}function S(a){const b=a.layer;return a.fields.filter(c=>!b.getField(c))}function T(a){const b=a.layer;return a.fields.filter(c=>{c=b.getFieldUsageInfo(c);return!c||!c.supportsStatistics})}let u=null;const R=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;
n.calculateHeatmapStats=function(a,b=18,c,d,f){const q=new Float64Array(d*f);b=Math.round(L.pt2px(b));let p=Number.POSITIVE_INFINITY,g=Number.NEGATIVE_INFINITY;c=H.createValueFunction(c);for(const {geometry:r,attributes:m}of a){const {x:l,y:t}=r;a=Math.max(0,l-b);var k=Math.max(0,t-b);const E=Math.min(f,t+b),F=Math.min(d,l+b),A=+c(m);for(;k<E;k++)for(let x=a;x<F;x++){var e=k*d+x;const B=H.evaluateDensityKernel(x-l,k-t,b)*A;e=q[e]+=B;p=Math.min(p,e);g=Math.max(g,e)}}return{min:p,max:g}};n.getDataValues=
async function(a,b,c=!0){if(!b)return[];const {field:d,field2:f,field3:q,fieldDelimiter:p,fieldInfos:g,timeZone:k}=a;var e=d&&g?.find(y=>y.name.toLowerCase()===d.toLowerCase());const r=e?D.isTimeOnlyField(e):!1,m=e?O.isAnyDateField(e):!1,l=a.valueExpression,t=a.normalizationType,E=a.normalizationField,F=a.normalizationTotal,A=[];e=a.viewInfoParams;let x=null,B=null;if(l){if(!u){const {arcadeUtils:y}=await P.loadArcade();u=y}u.hasGeometryOperations(l)&&await u.enableGeometryOperations();x=u.createFunction(l);
B=e?u.getViewInfo({viewingMode:e.viewingMode,scale:e.scale,spatialReference:new M(e.spatialReference)}):null}a=a.fieldInfos;const K=b[0]&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass||!a?null:{fields:a};b.forEach(y=>{var v=y.attributes;if(l){var h=u.createExecContext(K?{...y,layer:K}:y,B,k);h=u.executeFunction(x,h)}else v&&(h=v[d],f?(h=`${z.processNullValue(h)}${p}${z.processNullValue(v[f])}`,q&&(h=`${h}${p}${z.processNullValue(v[q])}`)):"string"===typeof h&&c&&(m?h=h?(new Date(h)).getTime():
null:r&&(h=h?I(h):null)));t&&"number"===typeof h&&isFinite(h)&&(v=v&&parseFloat(v[E]),h=z.getNormalizedValue(h,t,v,F));A.push(h)});return A};n.getRangeExpr=function(a,b,c){b=null!=b?a+" \x3e\x3d "+b:"";a=null!=c?a+" \x3c\x3d "+c:"";c="";return(c=b&&a?J(b,a):b||a)?"("+c+")":""};n.getSQLFilterForNormalization=function(a){const b=a.field,c=a.normalizationType;a=a.normalizationField;let d;if("field"===c)d="(NOT "+a+" \x3d 0)";else if("log"===c||"natural-log"===c||"square-root"===c)d=`(${b} > 0)`;return d};
n.getSumOfAttributesExpr=function(a,b,c){const d=[],f=[],q=[],p=[],g=[];a.forEach((r,m)=>{const l=r.field?"field":"expression",t=r.field||r.valueExpression;r.field?(g.push(t),f.push(`var ${l}${m} = Number($feature["${t}"]);`)):(d.push(`function getValueForExpr${m}() {\n  ${t} \n}`),f.push(`var ${l}${m} = Number(getValueForExpr${m}());`));c||q.push(`${l}${m} = IIf(${l}${m} < 0, 0, ${l}${m});`);p.push(`${l}${m}`)});a="return sum;";const k=d.length?null:g.reduce((r,m)=>`${r} + ${m}`);let e=null;b||c?
b?c||(a="return IIf(sum \x3e\x3d 0, sum, null);",k&&(e=`(( ${k} ) >= 0)`)):(a="return IIf(sum !\x3d 0, sum, null);",k&&(e=`(( ${k} ) <> 0)`)):(a="return IIf(sum \x3e 0, sum, null);",k&&(e=`(( ${k} ) > 0)`));return{valueExpression:[d.length?d.join("\n"):"",f.join("\n"),q.join("\n"),`var sum = ${p.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:k,sqlWhere:e}};n.mergeWhereClauses=J;n.quantizeFeatures=function(a,b,c,d){const f=G.isWrappable(c)?G.getInfo(c):null,q=f?Math.round((f.valid[1]-
f.valid[0])/b.scale[0]):null;return a.map(p=>{const g=new Q(p.geometry);N.quantizePoint(b,g,g,g.hasZ,g.hasM);if(f){var k=q??0,e=d[0];0>g.x?g.x+=k:g.x>e&&(g.x-=k)}p.geometry=g;return p})};n.timeOnlyToMilliseconds=I;n.verifyBasicFieldValidity=function(a,b,c){const d=S({layer:a,fields:b});if(d.length)return new w(c,"Unknown fields: "+d.join(", ")+". You can only use fields defined in the layer schema");a=T({layer:a,fields:b});if(a.length)return new w(c,"Unsupported fields: "+a.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true")};
n.verifyFieldType=function(a,b,c,d){let f;b?b.name!==a.objectIdField&&d.includes(b.type)||(f=new w(c,"'field' should be one of these types: "+d.join(","))):f=new w(c,"'field' is not defined in the layer schema");return f};n.verifyFilterValidty=function(a,b){if(a&&"intersects"!==a.spatialRelationship)return new w(b,"Only 'intersects' spatialRelationship is supported for featureFilter")};n.verifyNumericField=function(a,b,c){let d;b?b.name!==a.objectIdField&&D.isNumericField(b)||(d=new w(c,"'field' should be one of these numeric types: "+
D.numericTypes.join(","))):d=new w(c,"'field' is not defined in the layer schema");return d};Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});