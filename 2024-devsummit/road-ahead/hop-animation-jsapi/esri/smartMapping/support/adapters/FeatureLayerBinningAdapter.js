// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/promiseUtils ../../../core/Logger ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../statistics/support/predominanceUtils ../../statistics/support/statsWorker ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./support/utils".split(" "),function(B,C,n,D,x,K,E,F,z,G,
t,H,I,v,J,p){x=class extends J{constructor(){super(...arguments);this.adapterName="feature-layer-binning-adapter"}async _getNormalizationTotalFromMemory(a,c,b){const {featuresJSON:e,graphics:l,layerView:g,query:k}=c;a=(!e&&!l&&g&&"queryAggregateSummaryStatistics"in g?await g.queryAggregateSummaryStatistics(k,{field:a},{signal:b}):e?await this.workerClient.summaryStatistics({field:a},e):await t.summaryStatistics({attribute:{field:a},features:l})).sum;if(null==a)throw new n(`${this.adapterName}:invalid`,
"invalid normalizationTotal");return a}async _processStatsFromMemoryParams(a){const {features:c,filter:b}=a;if(c?.length)return this._getFilteredFeatures(c,b);const {view:e,field:l,field2:g,field3:k,normalizationField:d,valueExpression:h,returnGeometry:m,layerViewFunc:f,signal:r}=a;let q=a=null,u=null,y=null,A=null;if(e)try{if(a=await e.whenLayerView(this.layer),q=null!=f&&f in a&&"function"===typeof a[f]){await this._waitForLayerViewUpdate(a);const w=await v.getFieldsList({field:l,field2:g,field3:k,
normalizationField:d,valueExpression:h});p.getMissingFieldsForBinning(this,w).length?q=!1:(u="createAggregateQuery"in a?a.createAggregateQuery():null)?(u.outFields=w,u.returnGeometry=!1,p.updateQueryWithFeatureFilter(u,b)):q=!1;a.suspended&&(q=!1)}}catch{q=!1}if(!q&&(A=p.getFeatureReductionFields(this.layer).map(w=>w.toJSON()),y=await this._fetchFeaturesForStats({field:l,field2:g,field3:k,valueExpression:h,normalizationField:d,returnGeometry:m,filter:b,view:e,signal:r},"json"),!y?.length))throw new n(`${this.adapterName}:insufficient-data`,
"No features are available to calculate statistics");return{layerView:a,query:u,featuresJSON:y,fieldInfos:A}}async _summaryStatsFromMemory(a,c){const {view:b,field:e,valueExpression:l,normalizationType:g,signal:k}=a,d={field:e,valueExpression:l,normalizationType:g,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue},{featuresJSON:h,graphics:m,layerView:f,query:r,fieldInfos:q}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateSummaryStatistics"});
l&&b&&(h||m)&&(d.fieldType=c?.type?F.kebabDict.toJSON(c.type):null,d.viewInfoParams=p.getViewInfoParams(b),d.timeZone=b.timeZone,d.fieldInfos=q);"percent-of-total"===g&&null==a.normalizationTotal&&(d.normalizationTotal=await this._getNormalizationTotalFromMemory(e,{featuresJSON:h,graphics:m,layerView:f,query:r},k));return!h&&!m&&f&&"queryAggregateSummaryStatistics"in f?f.queryAggregateSummaryStatistics(r,d,{signal:k}):h?this.workerClient.summaryStatistics(d,h):t.summaryStatistics({attribute:d,features:m})}async _uvFromMemory(a,
c){const {view:b,field:e,valueExpression:l,returnAllCodedValues:g,signal:k}=a,{featuresJSON:d,graphics:h,layerView:m,query:f,fieldInfos:r}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateUniqueValues"});a={field:e,field2:a.field2,field3:a.field3,fieldDelimiter:v.fieldDelimiter,valueExpression:l,domains:c,returnAllCodedValues:g};l&&b&&(d||h)&&(a.viewInfoParams=p.getViewInfoParams(b),a.timeZone=b.timeZone,a.fieldInfos=r);return!d&&!h&&m&&"queryAggregateUniqueValues"in m?
m.queryAggregateUniqueValues(f,a,{signal:k}):d?this.workerClient.uniqueValues(a,d):t.uniqueValues({attribute:a,features:h})}async _histogramFromMemory(a){const {view:c,field:b,valueExpression:e,signal:l}=a,{featuresJSON:g,graphics:k,layerView:d,query:h,fieldInfos:m}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateHistogram"}),f={field:b,valueExpression:e,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,
minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};e&&c&&(g||k)&&(f.viewInfoParams=p.getViewInfoParams(c),f.timeZone=c.timeZone,f.fieldInfos=m);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(f.normalizationTotal=await this._getNormalizationTotalFromMemory(b,{featuresJSON:g,graphics:k,layerView:d,query:h},l));return!g&&!k&&d&&"queryAggregateHistogram"in d?d.queryAggregateHistogram(h,
f,{signal:l}):g?this.workerClient.histogram(f,g):t.histogram({attribute:f,features:k})}async _classBreaksFromMemory(a){const {view:c,field:b,valueExpression:e,signal:l}=a,{featuresJSON:g,graphics:k,layerView:d,query:h,fieldInfos:m}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateClassBreaks"}),f={field:b,valueExpression:e,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,
standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numClasses:a.numClasses};e&&c&&(g||k)&&(f.viewInfoParams=p.getViewInfoParams(c),f.timeZone=c.timeZone,f.fieldInfos=m);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(f.normalizationTotal=await this._getNormalizationTotalFromMemory(b,{featuresJSON:g,graphics:k,layerView:d,query:h},l));return!g&&!k&&d&&"queryAggregateClassBreaks"in d?d.queryAggregateClassBreaks(h,f,{signal:l}):g?
this.workerClient.classBreaks(f,g):t.classBreaks({attribute:f,features:k})}getField(a=""){return p.getFeatureReductionFields(this.layer)?.find(c=>c.name.toLowerCase()===a?.toLowerCase())}getFieldUsageInfo(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(a,c){return null}async summaryStatistics(a){var {field:c}=a;const b=c?this.getField(c):null,e=v.isAnyDateField(b)||z.isTimeOnlyField(b);
c=a.sqlExpression&&!a.valueExpression&&!c;if(e||c)throw new n(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(a,b)}async uniqueValues(a){const c=await p.getDomainsForFields(a,this);return this._uvFromMemory(a,c)}async histogram(a){var {field:c}=a,b=c?this.getField(c):null;b=v.isAnyDateField(b)||z.isTimeOnlyField(b);c=a.sqlExpression&&!a.valueExpression&&!c;if(b||c)throw new n(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");
return this._histogramFromMemory(a)}async classBreaks(a){return(!1!==a.analyzeData?this._classBreaksFromMemory(a):this._classBreaksFromInterpolation(a)).catch(()=>{D.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})}async queryFeatureCount(a){const c=await a.view?.whenLayerView(this.layer);if(!(c&&"queryAggregateCount"in c&&c.queryAggregateCount))throw new n(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(c);const b=c.createAggregateQuery();
b.where=H.mergeWhereClauses(b.where,a.whereClause);p.updateQueryWithFeatureFilter(b,a.filter);return c.queryAggregateCount(b,{signal:a.signal})}generateRenderer(a,c){throw new n(`${this.adapterName}:not-supported`,"'generateRenderer' is not supported.");}heatmapStatistics(a){throw new n(`${this.adapterName}:not-supported`,"'heatmapStatistics' is not supported.");}async predominantCategories(a){const {fields:c,view:b,signal:e}=a;a=G.getArcadeForPredominantCategory(c);a=await this._uvFromMemory({valueExpression:a,
view:b,signal:e});return p.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,c)}async getSampleFeatures(a,c){const {view:b,sampleSize:e,requiredFields:l,returnGeometry:g,filter:k,signal:d}=a;if(!b)throw new n(`${this.adapterName}:not-supported`,"'view' is required to get sample features for binning.");if("3d"===b.type)throw new n(`${this.adapterName}:not-supported`,"3d 'view' is not supported to get sample features for binning.");a=await b.whenLayerView(this.layer);if(!("queryAggregateJSON"in
a&&a.queryAggregateJSON&&"queryAggregates"in a&&a.queryAggregates))throw new n(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(a);if(p.getMissingFieldsForBinning(this,l).length)throw new n(`${this.adapterName}:insufficient-data`,"Layer does not have required fields");c="json"===c;const h=a.createAggregateQuery();h.outSpatialReference=b?.spatialReference;h.returnGeometry=!!g;h.outFields=l;p.updateQueryWithFeatureFilter(h,k);({features:a}=c?await a.queryAggregateJSON(h,
{signal:d}):await a.queryAggregates(h,{signal:d}));return a.length&&null!=e&&0<e&&e<=a.length?C.pickRandom(a,e,1):a}load(a){const c=this.layer.load(a).then(async b=>{this.geometryType="polygon";this.objectIdField=null;this._hasLocalSource=this.supportsSQLExpression=!1;this.hasQueryEngine=!0;this.minScale=b.minScale;this.maxScale=b.maxScale;this.fullExtent=b.fullExtent;if("geometryType"in b&&"point"!==b.geometryType)throw new n(`${this.adapterName}:invalid-parameters`,"Only 'point' geometry type is supported");
b="featureReduction"in b?b.featureReduction:null;if("binning"!==b?.type&&"cluster"!==b?.type)throw new n(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${b?.type} is not supported`);this.workerClient=I.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(c);return Promise.resolve(this)}};return x=B.__decorate([E.subclass("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],x)});