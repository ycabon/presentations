// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("require ../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../geometry/support/quantizationUtils ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../../rest/support/QuantizationParameters ../../statistics/support/predominanceUtils ../../statistics/support/statsWorker ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./LayerAdapter ./support/utils ../../../statistics/utils ../../../support/arcadeOnDemand".split(" "),
function(E,A,F,p,G,H,I,B,J,w,K,L,M,N,O,P,u,Q,R,t,S,m,z,T){let x=null;w=class extends S{constructor(){super(...arguments);this._hasLocalSource=!1;this.adapterName="in-memory-layer-adapter"}destroy(){this.workerClient?.destroy()}async _waitForLayerViewUpdate(a){if(!a)throw new p(`${this.adapterName}:insufficient-data", "layerView is required to fetch the features`);const b=new AbortController,c=B.whenOnce(()=>!a.updating,b.signal);await I.timeout(c,5E3,b).catch(d=>{G.getLogger(this).warn("LayerView is taking too long to update. Aborting fetch from layerView.");
throw d;})}async _fetchFeatureSetFromMemory(a,b,c){const d=this.layer;if(this._hasLocalSource&&"queryFeatures"in d)return d.queryFeatures(a);if(!b)throw new p(`${this.adapterName}:insufficient-data`,"view is required to fetch the features from layerView");b=await b.whenLayerView(this.layer);await this._waitForLayerViewUpdate(b);return b.queryFeatures(a,{signal:c})}async _fetchFeaturesFromMemory(a,b,c,d){const e=this.layer;d="json"===d;if(this._hasLocalSource&&"queryFeatures"in e)return a=await e.queryFeatures(b),
d?m.ensureFeaturesJSON(a.features):a.features;await this._waitForLayerViewUpdate(a);if(d&&"queryFeaturesJSON"in a&&a.queryFeaturesJSON)return{features:d}=await a.queryFeaturesJSON(b,{signal:c}),d;if(!("queryFeatures"in a))throw new p(`${this.adapterName}:not-supported`,"'queryFeatures' is not supported on the layerView");a=await a.queryFeatures(b,{signal:c});return d?m.ensureFeaturesJSON(a.features):a.features}_fetchFeaturesForStats(a,b){return t.getFieldsList({field:a.field,field2:a.field2,field3:a.field3,
normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(c=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,filter:a.filter,requiredFields:c,signal:a.signal},b))}async _summaryStatsFromClientQuery(a,b){const {view:c,signal:d}=a;a=m.getSummaryStatsQuery(this,a,b);a=await this._fetchFeatureSetFromMemory(a,c,d);b=m.getSummaryStatisticsFromFeatureSet(a,t.isAnyDateField(b)||N.isTimeOnlyField(b));return z.processSummaryStatisticsResult(b)}async _getNormalizationTotalFromMemory(a,
b,c){const {featuresJSON:d,graphics:e,layerView:f,query:h}=b;a=(!d&&!e&&f&&"querySummaryStatistics"in f?await f.querySummaryStatistics(h,{field:a},{signal:c}):d?await this.workerClient.summaryStatistics({field:a},d):await u.summaryStatistics({attribute:{field:a},features:e??[]})).sum;if(null==a)throw new p(`${this.adapterName}:invalid`,"invalid normalizationTotal");return a}async _summaryStatsFromMemory(a,b){const {view:c,field:d,valueExpression:e,normalizationType:f,signal:h}=a,g={field:d,valueExpression:e,
normalizationType:f,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue},{featuresJSON:k,graphics:n,layerView:l,query:q,fieldInfos:r}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"querySummaryStatistics"});e&&c&&(k||n)&&(g.fieldType=b?.type?M.kebabDict.toJSON(b.type):null,g.viewInfoParams=m.getViewInfoParams(c),g.timeZone=c.timeZone,g.fieldInfos=r);"percent-of-total"===f&&null==a.normalizationTotal&&(g.normalizationTotal=
await this._getNormalizationTotalFromMemory(d,{featuresJSON:k,graphics:n,layerView:l,query:q},h));return!k&&!n&&l&&"querySummaryStatistics"in l?l.querySummaryStatistics(q,g,{signal:h}):k?this.workerClient.summaryStatistics(g,k):u.summaryStatistics({attribute:g,features:n})}async _getFilteredFeatures(a,b){let c=[];if("intersects"===b?.spatialRelationship){const {intersect:d}=await new Promise((e,f)=>E(["../../../geometry/geometryEngineAsync"],e,f));b=null!=b.geometry?b.geometry:null;for(const e of a){const f=
null!=e.geometry?e.geometry:null;f&&b&&await d(f,b)&&c.push(e)}}else c=a;return a.length&&"declaredClass"in a[0]&&"esri.Graphic"===a[0].declaredClass?{graphics:c}:{featuresJSON:c}}async _processStatsFromMemoryParams(a){const {features:b,filter:c}=a;if(b?.length)return this._getFilteredFeatures(b,c);const {view:d,field:e,field2:f,field3:h,normalizationField:g,valueExpression:k,layerViewFunc:n,signal:l}=a;a=a.returnGeometry;null==a&&k&&(x||({arcadeUtils:a}=await T.loadArcade(),x=a),(a=x.hasGeometryOperations(k))&&
await x.enableGeometryOperations());let q=null,r=null,v=null,C=null,D=null;if(d)try{q=await d.whenLayerView(this.layer),r=null!=n&&n in q&&"function"===typeof q[n]}catch{r=!1}if(r)try{await this._waitForLayerViewUpdate(q);const y=await t.getFieldsList({field:e,field2:f,field3:h,normalizationField:g,valueExpression:k});m.getMissingFields(this,y,q).length?r=!1:(v=this.layer.createQuery(),v.outFields=y,v.returnGeometry=!1,m.updateQueryWithFeatureFilter(v,c));q.suspended&&(r=!1)}catch{r=!1}r||(C=await this._fetchFeaturesForStats({field:e,
field2:f,field3:h,valueExpression:k,normalizationField:g,returnGeometry:a,filter:c,view:d,signal:l},"json"),D=(await t.getFieldsList({valueExpression:k})).map(y=>this.getField(y)?.toJSON()).filter(Boolean));return{layerView:q,query:v,featuresJSON:C,fieldInfos:D}}async _uvFromClientQuery(a,b){const {view:c,signal:d}=a;var e=m.getUVQuery(this,a);e=await this._fetchFeatureSetFromMemory(e,c,d);e=await m.getUniqueValuesFromFeatureSet(e,{layer:this,field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:t.fieldDelimiter,
view:a.view,signal:a.signal});return z.createUVResult(e,b,a.returnAllCodedValues,t.fieldDelimiter)}async _uvFromMemory(a,b){const {view:c,field:d,valueExpression:e,returnAllCodedValues:f,signal:h}=a,{featuresJSON:g,graphics:k,layerView:n,query:l,fieldInfos:q}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryUniqueValues"});a={field:d,field2:a.field2,field3:a.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:e,domains:b,returnAllCodedValues:f};e&&c&&(g||k)&&(a.viewInfoParams=
m.getViewInfoParams(c),a.timeZone=c.timeZone,a.fieldInfos=q);return!g&&!k&&n&&"queryUniqueValues"in n?n.queryUniqueValues(l,a,{signal:h}):g?this.workerClient.uniqueValues(a,g):u.uniqueValues({attribute:a,features:k})}_histogramForField(a){let b=null;b=null!=a.minValue&&null!=a.maxValue?Promise.resolve({min:a.minValue,max:a.maxValue}):this.summaryStatistics(a).then(c=>{if(!c.count)throw new p(`${this.adapterName}:insufficient-data`,"Either the layer has no features or none of the features have data for the field");
return{min:c.min,max:c.max}});return b.then(c=>m.getBins(this,{min:c.min,max:c.max},a.field,a.numBins??void 0,a.view,a.filter,a.signal))}async _histogramFromMemory(a){const {view:b,field:c,valueExpression:d,signal:e}=a,{featuresJSON:f,graphics:h,layerView:g,query:k,fieldInfos:n}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryHistogram"}),l={field:c,valueExpression:d,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,
minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};d&&b&&(f||h)&&(l.viewInfoParams=m.getViewInfoParams(b),l.timeZone=b.timeZone,l.fieldInfos=n);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(l.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:f,graphics:h,layerView:g,query:k},e));return!f&&!h&&g&&"queryHistogram"in g?g.queryHistogram(k,l,{signal:e}):
f?this.workerClient.histogram(l,f):u.histogram({attribute:l,features:h})}_classBreaksFromInterpolation(a){const {minValue:b,maxValue:c}=a,d=a.numClasses||5,e=[],f=(c-b)/d;for(let h=0;h<d;h++){const g=b+h*f;e.push({minValue:g,maxValue:g+f})}e[d-1].maxValue=c;a=z.resolveCBResult({classBreaks:e,normalizationTotal:a.normalizationTotal},a.classificationMethod);return Promise.resolve(a)}async _classBreaksFromMemory(a){const {view:b,field:c,valueExpression:d,signal:e}=a,{featuresJSON:f,graphics:h,layerView:g,
query:k,fieldInfos:n}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryClassBreaks"}),l={field:c,valueExpression:d,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numClasses:a.numClasses};d&&b&&(f||h)&&(l.viewInfoParams=m.getViewInfoParams(b),l.timeZone=b.timeZone,l.fieldInfos=
n);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(l.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:f,graphics:h,layerView:g,query:k},e));return!f&&!h&&g&&"queryClassBreaks"in g?g.queryClassBreaks(k,l,{signal:e}):f?this.workerClient.classBreaks(l,f):u.classBreaks({attribute:l,features:h})}async _heatmapStatsFromMemory(a){const {view:b,field:c,radius:d}=a;H.assertIsSome(b,"InMemoryLayerAdapter: must have a view");const e=await b.whenLayerView(this.layer);
if("queryHeatmapStatistics"in e&&!e.updating)return e.queryHeatmapStatistics({field:a.field,radius:a.radius});const {featuresJSON:f,graphics:h}=await this._processStatsFromMemoryParams({...a,returnGeometry:!0});a=new O({extent:b.extent,tolerance:"2d"===b.type?b.state.resolution:b.pixelSizeAt?.(b.center)});a={field:c,radius:d,transform:L.toQuantizationTransform(a),spatialReference:b.spatialReference?.toJSON(),size:b.size};return f?.length||h?.length?f?this.workerClient.heatmapStatistics(a,f):u.heatmapStatistics({attribute:a,
features:h}):{min:null,max:null}}getField(a=""){return this.layer.getField(a)}getFieldUsageInfo(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(a,b){return this.layer.getFieldDomain(a,b)}createQuery(){return this.layer.createQuery()}async summaryStatistics(a){const {field:b,valueExpression:c,sqlExpression:d,features:e,view:f}=a,h=b?this.getField(b):null,g=!!c,k="3d"===f?.type;if(!c&&d&&
!this.supportsSQLExpression)throw new p(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return g||e||k?this._summaryStatsFromMemory(a,h):this._summaryStatsFromClientQuery(a,h)}async uniqueValues(a){const {valueExpression:b,sqlExpression:c,features:d,view:e}=a,f=await m.getDomainsForFields(a,this),h=!!b,g="3d"===e?.type;if(!b&&c&&!this.supportsSQLExpression)throw new p(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");
return h||d||g?this._uvFromMemory(a,f):this._uvFromClientQuery(a,f)}async histogram(a){const {features:b,valueExpression:c,normalizationType:d,sqlExpression:e}=a,f=b||!!c;if(!c&&e&&!this.supportsSQLExpression)throw new p(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return f||d?this._histogramFromMemory(a):this._histogramForField(a)}async classBreaks(a){return!1!==a.analyzeData?this._classBreaksFromMemory(a):this._classBreaksFromInterpolation(a)}async queryFeatureCount(a){const {whereClause:b,
view:c,signal:d}=a;if(!c)throw new p(`${this.adapterName}:insufficient-data`,"view is required to fetch the features from layerView");a=this.layer.createQuery();a.where=Q.mergeWhereClauses(a.where,b);const e=await c.whenLayerView(this.layer);await B.whenOnce(()=>!e.updating,d);return e.queryFeatureCount(a,{signal:d})}async generateRenderer(a,b){throw new p(`${this.adapterName}:not-supported`,"Layer does not support generateRenderer operation");}async predominantCategories(a){const {fields:b,view:c,
signal:d}=a;a=P.getArcadeForPredominantCategory(b);a=await this._uvFromMemory({valueExpression:a,view:c,signal:d});return m.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,b)}async heatmapStatistics(a){return this._heatmapStatsFromMemory(a)}async getSampleFeatures(a,b){const {view:c,sampleSize:d,requiredFields:e,returnGeometry:f,filter:h,signal:g}=a;a=this.layer.createQuery();a.outSpatialReference=c?.spatialReference;a.returnGeometry=!!f;a.outFields=e;m.updateQueryWithFeatureFilter(a,h);if(!c)throw new p(`${this.adapterName}:not-supported`,
"view is required to get sample features for Layer");const k=await c.whenLayerView(this.layer);if(m.getMissingFields(this,e,k).length)throw new p(`${this.adapterName}:not-supported`,"Required fields need to be passed in the outFields for Layer");b=await this._fetchFeaturesFromMemory(k,a,g,b);return F.pickRandom(b,null!=d&&0<d&&d<=b.length?d:b.length,1)}load(a){const b=this.layer.load(a).then(async c=>{this.geometryType=c.geometryType;this.objectIdField=c.objectIdField;this.supportsSQLExpression="stream"===
c.type||c.capabilities?.query?.supportsSqlExpression;this.minScale=c.minScale;this.maxScale=c.maxScale;this.fullExtent=c.fullExtent;this._hasLocalSource=!1;this.hasQueryEngine=!0;this.workerClient=R.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(b);return Promise.resolve(this)}};A.__decorate([J.property({constructOnly:!0})],w.prototype,"layer",void 0);return w=A.__decorate([K.subclass("esri.smartMapping.support.adapters.InMemoryLayerAdapter")],w)});