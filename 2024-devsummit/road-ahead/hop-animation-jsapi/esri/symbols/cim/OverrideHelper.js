// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../Color ../../core/colorUtils ../../core/lang ../../support/arcadeOnDemand ./CIMSymbolHelper ./utils ../../views/2d/arcade/callExpressionWithFeature".split(" "),function(p,t,u,q,v,w,l,x){class f{static findApplicableOverrides(a,b,c){if(a&&b){if(a.primitiveName){let e=!1;for(const d of c)if(d.primitiveName===a.primitiveName){e=!0;break}if(!e)for(const d of b)d.primitiveName===a.primitiveName&&c.push(d)}switch(a.type){case "CIMPointSymbol":case "CIMLineSymbol":case "CIMPolygonSymbol":if(a.effects)for(const e of a.effects)f.findApplicableOverrides(e,
b,c);if(a.symbolLayers)for(const e of a.symbolLayers)f.findApplicableOverrides(e,b,c);break;case "CIMSolidStroke":case "CIMPictureStroke":case "CIMGradientStroke":case "CIMSolidFill":case "CIMPictureFill":case "CIMHatchFill":case "CIMGradientFill":case "CIMVectorMarker":case "CIMCharacterMarker":case "CIMPictureMarker":if(a.effects)for(const e of a.effects)f.findApplicableOverrides(e,b,c);a.markerPlacement&&f.findApplicableOverrides(a.markerPlacement,b,c);if("CIMVectorMarker"===a.type){if(a.markerGraphics)for(const e of a.markerGraphics)f.findApplicableOverrides(e,
b,c),f.findApplicableOverrides(e.symbol,b,c)}else"CIMCharacterMarker"===a.type?f.findApplicableOverrides(a.symbol,b,c):"CIMHatchFill"===a.type?f.findApplicableOverrides(a.lineSymbol,b,c):"CIMPictureMarker"===a.type&&f.findApplicableOverrides(a.animatedSymbolProperties,b,c)}}}static findEffectOverrides(a,b){if(!a)return null;if(!b||!a.primitiveName)return{type:"cim-effect-info",effect:a,overrides:[]};const c=a.primitiveName,e=[];for(const d of b)d.primitiveName===c&&e.push({...d,propertyName:l.uncapitalize(d.propertyName)});
return{type:"cim-effect-info",effect:a,overrides:e}}static async resolveSymbolOverrides(a,b,c,e,d,g,m){if(!a?.symbol)return null;let {symbol:k,primitiveOverrides:h}=a;a=!!h;if(!a&&!e)return k;k=q.clone(k);h=q.clone(h);let r=!0;b||(b={attributes:{}},r=!1);a&&(r||(h=h.filter(n=>!n.valueExpressionInfo?.expression.includes("$feature"))),m||(h=h.filter(n=>!n.valueExpressionInfo?.expression.includes("$view"))),0<h.length&&(a=l.attributesToFields(b.attributes),await f.createRenderExpressions(h,{spatialReference:c,
fields:a,geometryType:d}),f.evaluateOverrides(h,b,d??"esriGeometryPoint",g,m)),f.applyOverrides(k,h));e&&f.applyDictionaryTextOverrides(k,b,e);return k}static async createRenderExpressions(a,b){const c=[];for(const e of a){const d=e.valueExpressionInfo;d&&!f._expressionToRenderExpression.has(d.expression)&&(a=v.createRendererExpression(d.expression,b.spatialReference,b.fields),c.push(a),a.then(g=>f._expressionToRenderExpression.set(d.expression,g)))}0<c.length&&await Promise.all(c)}static evaluateOverrides(a,
b,c,e,d){d={$view:{scale:d?.scale}};for(const g of a)if(g.value&&"object"===typeof g.value&&u.isRGB(g.value)&&("Color"===g.propertyName||"StrokeColor"===g.propertyName)&&(g.value=w.rgbaColorToArray(g.value)),a=g.valueExpressionInfo)if(a=f._expressionToRenderExpression.get(a.expression))g.value=x(a,b,d,c,e)}static applyDictionaryTextOverrides(a,b,c,e="Normal"){if(a?.type)switch(a.type){case "CIMPointSymbol":case "CIMLineSymbol":case "CIMPolygonSymbol":case "CIMTextSymbol":var d=a.symbolLayers;if(!d)break;
for(var g of d)g&&"CIMVectorMarker"===g.type&&f.applyDictionaryTextOverrides(g,b,c,"CIMTextSymbol"===a.type?a.textCase:e);break;case "CIMVectorMarker":a=a.markerGraphics;if(!a)break;for(d of a)d&&f.applyDictionaryTextOverrides(d,b,c);break;case "CIMMarkerGraphic":(g=a.textString)&&g.includes("[")&&(c=l.analyzeTextParts(g,c),a.textString=l.assignTextValuesFromFeature(b,c,e))}}static applyOverrides(a,b,c,e){if(a.primitiveName)for(const d of b)if(d.primitiveName===a.primitiveName){const g=l.uncapitalize(d.propertyName);
e&&e.push({cim:a,nocapPropertyName:g,value:a[g]});if(c){let m=!1;for(const k of c)k.primitiveName===a.primitiveName&&(m=!0);m||c.push(d)}null!=d.value&&(a[g]=d.value)}switch(a.type){case "CIMPointSymbol":case "CIMLineSymbol":case "CIMPolygonSymbol":if(a.effects)for(const d of a.effects)f.applyOverrides(d,b,c,e);if(a.symbolLayers)for(const d of a.symbolLayers)f.applyOverrides(d,b,c,e);break;case "CIMSolidStroke":case "CIMSolidFill":case "CIMVectorMarker":if(a.effects)for(const d of a.effects)f.applyOverrides(d,
b,c,e);if("CIMVectorMarker"===a.type&&a.markerGraphics)for(const d of a.markerGraphics)f.applyOverrides(d,b,c,e),f.applyOverrides(d.symbol,b,c,e)}}static restoreOverrides(a){for(const b of a)b.cim[b.nocapPropertyName]=b.value}static buildOverrideKey(a){let b="";for(const c of a)void 0!==c.value&&(b+=`${c.primitiveName}${c.propertyName}${JSON.stringify(c.value)}`);return b}static toValue(a,b){return"DashTemplate"===a?b.split(" ").map(c=>Number(c)):"Color"===a?(a=(new t(b)).toRgba(),a[3]*=255,a):b}}
f._expressionToRenderExpression=new Map;p.OverrideHelper=f;Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});