// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/RandomLCG","../CIMPlacements","../enums"],function(z,B,C,y){class v{static local(){null===v.instance&&(v.instance=new v);return v.instance}execute(d,a,c,e,b){return new u(d,a,c,e,b)}}v.instance=null;class u{constructor(d,a,c,e,b){this._currentY=this._currentX=this._yMax=this._yMin=this._xMax=this._xMin=0;this._accelerationMap=null;this._testInsidePolygon=!1;this._verticalSubdivision=!0;this._stepX=Math.abs(a.stepX??16)*c;this._stepY=Math.abs(a.stepY??16)*c;this._stepX=
Math.round(128*this._stepX)/128;this._stepY=Math.round(128*this._stepY)/128;if(0!==this._stepX&&0!==this._stepY){this._gridType=a.gridType??y.PlacementGridType.Fixed;if(this._gridType===y.PlacementGridType.Random)this._randomLCG=new B(1*(a.seed??13)),this._randomness=(a.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._offsetY=this._offsetX=this._sinAngle=0,this._buildRandomValues();else{this._randomness=0;this._gridAngle=a.gridAngle??0;this._shiftOddRows=a.shiftOddRows??
!1;this._offsetX=(a.offsetX??0)*c;this._offsetY=(a.offsetY??0)*c;this._cosAngle=Math.cos(this._gridAngle/180*Math.PI);this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI);if(this._stepX)if(0>this._offsetX)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(0>this._offsetY)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginY=
this._graphicOriginX=0;if(null!=e){const [k,g,f,p]=e.split("/");a=parseFloat(k);c=parseFloat(g);e=parseFloat(f);this._graphicOriginX=512*-(parseFloat(p)*2**a+e);this._graphicOriginY=512*c;this._testInsidePolygon=!0}this._internalPlacement=new C.Placement;this._calculateMinMax(d);this._geometryCursor=d}}next(){return this._geometryCursor?this._nextInside():null}_buildRandomValues(){if(!u._randValues){u._randValues=[];for(let d=0;24>d;d++)for(let a=0;24>a;a++)u._randValues.push(this._randomLCG.getFloat()),
u._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(d){this._yMax=this._yMin=this._xMax=this._xMin=0;let a,c,e,b,k,g,f,p;a=c=f=k=Number.MAX_VALUE;e=b=p=g=-Number.MAX_VALUE;var q=1!==this._cosAngle;for(d.reset();d.nextPath();)for(;d.nextPoint();){var n=d.x;var l=d.y;var h=n-this._graphicOriginX-this._offsetX;var r=l-this._graphicOriginY-this._offsetY;if(q){var m=this._cosAngle*h-this._sinAngle*r;h=this._sinAngle*h+this._cosAngle*r}else m=h,h=r;a=Math.min(a,m);e=Math.max(e,m);c=Math.min(c,
h);b=Math.max(b,h);k=Math.min(k,l);g=Math.max(g,l);f=Math.min(f,n);p=Math.max(p,n)}k=k!==Number.MAX_VALUE?k:-512-this._stepY;g=g!==-Number.MAX_VALUE?g:this._stepY;f=f!==Number.MAX_VALUE?f:-this._stepX;p=p!==-Number.MAX_VALUE?p:512+this._stepX;this._polygonMin=(this._verticalSubdivision=g-k>=p-f)?k:f;if(this._testInsidePolygon){m=0-this._graphicOriginX-this._offsetX-this._stepX;l=512-this._graphicOriginX-this._offsetX+this._stepX;n=-512-this._graphicOriginY-this._offsetY-this._stepY;h=0-this._graphicOriginY-
this._offsetY+this._stepY;if(q){q=[[m,n],[m,h],[l,n],[l,h]];m=n=Number.MAX_VALUE;l=h=-Number.MAX_VALUE;for(const t of q)q=this._cosAngle*t[0]-this._sinAngle*t[1],r=this._sinAngle*t[0]+this._cosAngle*t[1],m=Math.min(m,q),l=Math.max(l,q),n=Math.min(n,r),h=Math.max(h,r)}a=a!==Number.MAX_VALUE?Math.max(a,m):m;c=c!==Number.MAX_VALUE?Math.max(c,n):n;e=e!==-Number.MAX_VALUE?Math.min(e,l):l;b=b!==-Number.MAX_VALUE?Math.min(b,h):h}this._xMin=Math.round(a/this._stepX);this._xMax=Math.round(e/this._stepX);this._yMin=
Math.round(c/this._stepY);this._yMax=Math.round(b/this._stepY);this._currentX=this._xMax+1;this._currentY=this._yMin-1;this._buildAccelerationMap(d,f,p,k,g)}_buildAccelerationMap(d,a,c,e,b){d.reset();const k=new Map,g=this._verticalSubdivision;c=g?b-e:c-a;b=Math.ceil(c/10);if(!(1>=b)){c=Math.floor(c/b);b++;this._delta=c;var f,p;if(g){b=-512-2*this._stepY;var q=2*this._stepY;var n=e}else b=-2*this._stepX,q=512+2*this._stepX,n=a;for(;d.nextPath();)if(!(2>d.pathSize)&&d.nextPoint()){var l=d.x;for(f=
d.y;d.nextPoint();l=a,f=e){a=d.x;e=d.y;if(g){if(f===e||f<b&&e<b||f>q&&e>q)continue;var h=Math.min(f,e);var r=Math.max(f,e)}else{if(l===a||l<b&&a<b||l>q&&a>q)continue;h=Math.min(l,a);r=Math.max(l,a)}for(;h<r;){var m=p=Math.floor((h-n)/c),t=l,w=f,D=a,E=e,A=k;let x=A.get(m);x||(x=[],A.set(m,x));x.push([[t,w],[D,E]]);h+=c}h=Math.floor((r-n)/c);h>p&&(r=a,m=e,t=k,w=t.get(h),w||(w=[],t.set(h,w)),w.push([[l,f],[r,m]]))}}this._accelerationMap=k}}_nextInside(){for(;;){if(this._currentX>this._xMax){this._currentY++;
if(this._currentY>this._yMax)return null;this._currentX=this._xMin;this._shiftOddRows&&this._currentY%2&&this._currentX--}var d=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(d+=.5*this._stepX);const a=this._currentY*this._stepY+this._offsetY;this._currentX++;let c;if(this._gridType===y.PlacementGridType.Random){const e=(this._currentX%24+24)%24,b=(this._currentY%24+24)%24;c=this._graphicOriginX+d+this._stepX*this._randomness*(.5-u._randValues[24*b+e])*2/3;d=this._graphicOriginY+
a+this._stepY*this._randomness*(.5-u._randValues[24*b+e+1])*2/3}else c=this._graphicOriginX+this._cosAngle*d+this._sinAngle*a,d=this._graphicOriginY-this._sinAngle*d+this._cosAngle*a;if(!this._testInsidePolygon||this._isInsidePolygon(c,d,this._geometryCursor))return this._internalPlacement.setTranslate(c,d),this._internalPlacement}}_isInsidePolygon(d,a,c){if(null==this._accelerationMap){var e=0,b;let f;d+=1E-6;a+=1E-6;for(c.reset();c.nextPath();)if(c.nextPoint()){var k=c.x;for(b=c.y;c.nextPoint();k=
g,b=f){var g=c.x;f=c.y;b>a!==f>a&&(0<(g-k)*(a-b)-(f-b)*(d-k)?e++:e--)}}return 0!==e}d+=1E-6;a+=1E-6;c=this._verticalSubdivision;b=this._accelerationMap.get(Math.floor(((c?a:d)-this._polygonMin)/this._delta));if(!b)return!1;k=0;for(e of b){b=e[0];g=e[1];if(c){if(b[1]>a===g[1]>a)continue;b=(g[0]-b[0])*(a-b[1])-(g[1]-b[1])*(d-b[0])}else{if(b[0]>d===g[0]>d)continue;b=(g[1]-b[1])*(d-b[0])-(g[0]-b[0])*(a-b[1])}0<b?k++:k--}return 0!==k}}z.PlacementInsidePolygon=v;Object.defineProperty(z,Symbol.toStringTag,
{value:"Module"})});