// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../../../core/has ../../../../core/maybe ../brushes ../vectorTiles/shaders/VTLMaterialManager ./BitBlitRenderer ./enums ./MaterialManager ./TextureManager ./TextureUploadManager ./VertexStream ./WorldExtentClipRenderer ./effects/AnimationEffect ./effects/BlendEffect ./effects/FeatureEffect ./effects/HighlightEffect ./effects/HittestEffect ./effects/HittestEffectVTL ./effects/post-processing/EffectManager ./painter/RenderPass ./shaderGraph/techniques/TechniqueProgramCache ../../../webgl/enums ../../../webgl/FramebufferObject ../../../webgl/Renderbuffer ../../../webgl/RenderbufferDescriptor ../../../webgl/TextureDescriptor".split(" "),
function(R,q,t,y,z,p,A,B,C,D,E,F,G,u,H,I,J,K,L,v,e,r,M,N,w){function x(a,c,b,d){return a!==p.WGLDrawPhase.LABEL_ALPHA&&a!==p.WGLDrawPhase.LABEL&&a!==p.WGLDrawPhase.HIGHLIGHT&&(1!==d||null!=c&&"normal"!==c||null!=b&&0<b.length)}class O{constructor(a,c){this.context=a;this._currentPipelineStateNeedsUpdate=!1;this._blitRenderer=new z.BitBlitRenderer;this._worldExtentRenderer=new E.WorldExtentRenderer;this._brushCache=new Map;this._lastHeight=this._lastWidth=null;this._vtlMaterialManager=new y;this._blendEffect=
new G.BlendEffect;this._stencilBuf=null;this._prevBeforeLayerFBOStack=[];this._fboPool=[];this.effects={highlight:new H,hittest:new I.HittestEffect,hittestVTL:new J.HittestEffectVTL,integrate:new F.AnimationEffect,insideEffect:new u.FeatureEffect("inside"),outsideEffect:new u.FeatureEffect("outside")};this._programCache=new v.TechniqueProgramCache;this._shaderState={shader:null,uniforms:null,defines:null,optionalAttributes:null,useComputeBuffer:!1};this.materialManager=new A(a);this.textureManager=
new B(c);this.textureUploadManager=new C.TextureUploadManager(c);this._effectsManager=new K.EffectManager;this._quadMesh=new D(a,[0,0,1,0,0,1,1,1])}dispose(){this._programCache.destroy();this.materialManager.dispose();this.textureManager.dispose();this.textureUploadManager.destroy();this._blitRenderer=q.disposeMaybe(this._blitRenderer);this._worldExtentRenderer=q.disposeMaybe(this._worldExtentRenderer);this._quadMesh.dispose();this._brushCache&&(this._brushCache.forEach(a=>a.dispose()),this._brushCache.clear(),
this._brushCache=null);if(this._fbos){let a;for(a in this._fbos)this._fbos[a]&&this._fbos[a].dispose()}for(const a of this._fboPool)a.dispose();this._fboPool.length=0;if(this.effects){let a;for(a in this.effects)this.effects[a]&&this.effects[a].dispose()}this._effectsManager.dispose();this._blendEffect.dispose(this.context);this._vtlMaterialManager=q.disposeMaybe(this._vtlMaterialManager)}clearShaderCache(){this._programCache.destroy();this._programCache=new v.TechniqueProgramCache}get blitRenderer(){return this._blitRenderer}get vectorTilesMaterialManager(){return this._vtlMaterialManager}getFbos(){if(!this._fbos)throw Error("InternalError: Painter FBOs not initialized");
return this._fbos}acquireFbo(a,c){if(0<this._fboPool.length)var b=this._fboPool.pop();else b=new w.TextureDescriptor(a,c),b.samplingMode=e.TextureSamplingMode.NEAREST,b.wrapMode=e.TextureWrapMode.CLAMP_TO_EDGE,b=new r.FramebufferObject(this.context,b,this._stencilBuf);b.width===a&&b.height===c||b.resize(a,c);return b}releaseFbo(a){this._fboPool.push(a)}getSharedStencilBuffer(){return this._stencilBuf}beforeRenderPhases(a,c,b){const {context:d}=a;this._worldExtentRenderer.render(a,c,b);const {width:f,
height:g}=d.getViewport();this.updateFBOs(f,g);this._prevFBO=d.getBoundFramebufferObject();d.bindFramebuffer(this.getFbos().output);d.setColorMask(!0,!0,!0,!0);if(null!=c){const {r:k,g:l,b:m,a:h}=c;d.setClearColor(h*k/255,h*l/255,h*m/255,h)}else d.setClearColor(0,0,0,0);d.setDepthWriteEnabled(!0);d.setClearDepth(1);d.clear(d.gl.COLOR_BUFFER_BIT|d.gl.DEPTH_BUFFER_BIT);d.setDepthWriteEnabled(!1)}afterRenderPhases(a){({context:a}=a);a.bindFramebuffer(this._prevFBO);a.setStencilFunction(e.CompareFunction.EQUAL,
1,255);a.setStencilTestEnabled(!0);a.setDepthTestEnabled(!1);this.blitTexture(a,this.getFbos().output.colorTexture,e.TextureSamplingMode.NEAREST)}beforeRenderLayer(a,c,b){const {context:d,blendMode:f,effects:g,drawPhase:k,requireFBO:l}=a;if(l||x(k,f,g,b)){a=d.getBoundFramebufferObject();this._prevBeforeLayerFBOStack.push(a);const {width:m,height:h}=d.getViewport();a=this.acquireFbo(m,h);d.bindFramebuffer(a);d.setColorMask(!0,!0,!0,!0);d.setClearColor(0,0,0,0);d.setDepthWriteEnabled(!0);d.setClearDepth(1);
d.clear(d.gl.COLOR_BUFFER_BIT|d.gl.DEPTH_BUFFER_BIT);d.setDepthWriteEnabled(!1)}d.setDepthWriteEnabled(!1);d.setDepthTestEnabled(!1);d.setStencilTestEnabled(!0);d.setClearStencil(c);d.setStencilWriteMask(255);d.clear(d.gl.STENCIL_BUFFER_BIT)}afterRenderLayer(a,c){const {context:b,blendMode:d,effects:f,requireFBO:g,drawPhase:k}=a;if(g||x(k,d,f,c)){const l=b.getBoundFramebufferObject();null!=f&&0<f.length&&k===p.WGLDrawPhase.MAP&&(b.setColorMask(!0,!0,!0,!0),this._applyEffects(a,f,l));b.bindFramebuffer(this._prevBeforeLayerFBOStack.pop());
b.setStencilTestEnabled(!1);b.setStencilWriteMask(0);b.setBlendingEnabled(!0);b.setBlendFunctionSeparate(e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA,e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA);b.setColorMask(!0,!0,!0,!0);this._blendEffect.draw(a,l.colorTexture,e.TextureSamplingMode.NEAREST,null==d||k===p.WGLDrawPhase.HIGHLIGHT?"normal":d,c);this.releaseFbo(l)}}renderObject(a,c,b,d){if(b=t.brushes[b]){var f=this._brushCache.get(b);void 0===f&&(f=new b,this._brushCache.set(b,f));f.prepareState(a);
f.draw(a,c,d)}}renderObjects(a,c,b,d){if(b=t.brushes[b]){var f=this._brushCache.get(b);void 0===f&&(f=new b,this._brushCache.set(b,f));f.drawMany(a,c,d)}}registerRenderPass(a){const c=a.brushes.map(b=>{this._brushCache.has(b)||this._brushCache.set(b,new b);return this._brushCache.get(b)});return new L(c,a)}blitTexture(a,c,b,d=1){a.setBlendingEnabled(!0);a.setBlendFunctionSeparate(e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA,e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA);a.setColorMask(!0,
!0,!0,!0);this._blitRenderer.render(a,c,b,d);this._currentPipelineStateNeedsUpdate=!0}getPostProcessingEffects(a){return this._effectsManager.getPostProcessingEffects(a)}updateFBOs(a,c){if(a!==this._lastWidth||c!==this._lastHeight)if(this._lastWidth=a,this._lastHeight=c,this._fbos)for(var b in this._fbos)this._fbos[b].resize(a,c);else b=new w.TextureDescriptor(a,c),b.samplingMode=e.TextureSamplingMode.NEAREST,b.wrapMode=e.TextureWrapMode.CLAMP_TO_EDGE,a=new N.RenderbufferDescriptor(e.RenderbufferFormat.DEPTH_STENCIL,
a,c),this._stencilBuf=new M.Renderbuffer(this.context,a),this._fbos={output:new r.FramebufferObject(this.context,b,this._stencilBuf),effect0:new r.FramebufferObject(this.context,b,this._stencilBuf)}}_applyEffects(a,c,b){const {context:d}=a;c=this._effectsManager.getPostProcessingEffects(c);for(const {postProcessingEffect:f,effect:g}of c)d.bindFramebuffer(b),f.draw(a,b,g);this._currentPipelineStateNeedsUpdate=!0}setShader(a){this._shaderState.shader=a.shader;this._shaderState.uniforms=a.uniforms;this._shaderState.defines=
a.defines;this._shaderState.optionalAttributes=a.optionalAttributes;this._shaderState.useComputeBuffer=a.useComputeBuffer??!1}setPipelineState(a){a!==this._currentPipelineState&&(this._currentPipelineState=a,this._currentPipelineStateNeedsUpdate=!0)}submitDraw(a,c){var {instance:b}=c;b=b.instanceId;const {shader:d,uniforms:f,defines:g,optionalAttributes:k,useComputeBuffer:l}=this._shaderState;b=c.target.getMesh(b);const m={useComputeBuffer:l,locationInfo:d.locationInfo,computeAttributeMap:d.computeAttributes};
var h=b.getLayout(m);if(null==h)return null;const {primitive:n,count:P,offset:Q}=b.getDrawArgs(e.PrimitiveType.TRIANGLES,c.count,c.start*Uint32Array.BYTES_PER_ELEMENT,l);h=this._programCache.getProgram(d,h,f,g??{},k??{});h.setUniforms(f);h.bind(a);this.updatePipelineState(a);this._updateStencilRef(a,c.target);c=b.getVAO(a,d.locationInfo,m);a.bindVAO(c);a.drawElements(n,P,e.DataType.UNSIGNED_INT,Q);a.bindVAO(null);h.cleanupTemporaryTextures();return{vertexShader:h.vertexShader,fragmentShader:h.fragmentShader}}submitDrawQuad(a){const {shader:c,
uniforms:b,defines:d,optionalAttributes:f}=this._shaderState,g=this._programCache.getProgram(c,this._quadMesh.layout,b,d??{},f??{});g.setUniforms(b);g.bind(a);this.updatePipelineState(a);this._updateStencilRef(a,null);this._quadMesh.draw();a.bindVAO(null);g.cleanupTemporaryTextures()}submitDrawMesh(a,c,b){const {shader:d,uniforms:f,defines:g,optionalAttributes:k}=this._shaderState,l=this._programCache.getProgram(d,c.layout,f,g??{},k??{});l.setUniforms(f);l.bind(a);this.updatePipelineState(a);this._updateStencilRef(a,
null);if(b)for(const m of b)c.bind(a,m),c.draw(a);else for(b=0;b<c.parts.length;b++)c.bind(a,b),c.draw(a);c.unbind(a);l.cleanupTemporaryTextures()}updatePipelineState(a){this._currentPipelineStateNeedsUpdate&&(this._currentPipelineStateNeedsUpdate=!1,this._updatePipelineState(a))}_updatePipelineState(a){if(null==this._currentPipelineState)throw Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");const {color:c,depth:b,stencil:d}=this._currentPipelineState;if(c){const {blendMode:g,
write:k}=c;a.setColorMask(...k);a.setBlendingEnabled(!0);a.setBlendEquation(e.BlendOperation.ADD);switch(g){case "composite":a.setBlendFunctionSeparate(e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA,e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA);break;case "additive":a.setBlendFunctionSeparate(e.BlendFactor.ONE,e.BlendFactor.ONE,e.BlendFactor.ONE,e.BlendFactor.ONE);break;case "custom":var {blendParameters:f}=c;const {dstAlpha:l,dstRGB:m,srcAlpha:h,srcRGB:n}=f;a.setBlendFunctionSeparate(n,
m,h,l);break;case "delete":a.setBlendEquation(e.BlendOperation.REVERSE_SUBTRACT),a.setBlendFunctionSeparate(e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA,e.BlendFactor.ONE,e.BlendFactor.ONE_MINUS_SRC_ALPHA)}}if(b){const {test:g,write:k}=b;k?(a.setDepthWriteEnabled(!0),a.setDepthRange(k.zNear,k.zFar)):a.setDepthWriteEnabled(!1);g?(a.setDepthTestEnabled(!0),a.setDepthFunction(g)):a.setDepthTestEnabled(!1)}else a.setDepthTestEnabled(!1),a.setDepthWriteEnabled(!1);if(d){const {test:g,write:k}=d;
if(g){const {compare:l,mask:m,op:h,ref:n}=g;a.setStencilTestEnabled(!0);"function"!==typeof n&&a.setStencilFunctionSeparate(e.Face.FRONT_AND_BACK,l,n,m);a.setStencilOpSeparate(e.Face.FRONT_AND_BACK,h.fail,h.zFail,h.zPass)}else a.setStencilTestEnabled(!1);k?({mask:f}=k,a.setStencilWriteMask(f)):a.setStencilWriteMask(0)}else a.setStencilTestEnabled(!1),a.setStencilWriteMask(0)}_updateStencilRef(a,c){if(null==this._currentPipelineState)throw Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
var {stencil:b}=this._currentPipelineState;if(b&&({test:b}=b,b)){const {compare:d,mask:f,ref:g}=b;"function"===typeof g&&a.setStencilFunctionSeparate(e.Face.FRONT_AND_BACK,d,g(c),f)}}}return O});