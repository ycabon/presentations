// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/maybe ../number ./Buffer ../shaderGraph/techniques/mesh/dataViewUtils ../shaderGraph/techniques/mesh/utils ../../../../webgl/enums ../../../../webgl/VertexArrayObject".split(" "),function(r,t,v,u,w,x,y,z){class A{constructor(a){this._bufferPool=a;this._computeLayouts=new Map;this._vaos=new Map}destroy(){for(const [,a]of this._vaos)a?.disposeVAOOnly();this._indexBuffer=t.destroyMaybe(this._indexBuffer);this._vertexBuffer=t.destroyMaybe(this._vertexBuffer)}_getVertexAttributeLayout(a){if(!a)return null;
const b=[];for(const c of a.attributes)b.push({name:c.name,type:c.type,count:c.count,divisor:0,normalized:c.normalized??!1,offset:c.offset,stride:a.stride});return{geometry:b}}getLayout(a){if(!this._layout)return null;const {locationInfo:b,useComputeBuffer:c,computeAttributeMap:d}=a;var e=this._layout.attributes.filter(f=>b.locations.has(f.name));if(!c)return{attributes:e,hash:this._layout.hash,stride:this._layout.stride};a=Object.values(d).flat().join("-");if(this._computeLayouts.has(a))return this._computeLayouts.get(a);
const h=this._layout.stride;for(const {name:f,count:n,type:k,normalized:l,offset:m,packPrecisionFactor:p}of this._layout.attributes){const g=d[f];null!=g&&2===g.length&&(e.push({name:g[0],count:n,type:k,normalized:l,offset:m+h,packPrecisionFactor:p}),e.push({name:g[1],count:n,type:k,normalized:l,offset:m+2*h,packPrecisionFactor:p}))}e={attributes:e,stride:h,hash:x.vertexLayoutHash(e)};this._computeLayouts.set(a,e);return e}getDrawArgs(a,b,c,d){return d?{primitive:y.PrimitiveType.POINTS,count:b/3,
offset:c/3}:{primitive:a,count:b,offset:c}}getDebugVertexInfo(a){if(!this._vertexBuffer)return null;const b=this.getLayout(a);if(null==b)return null;const c=b.stride;var d=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize);const e=new DataView(d.slice().buffer);d=d.byteLength/c;a.useComputeBuffer&&(d=this._indexBuffer.fillPointer/3);const h=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let f=0;const n=[];for(let k=0;k<d;k++){a.useComputeBuffer&&(f=h[3*k]*c);const l={};for(const m of b.attributes){let p=
`${m.offset} ${m.name}`,g=w.unpackDataView(e,m,f);if(m.packPrecisionFactor)if(p+=` (precision: ${m.packPrecisionFactor})`,"number"===typeof g)g/=m.packPrecisionFactor;else for(let q=0;q<g.length;q++)g[q]/=m.packPrecisionFactor;l[p]=g}f+=c;n.push(l)}return{vertices:n,layout:b}}_ensure(a,b,c){if(this._vertexBuffer&&this._indexBuffer){if(this._layout?.hash!==a.hash)throw Error("InternalError: Expected vertex layouts to match");this._indexBuffer.ensure(Math.max(b,1E3));this._vertexBuffer.ensure(Math.max(c,
1E3))}else{const d=a.stride/Uint32Array.BYTES_PER_ELEMENT;this._layout=a;this._position=a.attributes.find(e=>"pos"===e.name||"position"===e.name);if(!this._position)throw Error("InternalError: Unable to find position attribute");this._indexBuffer=new u.MappedBuffer("index",Math.max(b,1E3),1,this._bufferPool);this._vertexBuffer=new u.MappedBuffer("vertex",Math.max(c,1E3),d,this._bufferPool)}}append(a){var b=a.layout.stride;this._ensure(a.layout,a.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,a.vertices.byteLength/
b);const {vertices:c,indices:d}=a;a=this._vertexBuffer.insert(c,0,c.byteLength/b,0);b=this._indexBuffer.insert(d,0,d.byteLength/4,a);return{vertexFrom:a,indexFrom:b}}copyRecordFrom(a,b,c,d){const {indexStart:e,indexCount:h,vertexStart:f,vertexCount:n}=b;this._ensure(a._layout,h,n);const k=a._position;var l=k.offset;c=v.i1616to32(c*(k.packPrecisionFactor??1),d*(k.packPrecisionFactor??1));l=this._vertexBuffer.copyFrom(a._vertexBuffer,f,n,c,l);a=this._indexBuffer.copyFrom(a._indexBuffer,e,h,l-f,0);b=
b.clone();b.vertexStart=l;b.indexStart=a;b.overlaps=0;return b}remove(a,b,c,d){this._indexBuffer.free(a,b);this._vertexBuffer.free(c,d)}getVAO(a,b,c){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;const d=c?.useComputeBuffer?1:0;let e=this._vaos.get(d);if(this._vertexBuffer.invalidated||this._indexBuffer.invalidated||c?.useComputeBuffer&&this._indexBuffer.invalidatedComputeBuffer)e?.disposeVAOOnly(),e=null;this._vertexBuffer.upload();this._indexBuffer.upload();
const h=this._indexBuffer.getGPUBuffer(a,1===d),f=this._vertexBuffer.getGPUBuffer(a);e||(e=new z.VertexArrayObject(a,b.locations,this._getVertexAttributeLayout(this.getLayout(c)),{geometry:f},h),this._vaos.set(d,e));return e}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(a){this._vertexBuffer&&
this._vertexBuffer.reshuffle(a.vertex.count,a.vertex.operations);this._indexBuffer&&this._indexBuffer.reshuffle(a.index.count,a.index.operations)}}r.MappedMesh=A;Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});