// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../../../../core/MapUtils ../../../../../../../core/libs/gl-matrix-2/math/mat2d ../../../../../../../core/libs/gl-matrix-2/factories/mat2df32 ../../../alignmentUtils ../../../definitions ../../../DisplayId ../../../collisions/LabelMetric ../../../mesh/templates/segmentUtils ../fill/meshWriterUtils ../text/TextMeshWriter".split(" "),function(t,A,u,v,w,x,B,C,y,z,D){const E=A.memoize(a=>{let c=0;if(0===a)return Infinity;for(;!(a%2);)c++,a/=2;return c});class F extends D.TextMeshWriter{constructor(){super(...arguments);
this.enablePixelBuffering=!1;this._zoomLevel=0}_write(a,c,b,f){this._zoomLevel=f||0;if(null!=b)throw Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(c.geometryType){case "esriGeometryPoint":return b=c.readXForDisplay(),f=c.readYForDisplay(),this._writePoint(a,b,f,c);case "esriGeometryEnvelope":case "esriGeometryPolygon":case "esriGeometryMultipoint":b=c.readCentroidForDisplay();if(!b)break;const [d,e]=b.coords;if(0>d||d>=x.tileSize||0>e||e>=x.tileSize)break;return this._writePoint(a,
d,e,c);case "esriGeometryPolyline":b=c.readLegacyGeometryForDisplay(),this._writeLines(a,c,b)}}_writePoint(a,c,b,f){const d=this._getShaping();if(d){var e=this._getPointReferenceBounds();e||={offsetX:0,offsetY:0,size:0};var g=d.boundsT,m=w.getXAnchorDirection(this.evaluatedMeshParams.horizontalAlignment),n=w.getYAnchorDirection(this.evaluatedMeshParams.verticalAlignment),k=this.evaluatedMeshParams.scaleInfo?.maxScale??0,l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=B.getDisplayIdTexel(f.getDisplayId());
a.metricStart(new C.LabelMetric(h,c,b,m,n,k,l,e));a.metricBoxWrite(g);this._writeGlyphs(a,f.getDisplayId(),c,b,d,0,e);a.metricEnd()}}_getPointReferenceBounds(){if(!this._references)return null;for(const a of this._references){const c=a.getBoundsInfo();if(c)return c}return null}_writeLines(a,c,b){const {repeatLabel:f,scaleInfo:d}=this.evaluatedMeshParams;var e=this.evaluatedMeshParams.repeatLabelDistance||128;const g=this._getShaping();if(g){this._current={out:a,id:c.getDisplayId(),shaping:g,zoomRange:z.getMinMaxZoom(d,
this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0}};a=y.smoothPaths(b.paths,g.bounds.width);c=this._placeSubdivGlyphs.bind(this);e=(g.bounds.width+e)/2;for(const m of a)y.pathDivide(m,e,c,!!f)}}_placeSubdivGlyphs(a,c,b,f){const {allowOverrun:d,labelPosition:e,repeatLabelDistance:g}=this.evaluatedMeshParams,m=this._current.zoomRange[0];var n=E(c),k=this._current.shaping.bounds.width/2,l=Math.sqrt(g||128)/2;b=Math.min(b,f-b);k=this._current.shaping.isMultiline?
25:Math.log2(b/(l+k/2));n=Math.max(m,this._zoomLevel+1-(0===c?k:Math.min(n,k)));k=this._zoomLevel-n;l=this._current.shaping.bounds.width/2*2**k;this._current.shaping.isMultiline?0===c&&this._placeStraight(a,n):d&&0>k?this._placeStraightAlong(a,m):"parallel"===e?this._placeStraightAlong(a,n):"curved"===e&&this._placeCurved(a,n,l)}_placeStraight(a,c){const {out:b,id:f,shaping:d,zoomRange:e,referenceBounds:g}=this._current,{x:m,y:n}=a,k=180/Math.PI*a.angle%360,l=(180/Math.PI*a.angle+180)%360;if(d.textBox){var h=
Math.max(c,e[0],0);const p=Math.min(25,e[1]);var q=u.fromRotation(v.create(),-a.angle);[,q]=d.shapeBackground(q);h={minZoom:h,maxZoom:p,clipAngle:k,mapAligned:!0,isLineLabel:!0};b.recordStart(this.instanceId,this.attributeLayout,d.glyphs[0].textureBinding);this._writeTextBox(b,f,a.x,a.y,q,g,h);b.recordEnd();h.clipAngle=l;b.recordStart(this.instanceId,this.attributeLayout,d.glyphs[0].textureBinding);this._writeTextBox(b,f,a.x,a.y,q,g,h);b.recordEnd()}for(const p of d.glyphs)p.minZoom=c,p.maxZoom=e[1],
p.angle=a.angle,this._writeLineGlyph(b,f,m,n,d.bounds,p,k,g,!0),p.angle=a.angle+Math.PI,this._writeLineGlyph(b,f,m,n,d.bounds,p,l,g,!0)}_placeCurved(a,c,b){const f=a.clone(),d=180/Math.PI*a.angle%360,e=(180/Math.PI*a.angle+180)%360;this._placeFirst(f,c,1,d);this._placeBack(a,f,c,b,1,d);this._placeForward(a,f,c,b,1,d);this._placeFirst(f,c,0,e);this._placeBack(a,f,c,b,0,e);this._placeForward(a,f,c,b,0,e)}_placeStraightAlong(a,c){const {out:b,id:f,shaping:d,zoomRange:e,referenceBounds:g}=this._current,
{boxBorderLineColor:m,boxBackgroundColor:n}=this.evaluatedMeshParams,k=a.clone(),l=180/Math.PI*a.angle%360,h=(180/Math.PI*a.angle+180)%360;if(0<d.glyphs.length&&(m||n)){var q=Math.max(c,e[0],0);const r=Math.min(25,e[1]);var p=u.fromRotation(v.create(),-a.angle);[,p]=d.shapeBackground(p);q={minZoom:q,maxZoom:r,clipAngle:l,mapAligned:!0,isLineLabel:!0};b.recordStart(this.instanceId,this.attributeLayout,d.glyphs[0].textureBinding);this._writeTextBox(b,f,a.x,a.y,p,g,q);b.recordEnd();q.clipAngle=h;b.recordStart(this.instanceId,
this.attributeLayout,d.glyphs[0].textureBinding);this._writeTextBox(b,f,a.x,a.y,p,g,q);b.recordEnd()}this._placeFirst(k,c,1,l,!0);this._placeFirst(k,c,0,h,!0)}_placeBack(a,c,b,f,d,e){const g=a.clone();for(a=a.backwardLength+0;g.prev()&&!(a>=f);)this._placeOnSegment(g,c,a,b,-1,d,e),a+=g.length+0}_placeForward(a,c,b,f,d,e){const g=a.clone();for(a=a.remainingLength+0;g.next()&&!(a>=f);)this._placeOnSegment(g,c,a,b,1,d,e),a+=g.length+0}_placeFirst(a,c,b,f,d=!1){const {out:e,id:g,shaping:m,zoomRange:n,
referenceBounds:k}=this._current;var l=m.glyphs;for(const h of l)l=h.x>m.bounds.x?b:1-b,l=Math.max(0,this._zoomLevel+Math.log2(Math.abs(h.x+h.width/2-m.bounds.x)/(l*a.remainingLength+(1-l)*a.backwardLength))),l=Math.max(c,d?0:l),h.maxZoom=Math.min(n[1],25),h.angle=a.angle+(1-b)*Math.PI,h.minZoom=Math.max(n[0],l),this._writeLineGlyph(e,g,a.x,a.y,m.bounds,h,f,k,!0)}_placeOnSegment(a,c,b,f,d,e,g){const {out:m,id:n,shaping:k,referenceBounds:l}=this._current;var h=k.glyphs;c=a.x+a.dx/a.length*-d*b;var q=
a.y+a.dy/a.length*-d*b;for(const r of h)if((h=r.x>k.bounds.x?e:1-e)&&1===d||!h&&-1===d){var p=Math.abs(r.x+r.width/2-k.bounds.x);h=Math.max(0,this._zoomLevel+Math.log2(p/b)-.1);p=Math.max(f,this._zoomLevel+Math.log2(p/(b+a.length+0)));0!==h&&(r.angle=a.angle+(1-e)*Math.PI,r.minZoom=p,r.maxZoom=h,this._writeLineGlyph(m,n,c,q,k.bounds,r,g,l,!0))}}_writeLineGlyph(a,c,b,f,d,e,g,m,n){const k=b+d.x,l=f+d.y;d=2*Math.max(d.width,d.height)*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/
this._textMeshTransformProps.fontSize:1);a.recordStart(this.instanceId,this.attributeLayout,e.textureBinding);this.enablePixelBuffering&&a.recordBounds(k,l,d,d);const {texcoords:h,offsets:q}=e;this._writeQuad(a,c,b,f,{texcoords:h,offsets:q,fontSize:this._textMeshTransformProps.fontSize,color:z.processColorInput(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:m,minZoom:Math.max(this._current.zoomRange[0],e.minZoom),maxZoom:Math.min(this._current.zoomRange[1],e.maxZoom),clipAngle:g,
mapAligned:n,isLineLabel:!0});a.recordEnd()}}t.LabelMeshWriter=F;Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});