// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../../../../core/arrayUtils ../../../../../../../core/Error ../../../../../../../core/lang ../../../../../../../core/Logger ../../../grouping ./utils ../../../../../layers/features/support/DictionaryValue".split(" "),function(w,u,B,C,D,E,F,G){async function v(c,e){const {defaultValue:d,valueExpressionInfo:b,value:g}=e;if(b){const {expression:h}=b;return(c=await c.createComputedField({expression:h}))?{...e,computed:c,defaultValue:d}:null}return{...e,computed:new G.DictionaryValue(g),
defaultValue:d}}async function x(c,e){const {defaultValue:d,valueExpressionInfo:b}=e,{expression:g}=b;return(c=await c.createComputedField({expression:g}))?{...e,computed:c,defaultValue:d}:null}const y=c=>"boolean"!==typeof c&&"number"!==typeof c&&"valueExpressionInfo"in c,H=c=>c.some(e=>{for(const d in e)if(y(e[d]))return!0;return!1});class z{static async create(c,e,d){const b={},g=new Map,h=new Map,f=new Map,l=new Map,n=new Map;for(const k in d.params){var a=d.params[k];if(null==a||"object"!==typeof a)b[k]=
a;else if(Array.isArray(a)){if("object"===typeof a[0])throw Error(`InternalError: Cannot handle ${k}. Nested array params are not supported`);b[k]=a}else if("valueExpressionInfo"in a)if(a.value)b[k]=a.value;else{var p=await x(c,a);p?(g.set(k,p),b[k]=null):b[k]=a.defaultValue}else switch(a.type){case "cim-effect-infos":if(a.effectInfos.some(m=>m.overrides.length)){h.set(k,{effects:await Promise.all(a.effectInfos.map(async m=>{const r=m.overrides.map(q=>v(c,q));return{effect:m.effect,compiledOverrides:(await Promise.all(r)).filter(u.isSome)}}))});
break}b[k]=a.effectInfos.map(m=>m.effect);break;case "cim-marker-placement-info":a.overrides.length&&f.set(k,{placementInfo:a,compiledOverrides:(await Promise.all(a.overrides.map(m=>v(c,m)))).filter(u.isSome)});b[k]=a.placement;break;case "sprite-rasterization-param":case "text-rasterization-param":if(a.overrides.length){p=a.overrides.map(m=>v(c,m));l.set(k,{compiledOverrides:(await Promise.all(p)).filter(u.isSome),rasterizationParam:a,objectIdToResourceId:new Map});continue}if("sprite-rasterization-param"===
a.type&&"animated"===a.resource.type){l.set(k,{compiledOverrides:[],rasterizationParam:a,objectIdToResourceId:new Map});continue}b[k]=await e.fetchResourceImmediate({type:"cim-rasterization-info",resource:a.resource})??null;break;case "cim-marker-transform-param":({params:a}=a);if(H(a)){const m={compiledMarkerInfos:[]};await Promise.all(a.map(async r=>{const q={props:{}};for(const t in r)if(y(r[t])){const A=await x(c,r[t]);q.compiledExpressionMap||(q.compiledExpressionMap=new Map);const I=q.compiledExpressionMap;
A&&I.set(t,A)}else q.props[t]=r[t];m.compiledMarkerInfos.push(q)}));n.set(k,m)}else b[k]={type:"cim-marker-transform-info",infos:a};break;default:b[k]=a}}return new z(d,b,g,h,f,l,n)}constructor(c,e,d,b,g,h,f){this.inputMeshParams=c;this._resolvedMeshParams=e;this._dynamicProperties=d;this._dynamicEffectProperties=b;this._dynamicPlacementProperties=g;this._dynamicAsyncProperties=h;this._dynamicTransformProperties=f;this.evaluator=l=>l}get hasDynamicProperties(){return!!(this._dynamicProperties.size||
this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams));return this._evaluatedMeshParams}enqueueRequest(c,e,d){for(const g of this._dynamicAsyncProperties.values()){var b=C.clone(g.rasterizationParam.resource);"animated"===g.rasterizationParam.resource.type&&g.rasterizationParam.resource.randomizeStartTime&&
(b.startGroup=E.getStartGroup(e.getObjectId()||0));for(const {primitiveName:h,propertyName:f,computed:l,defaultValue:n,valueExpressionInfo:a}of g.compiledOverrides)try{F.applyComputedValue(b,h,f,l,e,d,n)}catch(p){D.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new B("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${a?.expression}' (primitive: '${h}', property: '${f}')`,p))}b=c.enqueueRequest({type:"cim-rasterization-info",
resource:b});g.objectIdToResourceId.set(e.getObjectId(),b)}}evaluateMeshParams(c,e,d){for(const [h,f]of this._dynamicProperties.entries())this._resolvedMeshParams[h]=f.computed.readWithDefault(e,d,f.defaultValue);for(const [h,f]of this._dynamicPlacementProperties.entries())for(const {computed:l,defaultValue:n,propertyName:a}of f.compiledOverrides){var b=l.readWithDefault(e,d,n);f.placementInfo.placement[a]=b;this._resolvedMeshParams[h]=f.placementInfo.placement}for(const [h,f]of this._dynamicEffectProperties.entries())for(var g of f.effects){for(const {computed:l,
defaultValue:n,propertyName:a}of g.compiledOverrides)b=l.readWithDefault(e,d,n),g.effect[a]=b;this._resolvedMeshParams[h]=f.effects.map(l=>l.effect)}for(const [h,f]of this._dynamicTransformProperties.entries()){g={type:"cim-marker-transform-info",infos:[]};for(const l of f.compiledMarkerInfos){b={...l.props};if(l.compiledExpressionMap)for(const [n,a]of l.compiledExpressionMap){const p=a.computed.readWithDefault(e,d,a.defaultValue);b[n]="number"===typeof p||"boolean"===typeof p?p:a.defaultValue}g.infos.push(b)}this._resolvedMeshParams[h]=
g}for(const [h,f]of this._dynamicAsyncProperties.entries())d=f.objectIdToResourceId.get(e.getObjectId()),null!=d&&(d=c.getResource(d),this._resolvedMeshParams[h]=d);this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams);return this.evaluatedMeshParams}}w.MeshWriterInputEvaluator=z;Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});