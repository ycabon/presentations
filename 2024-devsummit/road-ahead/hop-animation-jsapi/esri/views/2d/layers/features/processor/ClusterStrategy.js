// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/has ../../../../../layers/graphics/featureConversionUtils ../../../../../layers/graphics/OptimizedFeature ../../../../../layers/support/FieldsIndex ../../../engine/webgl/definitions ../aggregation/ComputedAggregateField ../aggregation/GridCell ../aggregation/GridSpatialIndex ./AAggregateStrategy ./AProcessorStrategy ./support/WithDisplayId ../sources/FeatureSourceMessage ../support/ComputedAttributeStorage ../support/FeatureFilter ../support/FeatureMetadata ../support/FeatureSetReaderJSON".split(" "),
function(m,n,u,p,v,q,w,x,y,z,A,B,C,D,E,F,G){class r extends A.ASendState{constructor(a){super(a);this.done=this.didSend=!1}}class H{constructor(a,c,b,d,e){this._level=a;this._scale=c;this._indexOptions=b;this._clusterRadius=d;this._store=e;this._cells=new Map;this._handledChunks=new Set;this._statistics=new Map;this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const a of this._clusters.values())this._store.releaseDisplayIdForObjectId(a.inner.id);this._clusters.clear()}clusters(){return this._clusters.values()}updateChunks(a){let c=
!1;for(const b of a)this._handledChunks.has(b.chunkId)||(this._handledChunks.add(b.chunkId),c=!0,b.getGridIndex({...this._indexOptions,scale:this._scale}).putCells(this._cells));c&&this._clusterCells();return c}async updateStatistics(a){var c=!1;for(const b of this._clusters.values())1<b.inner.count&&(c=this._updateAggregateStatistics(this._statistics,b.inner)||c);c&&(c=Array.from(this._statistics.entries()).map(([b,d])=>({fieldName:b,minValue:d.minValue,maxValue:d.maxValue})),await a.container.updateStatistics(this._level,
c))}createAggregateFeatures(a,c){a=a.subscription;const b=[],d=a.tile.transform;for(const f of this._clusters.values()){var e=f.inner.getCentroid(d);e=new p.OptimizedFeature(e,f.inner.getAttributes(),null);e.objectId=f.inner.id;e.displayId=f.displayId;const [g,h]=e.geometry.coords;g<q.tileSize&&0<=g&&h<q.tileSize&&0<=h&&b.push(e)}return G.FeatureSetReaderJSON.fromOptimizedFeatures(b,c,a.tile.transform)}_clusterCells(){var a=Array.from(this._cells.values());a=a.sort((b,d)=>d.count-b.count);this._clusters.clear();
const c=new Set;for(const b of a){if(c.has(b.id))continue;a=this._store.createDisplayIdForObjectId(b.id);a=new B.WithDisplayId(b.clone(),a);c.add(b.id);this._clusters.set(b.id,a);const d=this._clusterRadius*(1/y.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale)),e=1+this._clusterRadius/this._indexOptions.cellSize,f=b.centroidXWorld,g=b.centroidYWorld;for(let h=b.gridY-e;h<=b.gridY+e;h++)for(let k=b.gridX-e;k<=b.gridX+e;k++){if(0===h&&0===k)continue;const l=this._cells.get(x.GridCell.createId(k,
h));if(!l||c.has(l.id))continue;const I=Math.abs(l.centroidYWorld-g);Math.abs(l.centroidXWorld-f)<d&&I<d&&(a.inner.merge(l),c.add(l.id))}}}_updateAggregateStatistics(a,c){let b=!1;for(const f of c.statistics.values())if("esriFieldTypeString"!==f.field.type){var d=f.value,e=f.field;if(c=a.get(e.name)){const {minValue:g,maxValue:h}=c;e=Math.min(c.minValue,d);d=Math.max(c.maxValue,d);if(g!==e||h!==d)c.minValue=e,c.maxValue=d,b=!0}else a.set(e.name,{minValue:d,maxValue:d}),b=!0}return b}}class t extends z.AAggregateStrategy{static async create(a,
c,b,d,e){const f=new D.ComputedAttributeStorage({spatialReference:b}),g=await Promise.all(c.fields.map(async k=>w.ComputedAggregateField.create(f,k))),h=c.featureFilter?await E.create({geometryType:d.service.geometryType,hasM:!1,hasZ:!1,timeInfo:d.service.timeInfo,fieldsIndex:new v(d.service.fields),spatialReference:b,filterJSON:c.featureFilter}):null;return new t(a,c.clusterRadius,{fields:g,spatialReference:b,featureFilter:h,cellSize:c.clusterRadius/4},d,e)}constructor(a,c,b,d,e){super(d,e,b.spatialReference,
b.fields);this._connection=a;this._clusterRadius=c;this._indexOptions=b;this._metadata=new F.FeatureMetadata({geometryType:this.geometryType,objectIdField:"aggregateId",fields:[...this._indexOptions.fields,...this._source.service.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}]});this._aggregateStatistics=new Map;this._cellsPerScale=new Map}get geometryType(){return"esriGeometryPoint"}onSubscribe(a){super.onSubscribe(a);this._requiredLevel=a.tile.level;this._requiredScale=
a.tile.scale}createState(a){return new r(a)}async *applyOverride(a){this._aggregateStatistics.clear()}getDisplayIds(a){a=new Set(a);const c=[],b=this._getClusterState(this._requiredLevel,this._requiredScale);for(const d of b.clusters())a.has(d.inner.id)?(c.push(d.displayId),a.delete(d.inner.id)):1===d.inner.count&&a.has(d.inner.firstObjectId)&&(c.push(d.displayId),a.delete(d.inner.firstObjectId));return c}getDisplayFeatures(a){a=new Set(a);const c=new Set,b=[],d=[];var e=this._getClusterState(this._requiredLevel,
this._requiredScale);for(const f of e.clusters())if(a.has(f.displayId)&&!c.has(f.displayId)){e=f.inner.getCentroid(null);e=new p.OptimizedFeature(e,f.inner.getAttributes(),null);e.objectId=f.inner.id;e.displayId=f.displayId;const g=u.convertToFeature(e,this.geometryType,!1,!1);c.add(e.displayId);1===g.attributes.cluster_count?b.push(g):d.push(g)}return{features:b,aggregates:d}}getFeatureObjectIdsForAggregate(a){const c=this._getClusterState(this._requiredLevel,this._requiredScale);for(const b of c.clusters())if(b.inner.id===
a)return Array.from(b.inner.objectIds);return[]}async *updateChunks(){var a=this._source.chunks();if(a.length){var c=this._getClusterState(this._requiredLevel,this._requiredScale);if(c.updateChunks(a)||!this._source.updateTracking.updating)for(const d of this._sendStates.values())d.subscription.tile.level===this._requiredLevel&&(d.didSend=!1);a=Array.from(this._sendStates.values()).filter(d=>d.done).map(d=>d.subscription.tile.key);var b=new Set(a);for(const d of this._sendStates.values()){if(this._source.updateTracking.updating){if(a.some(e=>
e.containsChild(d.subscription.tile.key)))continue;if(d.subscription.tile.key.getChildKeys().every(e=>b.has(e)))continue}d.didSend||d.subscription.tile.level!==this._requiredLevel||(d.didSend=!0,yield*this._update(d,c,this._source))}await c.updateStatistics(this._connection)}}_getClusterState(a,c){if(null==a||null==c)throw Error("InternalError: Level and scale must be defined");let b=this._cellsPerScale.get(c);b||(b=new H(a,c,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(c,
b));return b}async *_update(a,c,b){const {subscription:d}=a;if(!a.done){c=c.createAggregateFeatures(a,this._metadata);this.events.emit("changed");a.done=!b.updateTracking.updating;b=c.getCursor();for(var e=a.subscription.tile.arcadeEvaluationOptions;b.next();)this._attributeStore.setAttributeData(b.getDisplayId(),b,e);n("esri-2d-update-debug")&&console.debug(`Tile[${d.tile.key.id}] ClusterStrategy.sendUpdates`);this._attributeStore.sendUpdates();n("esri-2d-update-debug")&&console.debug(`Tile[${d.tile.key.id}] ClusterStrategy._sendUpdates.await`);
yield new C.FeatureTileUpdateMessage(a.subscription,c,[],a.done,{})}}}m.ClusterState=r;m.ClusterStrategy=t;Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});