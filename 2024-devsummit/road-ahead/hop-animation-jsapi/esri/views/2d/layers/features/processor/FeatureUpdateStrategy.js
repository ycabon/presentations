// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define(["exports","./AProcessorStrategy","../sources/FeatureSourceMessage","../sources/strategies/chunks/OverrideChunk"],function(h,l,k,n){class m extends l.ASendState{}class p extends l.AProcessorStrategy{constructor(a,d){super(a,d);this.handledChunks=new Set;this.handledChunksForIdCreation=new Set;this.handledChunksForAttributeData=new Set;this._handle=a.store.events.on("remove",b=>{this.handledChunks.delete(b.chunkId);this.handledChunksForAttributeData.delete(b.chunkId);this.handledChunksForIdCreation.delete(b.chunkId);
for(b=b.reader.getCursor();b.next();){const c=b.getObjectId();this._attributeStore.releaseDisplayIdForObjectId(c)}})}destroy(){super.destroy();this._handle.remove();for(const a of this._source.chunks()){const d=a.reader.getCursor();for(;d.next();){const b=d.getObjectId();this._attributeStore.releaseDisplayIdForObjectId(b)}}}invalidateAttributeData(){this.handledChunksForAttributeData.clear()}onSubscribe(a){super.onSubscribe(a);this._evalOptions=a.tile.arcadeEvaluationOptions}createState(a){return new m(a)}get aggregateQueryEngine(){throw Error("InternalError: FeatureUpdateStrategy does not support aggregations");
}getDisplayIds(a){a=new Set(a);const d=[];for(const b of this._source.chunks()){const c=b.reader.getCursor();for(;c.next();)a.has(c.getObjectId())&&d.push(c.getDisplayId())}return d}getDisplayFeatures(a){a=new Set(a);const d=new Set,b=[];for(const c of this._source.chunks()){const e=c.reader.getCursor();for(;e.next();){const f=e.getObjectId();a.has(e.getDisplayId())&&!d.has(f)&&(b.push(e.readLegacyFeatureWorldSpace()),d.add(f))}}return{features:b,aggregates:[]}}async *applyOverride(a){const d=[];
for(var b=a.reader.getCursor();b.next();){var c=b.getObjectId();d.push(c);c=this._attributeStore.createDisplayIdForObjectId(c);b.setDisplayId(c);this._attributeStore.setAttributeData(c,b,this._evalOptions)}const e=this.getDisplayIds(d);b=this.getDisplayIds(a.removed);this._attributeStore.sendUpdates();c=new n.OverrideChunk;c.applyOverrides(a);for(var f of this._sendStates.values())yield new k.FeatureTileUpdateMessage(f.subscription,null,e,!1,c.queryInfo);for(const g of this._sendStates.values())f=
c.getTileReader(g.subscription.tile),yield new k.FeatureTileUpdateMessage(g.subscription,f,b,!1,c.queryInfo);for(const g of a.removed)this._attributeStore.releaseDisplayIdForObjectId(g);for(const g of d)this._attributeStore.releaseDisplayIdForObjectId(g)}async *updateChunks(){if(this._source.chunks().length){await this._updateAttributeData();for(const a of this._sendStates.values())yield*this._update(a)}}async _updateAttributeData(){for(var a of this._source.chunks()){const {chunkId:b,reader:c}=a;
if(!this.handledChunksForIdCreation.has(b)){this.handledChunksForIdCreation.add(b);for(var d=c.getCursor();d.next();){const e=this._attributeStore.createDisplayIdForObjectId(d.getObjectId());d.setDisplayId(e)}}}for(const b of this._source.chunks())if(!this.handledChunksForAttributeData.has(b.chunkId))for(this.handledChunksForAttributeData.add(b.chunkId),a=b.reader.getCursor();a.next();)d=a.getDisplayId(),this._attributeStore.setAttributeData(d,a,this._evalOptions);this._attributeStore.sendUpdates()}*_update(a){const {subscription:d,
handledChunks:b}=a;for(const e of this._source.chunks()){var {chunkId:c}=e;b.has(c)||(b.add(c),(c=e.getTileReader(d.tile))&&(yield new k.FeatureTileAppendMessage(a.subscription,c,!1,e.end,e.queryInfo)))}}}h.DefaultSendState=m;h.FeatureUpdateStrategy=p;Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});