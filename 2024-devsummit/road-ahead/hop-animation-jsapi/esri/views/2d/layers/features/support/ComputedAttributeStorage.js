// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/Error ../../../../../core/Logger ../../../../../geometry/support/aaBoundingBox ../../../engine/webgl/DisplayId ./CachedField ./ComputedExpression ./NormalizedField ./StaticBitSet ./whereUtils".split(" "),function(m,n,t,u,c,v,w,x,y,z){function g(a,b,d){if(!(a.length>b))for(;a.length<=b;)a.push(d)}const p=()=>t.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage");class A{constructor(a){this._numerics=[];this._strings=[];this._allocatedSize=
256;this._bitsets=[];this._instanceIds=[];this._bounds=[];this._dirtyBitset=this.getBitset(this.createBitset());this.compilationOptions=a}createBitset(){const a=this._bitsets.length;this._bitsets.push(y.StaticBitSet.create(this._allocatedSize,c.displayIdTexelMask));return a+1}async createComputedField(a){if(a.expression)try{if(!this.compilationOptions)throw Error("InternalError: Compilation options not defined");return await w.ComputedExpression.create(a.expression,this.compilationOptions)}catch(b){return a=
new n("featurelayer","Failed to compile arcade expression",{error:b,expression:a.expression}),p().error(a),null}if(a.normalizationType||a.normalizationField)return new x.NormalizedField(a.field,a);if(a.field)return new v.CachedField(a.field);a=new n("featurelayer","Unable to create computed field. No expression or field found",{info:a});p().error(a);return null}async createWhereClause(a){return a?z.createWhereClause(a,this.compilationOptions.fields):null}getBitset(a){return this._bitsets[a-1]}getComputedNumeric(a,
b){return this.getComputedNumericAtIndex(a&c.displayIdTexelMask,0)}setComputedNumeric(a,b,d){return this.setComputedNumericAtIndex(a&c.displayIdTexelMask,d,0)}getComputedString(a,b){return this.getComputedStringAtIndex(a&c.displayIdTexelMask,0)}setComputedString(a,b,d){return this.setComputedStringAtIndex(a&c.displayIdTexelMask,0,d)}getComputedNumericAtIndex(a,b){a&=c.displayIdTexelMask;this._ensureNumeric(b,a);return this._numerics[b][a]}setComputedNumericAtIndex(a,b,d){a&=c.displayIdTexelMask;this._ensureNumeric(b,
a);this._numerics[b][a]=d}getPackedChunkId(a){a&=c.displayIdTexelMask;this._ensureInstanceId(a);return this._instanceIds[a]}setPackedChunkId(a,b){a&=c.displayIdTexelMask;this._ensureInstanceId(a);this._instanceIds[a]=b}getComputedStringAtIndex(a,b){a&=c.displayIdTexelMask;this._ensureString(b,a);return this._strings[b][a]}setComputedStringAtIndex(a,b,d){a&=c.displayIdTexelMask;this._ensureString(b,a);this._strings[b][a]=d}getXMin(a){return this._bounds[4*(a&c.displayIdTexelMask)]}getYMin(a){return this._bounds[4*
(a&c.displayIdTexelMask)+1]}getXMax(a){return this._bounds[4*(a&c.displayIdTexelMask)+2]}getYMax(a){return this._bounds[4*(a&c.displayIdTexelMask)+3]}setBounds(a,b,d=!1){const e=a&c.displayIdTexelMask;if(!d&&!this._dirtyBitset.has(a))return 4294967295!==this._bounds[4*e];this._dirtyBitset.unset(a);a=b.readGeometryWorldSpace();g(this._bounds,4*e+4,0);if(!a||!a.coords.length)return this._bounds[4*e]=4294967295,this._bounds[4*e+1]=4294967295,this._bounds[4*e+2]=4294967295,this._bounds[4*e+3]=4294967295,
!1;let f=Infinity,h=Infinity,k=-Infinity,l=-Infinity;a.forEachVertex((q,r)=>{f=Math.min(f,q);h=Math.min(h,r);k=Math.max(k,q);l=Math.max(l,r)});this._bounds[4*e]=f;this._bounds[4*e+1]=h;this._bounds[4*e+2]=k;this._bounds[4*e+3]=l;return!0}getBounds(a,b){const d=this.getXMin(b),e=this.getYMin(b),f=this.getXMax(b);b=this.getYMax(b);u.fromRectValues(a,d,e,f,b);return 4294967295!==d}_ensureNumeric(a,b){this._numerics[a]||(this._numerics[a]=[]);g(this._numerics[a],b,0)}_ensureInstanceId(a){g(this._instanceIds,
a,0)}_ensureString(a,b){this._strings[a]||(this._strings[a]=[]);g(this._strings[a],b,null)}}m.ComputedAttributeStorage=A;Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});