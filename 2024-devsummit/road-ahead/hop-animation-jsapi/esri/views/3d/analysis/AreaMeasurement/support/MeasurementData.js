// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/mathUtils ../../../../../core/quantityUtils ../../../../../core/libs/gl-matrix-2/math/vec2 ../../../../../core/libs/gl-matrix-2/factories/vec2f64 ../../../../../chunks/vec32 ../../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../../core/libs/gl-matrix-2/factories/vec4f64 ../../../../../geometry/ellipsoidUtils ../../../../../geometry/projection ../../../../../geometry/SpatialReference ../../../../../geometry/spatialReferenceEllipsoidUtils ../../../../../geometry/projection/projectDirection ../../../../../geometry/projection/projectPointToVector ../../../../../geometry/projection/projectPointToWGS84ComparableLonLat ../../../../../geometry/projection/projectVectorToVector ../../../../../geometry/support/Axis ../../../../../geometry/support/Indices ../../../../../geometry/support/intersectsBase ../../../../../chunks/sphere ../../../../../geometry/support/triangle ../../interfaces ../../support/measurementUtils ../../../support/ElevationProvider ../../../support/mathUtils ../../../../support/euclideanAreaMeasurementUtils".split(" "),
function(E,P,y,B,F,k,l,Q,R,G,S,H,I,C,T,J,U,K,L,V,W,M,v,X,A,N){class Y{get numVertices(){return this._length}get hasStagedVertex(){return this._hasCursorPoint}constructor(a,c){this.validMeasurement=!1;this.positionsWorldCoords=[];this.positionsRenderCoords=[];this.positionsProjectedWorldCoords=[];this.positionsFittedRenderCoords=[];this.positionsGeographic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=
[];this.intersectingSegments=new Set;this.geodesicIntersectingSegments=new Set;this.geodesicTriangleIndices=this.triangleIndices=null;this.areaCentroidWorldCoords=l.create();this.areaCentroidRenderCoords=l.create();this.geodesicAreaCentroidRenderCoords=l.create();this.perimeterLength=this.geodesicPathLength=this.pathLength=this.geodesicArea=this.area=null;this._length=0;this._centroidRenderCoords=l.create();this._planeWorldCoords=Q.create();this._worldUp=l.create();this._worldTangent=l.create();this._frame=
[l.create(),l.create(),l.create()];this._pathVersion=-1;this._hasCursorPoint=!1;this._mode=null;this._tempU=l.create();this._tempV=l.create();this._tempVec3=l.create();this._tempSphere=V.create();this._sceneView=a;this.unitNormalizer=c}update(a,c,d,b,e,f){const h=null!=c,p=this._hasCursorPoint===h,m=this._mode===e;if(this._pathVersion===a.version&&!f&&p&&m&&a.isValidPolygon)return!1;this._pathVersion=a.version;this._hasCursorPoint=h;this._updateCursorSegmentLength(a,c);this._update(a,c,d,b,e);return!0}_update(a,
c,d,b,e){const f=this.unitNormalizer,h=this._sceneView.renderSpatialReference,p=this.unitNormalizer.spatialReference;let m=a.numVertices;const n=null!=c&&!c.equals(a.lastPoint)&&!(2<m&&c.equals(a.firstPoint));n&&(m+=1);var g=!a.polygonIsClosed&&2<m;g=a.polygonIsClosed||g;this._resize(m);const w=H.getSphericalPCPF(d.spatialReference),r=G.canProjectWithoutEngine(d.spatialReference,w)&&G.canProjectToWGS84ComparableLonLat(d.spatialReference),{positionsGeographic:q,positionsWorldCoords:t,positionsRenderCoords:z,
positionsSpherical:D}=this,O=(u,x)=>{u.hasZ||(u.z=X.getElevationAtPoint(d.elevationProvider,u,"ground")??0);C.projectPointToVector(u,t[x],p);C.projectPointToVector(u,z[x],h);r&&(T.projectPointToWGS84ComparableLonLat(u,q[x]),C.projectPointToVector(u,D[x],w),k.normalize(D[x],D[x]))};a.forEachVertexPosition((u,x)=>O(u,x));n&&O(c,m-1);a=this._updatePathLengths(g);this.pathLength=1<this._length?y.createLength(f.normalizeDistance(a),"meters"):null;r?(a=this._updateGeodesicPathLengths(g,p),this.geodesicPathLength=
1<this._length?y.createLength(a,"meters"):null):this.geodesicPathLength=null;this._updateMode(e);g?(this._updateAreaAndPerimeterLength(d,f,h,p,b),r&&this._updateGeodesicArea(d),this.validMeasurement=!0):(this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),this.validMeasurement=!1)}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,
positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,
intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,
perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(a){a<this._length&&(this.positionsWorldCoords.length=a,this.positionsRenderCoords.length=a,this.positionsProjectedWorldCoords.length=a,this.positionsFittedRenderCoords.length=a,this.positionsGeographic.length=a,this.positionsSpherical.length=a,this.positionsStereographic.length=a,this.pathSegmentLengths.length=a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=
a);for(;this._length<a;)this.positionsWorldCoords.push(l.create()),this.positionsRenderCoords.push(l.create()),this.positionsProjectedWorldCoords.push(F.create()),this.positionsFittedRenderCoords.push(l.create()),this.positionsGeographic.push(l.create()),this.positionsSpherical.push(l.create()),this.positionsStereographic.push(F.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(a){const c=this.positionsWorldCoords,
d=this.pathSegmentLengths;let b=0;for(let e=0;e<this._length;++e){const f=d[e]=k.distance(c[e],c[(e+1)%this._length]);if(e<this._length-1||a)b+=f}return b}_updateGeodesicPathLengths(a,c){const d=this.positionsGeographic,b=this.geodesicPathSegmentLengths;let e=0;for(let f=0;f<this._length;++f){const h=b[f]=v.segmentLengthGeodesicVector(d[f],d[(f+1)%this._length],c??void 0);if(f<this._length-1||a)e+=h}return e}_updateAreaAndPerimeterLength(a,c,d,b,e){const f=a.renderCoordsHelper;a=this.positionsWorldCoords;
const h=this.positionsRenderCoords,p=this.positionsProjectedWorldCoords,m=this.positionsFittedRenderCoords;var n=this._planeWorldCoords,g=this._centroidRenderCoords;A.midpoint3d(h,g);f.worldUpAtPosition(g,this._worldUp);f.worldBasisAtPosition(g,U.Axis.X,this._worldTangent);I.projectDirection(g,this._worldUp,d,this._worldUp,b);I.projectDirection(g,this._worldTangent,d,this._worldTangent,b);2<a.length&&v.bestFitPlane(a,n);this.fittingMode=this._selectFittingMode(n,a,this._worldUp,e);let w=0;if("horizontal"===
this.fittingMode){let q=-Infinity;h.forEach((t,z)=>{t=f.getAltitude(h[z]);t>q&&(q=t,w=z)})}e=a[w];g=n;var r=this._worldTangent;"horizontal"===this.fittingMode?g=this._worldUp:"vertical"===this.fittingMode&&(g=this._tempVec3,r=this._worldUp,A.makeOrthonormal(n,this._worldUp,g));k.copy(this._frame[2],g);A.makeOrthonormal(r,g,this._frame[0]);k.cross(this._frame[1],this._frame[0],this._frame[2]);k.negate(this._frame[1],this._frame[1]);n=this._tempVec3;g=this._tempU;r=this._tempV;for(let q=0;q<this._length;++q){const t=
p[q],z=m[q];k.subtract(n,a[q],e);B.set(t,k.dot(this._frame[0],n),k.dot(this._frame[1],n));k.scale(g,this._frame[0],t[0]);k.scale(r,this._frame[1],t[1]);k.add(n,g,r);k.add(n,n,e);J.projectVectorToVector(n,b,z,d)}this.perimeterLength=0<this._length?y.createLength(c.normalizeDistance(this._updatePerimeterLengths()),"meters"):null;A.midpoint3d(m,this.areaCentroidRenderCoords);J.projectVectorToVector(this.areaCentroidRenderCoords,d,this.areaCentroidWorldCoords,b);this._updateIntersectingSegments();this.area=
0===this.intersectingSegments.size?y.createArea(c.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(a){const {renderCoordsHelper:c,spatialReference:d}=a,{positionsSpherical:b,positionsStereographic:e}=this;a=this._tempVec3;const f=v.fitHemisphere(b,a);if(f){var h=this._tempU,p=this._tempV;A.tangentFrame(a,h,p);for(let m=0;m<this._length;++m){const n=k.dot(b[m],h),g=k.dot(b[m],p),w=k.dot(b[m],a);B.set(e[m],n/w,g/w)}k.scale(a,a,R.getReferenceEllipsoid(d).radius);c.toRenderCoords(a,
H.getSphericalPCPF(d),this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=f&&0===this.geodesicIntersectingSegments.size?y.createArea(this._computeGeodesicArea(),"square-meters"):null}else this.geodesicArea=null}_updatePerimeterLengths(){const a=this.positionsProjectedWorldCoords,c=this.perimeterSegmentLengths;let d=0;for(let b=0;b<this._length;++b){const e=c[b]=B.distance(a[b],a[(b+1)%this._length]);d+=e}return d}_updateIntersectingSegments(){const a=
this.positionsProjectedWorldCoords,c=this.intersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&L.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))}_computeArea(){const a=this.positionsProjectedWorldCoords,c=this.triangleIndices=K.compactIndices(N.triangulate(a));let d=0;for(let b=0;b<c.length;b+=3)d+=W.areaPoints2d(a[c[b]],a[c[b+1]],a[c[b+2]]);return d}_updateGeodesicIntersectingSegments(){const a=
this.positionsStereographic,c=this.geodesicIntersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&L.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))}_computeGeodesicArea(){const a=this.positionsGeographic,c=this.geodesicTriangleIndices=K.compactIndices(N.triangulate(this.positionsStereographic));let d=0;for(let b=0;b<c.length;b+=3)d+=v.triangleAreaGeodesic(a[c[b]],a[c[b+1]],a[c[b+2]],S.WGS84);
return d}_selectFittingMode(a,c,d,b){var e=c.map(h=>Math.abs(v.planePointDistance(a,h))).reduce((h,p)=>Math.max(h,p),0);v.boundingSphere(c,this._tempSphere);c=e/(2*this._tempSphere[3]);e=c<b.maxRelativeErrorAlmostCoplanar;let f="horizontal";c<b.maxRelativeErrorCoplanar?f="oblique":e&&(f=Math.abs(k.dot(d,a))>Math.cos(P.deg2rad(b.verticalAngleThreshold))?"horizontal":"vertical");return f}_updateCursorSegmentLength(a,c){const d=a.lastPoint;a.isValidPolygon||null==d||null==c?this.stagedSegmentLength=
this.geodesicStagedSegmentLength=null:(this.geodesicStagedSegmentLength=y.createLength(v.segmentLengthGeodesic(d,c),"meters"),this.stagedSegmentLength=y.createLength(this.unitNormalizer.normalizeDistance(v.segmentLengthEuclidean(d,c,this.unitNormalizer.spatialReference)),"meters"))}_updateMode(a){if(a===M.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let c=0;null!=this.geodesicPathLength&&(c+=this.geodesicPathLength.value);1E5<c&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=
a===M.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean");this._mode=a}}E.MeasurementDataManager=Y;Object.defineProperty(E,Symbol.toStringTag,{value:"Module"})});