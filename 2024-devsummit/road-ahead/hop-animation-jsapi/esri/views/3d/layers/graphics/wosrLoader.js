// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../../request ../../../../core/asyncUtils ../../../../core/byteSizeEstimations ../../../../core/Error ../../../../core/Logger ../../../../core/NestedMap ../../../../core/promiseUtils ../../../../core/Version ../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/Indices ../../../../support/requestImageUtils ../../webgl-engine/lib/Attribute ../../webgl-engine/lib/basicInterfaces ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/Texture ../../webgl-engine/lib/VertexAttribute ../../webgl-engine/materials/DefaultMaterial ../../../webgl/enums".split(" "),
function(w,Q,F,R,S,T,U,G,H,I,z,V,W,X,p,Y,Z,J,aa,K){async function ba(a,b){const c=b?.streamDataRequester;if(c)return ca(a,c,b);a=await F.result(Q(a,b));if(!0===a.ok)return a.value.data;G.throwIfAbortError(a.error);L(a.error)}async function ca(a,b,c){a=await F.result(b.request(a,"json",c));if(!0===a.ok)return a.value;G.throwIfAbortError(a.error);L(a.error.details.url)}function L(a){throw new S("",`Request for object resource failed: ${a}`);}function da(a){var b=a.params,c=b.topology;let d=!0;b.vertexAttributes||
(l().warn("Geometry must specify vertex attributes"),d=!1);switch(b.topology){case "PerAttributeArray":break;case "Indexed":case null:case void 0:c=b.faces;if(!c)l().warn("Indexed geometries must specify faces"),d=!1;else if(b.vertexAttributes)for(const f in b.vertexAttributes)b=c[f],b?.values?(null!=b.valueType&&"UInt32"!==b.valueType&&(l().warn(`Unsupported indexed geometry indices type '${b.valueType}', only UInt32 is currently supported`),d=!1),null!=b.valuesPerElement&&1!==b.valuesPerElement&&
(l().warn(`Unsupported indexed geometry values per element '${b.valuesPerElement}', only 1 is currently supported`),d=!1)):(l().warn(`Indexed geometry does not specify face indices for '${f}' attribute`),d=!1);break;default:l().warn(`Unsupported topology '${c}'`),d=!1}a.params.material||(l().warn("Geometry requires material"),d=!1);a=a.params.vertexAttributes;for(const f in a)a[f].values||(l().warn("Geometries with externally defined attributes are not yet supported"),d=!1);return d}function ea(a){const b=
z.empty();a.forEach(c=>{c=c.boundingInfo;null!=c&&(z.expandWithVec3(b,c.bbMin),z.expandWithVec3(b,c.bbMax))});return b}async function M(a,b){const c=[];for(const n in a){var d=a[n],f=d.images[0].data;if(!f){l().warn("Externally referenced texture data is not yet supported");continue}f=d.encoding+";base64,"+f;const q="/textureDefinitions/"+n,t="rgba"===d.channels?d.alphaChannelUsage||"transparency":"none",x={noUnpackFlip:!0,wrap:{s:K.TextureWrapMode.REPEAT,t:K.TextureWrapMode.REPEAT},preMultiplyAlpha:N(t)!==
p.AlphaDiscardMode.Opaque};d=null!=b&&b.disableTextures?Promise.resolve(null):W.requestImage(f,b);c.push(d.then(A=>({refId:q,image:A,parameters:x,alphaChannelUsage:t})))}a=await Promise.all(c);b={};for(const n of a)b[n.refId]=n;return b}function N(a){switch(a){case "mask":return p.AlphaDiscardMode.Mask;case "maskAndTransparency":return p.AlphaDiscardMode.MaskBlend;case "none":return p.AlphaDiscardMode.Opaque;case "transparency":return p.AlphaDiscardMode.Blend;default:return p.AlphaDiscardMode.Blend}}
function fa(a){a=a.params;return{id:1,material:a.material,texture:a.texture,region:a.texture}}const l=()=>T.getLogger("esri.views.3d.layers.graphics.objectResourceUtils"),ha=new H.Version(1,2,"wosr");w.createTextureResources=M;w.load=async function(a,b){a=await ba(a,b);b=await M(a.textureDefinitions??{},b);let c=0;for(const d in b)if(b.hasOwnProperty(d)){const f=b[d];c+=f?.image?f.image.width*f.image.height*4:0}return{resource:a,textures:b,size:c+R.estimateNestedObjectSize(a)}};w.processLoadResult=
function(a,b){const c=[],d=[],f=[],n=new U.NestedMap,q=a.resource;var t=H.Version.parse(q.version||"1.0","wosr");ha.validate(t);t=q.model.name;const x=q.model.geometries,A=q.materialDefinitions??{};a=a.textures;let O=0;const B=new Map;for(let C=0;C<x.length;C++){const v=x[C];if(!da(v))continue;var r=fa(v),g=v.params.vertexAttributes;const D=[];var h=m=>{if("PerAttributeArray"===v.params.topology)return null;const y=v.params.faces;for(const P in y)if(P===m)return y[P].values;return null},k=g[J.VertexAttribute.POSITION];
k=k.values.length/k.valuesPerElement;for(const m in g){var e=g[m],u=e.values,E=h(m)??V.getContinuousIndexArray(k);D.push([m,new X.Attribute(u,E,e.valuesPerElement,!0)])}g=r.texture;if((h=a&&a[g])&&!B.has(g)){const {image:m,parameters:y}=h;k=new Z.Texture(m,y);d.push(k);B.set(g,k)}k=(k=B.get(g))?k.id:void 0;r=r.material;e=n.get(r,g);null==e&&(e=r.substring(r.lastIndexOf("/")+1),e=A[e].params,1===e.transparency&&(e.transparency=0),u=h&&h.alphaChannelUsage,u=0<e.transparency||"transparency"===u||"maskAndTransparency"===
u,E=h?N(h.alphaChannelUsage):void 0,h={ambient:I.fromArray(e.diffuse),diffuse:I.fromArray(e.diffuse),opacity:1-(e.transparency||0),transparent:u,textureAlphaMode:E,textureAlphaCutoff:.33,textureId:k,initTextureTransparent:!0,doubleSided:!0,cullFace:p.CullFaceOptions.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:h?.parameters.preMultiplyAlpha??!1},b?.materialParameters&&Object.assign(h,b.materialParameters),e=new aa.DefaultMaterial(h),n.set(r,g,e));f.push(e);g=new Y.Geometry(e,
D);O+=D.find(m=>m[0]===J.VertexAttribute.POSITION)?.[1]?.indices.length??0;c.push(g)}return{engineResources:[{name:t,stageResources:{textures:d,materials:f,geometries:c},pivotOffset:q.model.pivotOffset,numberOfVertices:O,lodThreshold:null}],referenceBoundingBox:ea(c)}};Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});