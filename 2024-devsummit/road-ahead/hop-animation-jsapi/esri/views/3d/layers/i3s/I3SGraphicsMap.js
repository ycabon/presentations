// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/Evented","../../../../core/MapUtils"],function(l,m,n){class p extends m{constructor(a,d){super();this._updateAndCompare=a;this._notifyUpdated=d;this._nodes=new Map;this._graphics=new Map;this._duplicates=new Map}clear(){if(0<this._graphics.size){const a=this.toArray();this._graphics.clear();this.emit("change",{added:[],removed:a})}this._nodes.clear()}get length(){return this._graphics.size}get(a){return this._graphics.get(a)}getNode(a){return this._nodes.get(a)}hasNode(a){return this._nodes.has(a)}nodes(){return this._nodes.values()}addNode(a,
d){this._nodes.set(a,d);const e=d.graphics;if(0!==e.length){var f=new Set;for(let b=0;b<e.length;b++){var c=e[b];const g=c.objectId,h=this._graphics.get(g);h?(f.add(g),c!==h&&(e[b]=h),(c=this._duplicates.get(g))?c.push(a):this._duplicates.set(g,[h.nodeIndex,a])):(c.nodeIndex=a,this._graphics.set(g,c))}f.size&&this._updateForeignGraphics(d);a=0<f.size?e.filter(b=>!f.has(b.objectId)):e;0<a.length&&this.emit("change",{added:a,removed:[]})}}removeNode(a){var d=this._nodes.get(a);if(d){this._nodes.delete(a);
var e=new Set,f=[];for(const g of d.graphics){d=g.objectId;var c=this._graphics.get(d);if(!c)continue;const h=this._duplicates.get(d);if(h){var b=h.indexOf(a);if(-1===b)console.error("error: removing graphic from node that should not reference it.");else{h.splice(b,1);if(c.nodeIndex===a){c=this.getNode(h[0]);for(b=1;b<h.length;b++){const k=this.getNode(h[b]);if(null==c||null!=k&&k.node.level>c.node.level)c=k}null!=c&&e.add(c)}1===h.length&&this._duplicates.delete(d)}}else this._graphics.delete(d),
f.push(g)}0<f.length&&this.emit("change",{added:[],removed:f});e.forEach(g=>this._updateForeignGraphics(g))}else console.error("Removing unknown node")}_updateForeignGraphics(a){const d=[],e=a.node.index,f=a.node.level;let c=0;for(;c<a.graphics.length;){var b=a.graphics[c].nodeIndex;if(b===e){c++;continue}let g=1;for(;c+g<a.graphics.length&&a.graphics[c+g].nodeIndex===b;)g++;b=this.getNode(b);if(!(null!=b&&b.node.level>f))for(b=c;b<c+g;b++){const h=a.graphics[b];h.nodeIndex=e;this._updateAndCompare(h,
a,b)&&d.push(h)}c+=g}this._notifyUpdated(d)}toArray(){return Array.from(this._graphics.values())}find(a){let d=void 0;n.someMap(this._graphics,e=>a(e)?(d=e,!0):!1);return d}forEach(a){this._graphics.forEach(d=>a(d))}forEachNode(a){this._nodes.forEach((d,e)=>a(d,e))}get nodeCount(){return this._nodes.size}_checkInvariants(){const a=new Map;this._nodes.forEach((e,f)=>{f!==e.node.index&&console.error("Mismatched node index");e.graphics.forEach(c=>{a.set(c.objectId,1+(a.get(c.objectId)??0));const b=this._duplicates.get(c.objectId);
b&&!b.includes(f)&&console.error("Node not listed in duplicate list");b||c.nodeIndex===f||console.error("Unique graphic does not reference owning node index")})});this._graphics.size!==a.size&&console.error("Mismatch between actual and expected number of graphics");let d=0;a.forEach((e,f)=>{d+=1<e?1:0;const c=this._graphics.get(f);if(c){var b=this._nodes.get(c.nodeIndex);b?(f=this._duplicates.get(f))?(f.length!==e&&console.error("Wrong number of entries in duplicate list"),f.forEach(g=>{(g=this._nodes.get(g))?
g.node.level>b.node.level&&console.error("Duplicated graphic does not reference highest level node"):console.error("Unknown node in duplicate list")})):1<e&&console.error("Missing duplicates entry"):console.error("Graphic references unkown node")}else console.error("Missing graphic entry")});this._duplicates.size!==d&&console.error("Mismatch between expected and actual number of duplicate entries")}}l.I3SGraphicsMap=p;Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})});