// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../../../core/asyncUtils ../../../../core/has ../../../../core/lang ../../../../core/promiseUtils ../../../../core/urlUtils ./enums ./I3SBinaryReader ./I3SMaterialUtil".split(" "),function(q,z,A,B,w,t,x,u){class v{constructor(a,b,g,c,d,e){this._streamDataController=b;this._logger=g;this._defaultGeometrySchema=c;this._requiredAttributes=d;this._options=e;this._logLayer=a;this._layerUrl=a.parsedUrl.path;this._geometryDefinitions=a.geometryDefinitions;if(a.materialDefinitions){const f=a.textureSetDefinitions;
this._materialAndTextures=a.materialDefinitions.map(h=>u.getMaterialAndTextures(f,h,"integrated-mesh"===a.type))}}_load(a,b,g){return this._streamDataController.request(a,b,g)}_loadAttribute(a,b,g){return this._load(`${this._layerUrl}/nodes/${a.resources.attributes}/attributes/${b.key}/0`,"binary",g).then(c=>x.readBinaryAttribute(b,c))}async loadAttributes(a,b,g){const c=await Promise.allSettled(b.map(f=>this._loadAttribute(a,f.attributeStorageInfo,g))),d={};for(let f=0;f<b.length;++f){var e=c[f];
const h=b[f];"fulfilled"===e.status?d[h.name]=e.value:(e=e.reason,B.throwIfAbortError(e),this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${h.name}' on node '${a.id}'`,e))}return d}async loadNodeData(a,b){var g=null!=this._requiredAttributes&&a.resources.attributes?q.result(this.loadAttributes(a,this._requiredAttributes,b)):null;var c=this._geometryDefinitions;var d={bufferDefinition:null,bufferIndex:0};var e=a.resources.geometryDefinition;if(!(null==c||null==
e||0>e)&&(c=0<=e?c[e].geometryBuffers:null,null!=c))for(e=0;e<c.length;e++){var f=c[e];if(null!=f.compressedAttributes){if("draco"===f.compressedAttributes.encoding&&!z("disable-feature:i3s-draco")){d.bufferIndex=e;d.bufferDefinition=f;break}}else d.bufferIndex=e,d.bufferDefinition=c[e]}const {bufferDefinition:h,bufferIndex:m}=d;e=(f=!!a.resources.geometry)?q.result(this._loadGeometry(a.resources.geometry,m,b)):null;c=a.resources.hasSharedResource?await this._loadShared(a,b):null;d=a.resources.materialDefinition;
d=this._materialAndTextures&&null!=d&&0<=d?this._materialAndTextures[d]:null!=c?u.getMaterialAndTexturesFromShared(c):null;var n=d?.material;d=d?.textures??[];const r=`${a.id}`,y=!f&&this._options.loadFeatureData;f=y?await this._loadFeatureData(r,b):null;if(y)a:{if(f)for(k of f.featureData)if(n=k.geometries,null!=n)for(var p of n){var k={featureIds:[k.id],featureDataPosition:k.position,geometries:[p]};break a}k=null}else k={featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:n}}],featureDataPosition:[0,
0,0]};if(null==k)if(f){p=[];for(l of f.featureData)null!=l.position&&p.push({featureIds:[l.id],featureDataPosition:l.position,geometries:[]});var l=p}else l=null;else l=null;p=0<d.length?q.result(this.loadTextures(a,d,b)):null;b=a=null;e&&(a=q.assertResult(await e),(b=this._defaultGeometrySchema)&&c?.materialDefinitions&&(e=Object.keys(c.materialDefinitions)[0],!c.materialDefinitions[e].params.vertexRegions&&b.vertexAttributes.region&&(b=A.clone(b),delete b.vertexAttributes.region)),b=x.createGeometryDescriptor(h,
b));c=p?q.assertResult(await p):null;g=(g=g?q.assertResult(await g):{})?{attributeData:g,loadedAttributes:this._requiredAttributes}:null;if(null!=k)return{geometryData:k,attributeDataInfo:g,geometryBuffer:a,geometryDescriptor:b,requiredTextures:d,textureData:c};if(null!=l)return{pointData:l,attributeDataInfo:g,geometryBuffer:a,geometryDescriptor:b,requiredTextures:d,textureData:c};throw Error();}static _addAbsoluteHrefTexture(a,b){a=a.textureDefinitions;if(null!=a)for(const g of Object.keys(a))for(const c of a[g].images)Array.isArray(c.href)?
c.hrefConcat=c.href.map(d=>w.makeAbsolute(d,b)):c.hrefConcat=w.makeAbsolute(c.href,b)}static _fixTextureEncodings(a){a=a.textureDefinitions;if(null!=a)for(const g in a){const c=a[g];if(Array.isArray(c.encoding))for(var b=0;b<c.encoding.length;b++){const d=c.encoding[b];"data:"===d.substring(0,5)&&(c.encoding[b]=d.substring(5))}else b=c.encoding,"data:"===b.substring(0,5)&&(c.encoding=b.substring(5))}}async _loadShared(a,b){if(null==a.resources.geometry)return{};a=`${this._layerUrl}/nodes/${a.resources.geometry}/shared`;
b=await this._load(a,"json",b);v._fixTextureEncodings(b);v._addAbsoluteHrefTexture(b,a);return b}_loadTexture(a,b,g,c,d,e){let f=!1;return d===t.TextureEncoding.DDS_S3TC||d===t.TextureEncoding.KTX2||d===t.TextureEncoding.Basis?this._load(a,"binary",e).then(h=>({id:b,usage:g,data:h,encoding:d,downsampled:f})):this._load(a,"image",e).then(h=>{var m=h;if(c&&4096<=h.width*h.height){m=Math.ceil(h.width/2);const n=Math.ceil(h.height/2),r=document.createElement("canvas");r.width=m;r.height=n;r.getContext("2d").drawImage(h,
0,0,m,n);m=r;f=!0}return{id:b,usage:g,data:m,encoding:d,downsampled:f}})}loadTextures(a,b,g){const c=!!this._options.uncompressedTextureDownsamplingEnabled,d=this._options.textureUsageMask;return Promise.all(b.map(e=>{if(0===(e.usage&d))return null;const f=u.selectEncoding(e.encodings,this._options.textureEncodings);return null==f?(this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${a.id}`),Promise.reject()):this._loadTexture(`${this._layerUrl}/nodes/${a.resources.texture||
a.id}/textures/${f.name}`,e.id,e.usage,c,f.encoding,g)}))}_loadFeatureData(a,b){return this._load(`${this._layerUrl}/nodes/${a}/features/0`,"json",b)}_loadGeometry(a,b,g){return this._load(`${this._layerUrl}/nodes/${a}/geometries/${b}`,"binary",g)}}return v});