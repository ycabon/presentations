// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../Camera ../../../Viewpoint ../../../core/Error ../../../core/promiseUtils ../../../core/reactiveUtils ../camera/constraintUtils ../camera/constraintUtils/surfaceCollision ./controllers/CameraController ./controllers/PointToPointAnimationController ./controllers/SurfaceCollisionCorrectionController ../support/cameraUtils ../support/viewpointUtils".split(" "),function(l,p,q,h,m,r,t,n,f,k,u,v,w){class x{constructor(a,b,c){this.target=a;this.options=b;this.view=c;this.state="pending";
this._animationController=null;this.promise=new Promise((e,g)=>{this._resolveCallback=e;this._rejectCallback=g;e=new AbortController;if(null!=this.options.signal)m.onAbort(this.options.signal,()=>{this.abort()});this._abortController=e;this.waitForReady()})}resolve(a){if("finished"!==this.state)return this.state="finished",this._resolveCallback(a)}reject(a){if("finished"!==this.state)return this.state="finished",this._rejectCallback(a)}abort(a=!1){this._abortController.abort();switch(this.state){case "wait-for-animation-finish":!a&&
null!=this._animationController&&this.view.state.cameraController===this._animationController&&this._animationController.active&&this._animationController.stopController()}this.reject(m.createAbortError())}async waitForReady(){this.state="wait-for-ready";if(!this.view.ready)try{await r.whenOnce(()=>this.view.ready,this._abortController.signal)}catch(a){return this.reject(a)}this.createViewPoint()}async createViewPoint(){if("finished"!==this.state){this.state="wait-for-viewpoint";this._animationController=
this.options.animate?this._getAnimationController():null;try{const b=await w.create(this.view,this.target,this._abortController.signal);if("finished"!==this.state){var a=b?this._getCameraFromViewpoint(b):null;null!=a&&(this.options.animate?null!=this._animationController&&this.startAnimation(a,this._animationController):(this.view.stateManager.setStateCamera(a.camera,{applyConstraints:!a.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve()))}}catch(b){this.reject(b)}}}_getCameraFromViewpoint(a){const b=
!!(this.target instanceof q&&this.target.camera||this.target instanceof p);var c=a.camera;if(null==c)return null;if(!this.view.stateManager.isCompatible(c))return a=(a=c.position)&&a.spatialReference,this.reject(new h("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a?a.wkid:"none"}, view: ${this.view.spatialReference?.wkid})`,{camera:c})),null;c=v.externalToInternal(this.view,c);return null==c?(this.reject(new h("GotoAnimation:invalid-camera",
"Resulting camera is invalid")),null):{viewpoint:a,camera:c,isFullySpecified:b}}startAnimation(a,b){this.state="wait-for-animation-finish";const c=b.viewAnimation;if(null==c)this.reject(new h("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));else{c.update(a.viewpoint,"running");if(!b.active||null==b.viewAnimation||b.viewAnimation.target!==a.viewpoint||this.view.state.cameraController!==b)return this.abort();if(a.isFullySpecified){var e=new u.SurfaceCollisionCorrectionController({view:this.view,
desiredCamera:a.camera});n.applySurfaceCollisionConstraint(this.view,a.camera,n.Mode.EYE_AND_CENTER)}else t.applyAll(this.view,a.camera);b.begin(a.camera,this.options);var g=d=>{if(null!=this.view.state)switch(b.state){case f.State.Finished:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.resolve()}break;case f.State.Ready:case f.State.Rejected:case f.State.Running:case f.State.Stopped:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.reject(d)}}};
c.when(()=>{const d=this.view.state.cameraController;e&&(d&&d.active?d instanceof k.PointToPointAnimationController&&null!=d.viewAnimation&&d.viewAnimation.target===a.viewpoint&&(this.view.state.cameraController=e):null!=b.viewAnimation&&b.viewAnimation.target===a.viewpoint&&b.state===f.State.Finished&&(this.view.state.cameraController=e))},d=>g(d));b.asyncResult={resolve:()=>g(),reject:d=>g(d)}}}_getAnimationController(){let a=null;var b=null;b=this.view.state.cameraController;b instanceof k.PointToPointAnimationController&&
(b.updateStateFromViewAnimation(),b.active&&(a=b,b=a.viewAnimation));return null!=a||(a=new k.PointToPointAnimationController({view:this.view,mode:"animation"}),b=a.viewAnimation,this.view.state.switchCameraController(a))?a:(null!=b&&b.stop(),this.reject(new h("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)}}l.GoToOperation=x;Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})});