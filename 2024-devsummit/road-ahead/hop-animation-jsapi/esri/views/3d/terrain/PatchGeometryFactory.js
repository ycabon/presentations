// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ./ElevationData ./interfaces ./ITile ./PatchGeometry ./PatchGeometryLUT ./PatchRenderData ./terrainUtils ./Tile ./tileUtils ../webgl-engine/lib/Normals".split(" "),function(mb,G,mc,$c,ja,Ib,nc,jb,ad,Jb,O,oc,Kb,Lb){function bd(a,b,d){const {tile:e,localOrigin:f,geometry:m}=a,{extent:l,ellipsoid:k}=e,{boundingBox:h,numVerticesPerSide:n,vertexAttributes:r,poleVerticesStartIndex:t}=
m,p=n-1,x=f[0],D=f[1],E=f[2],P=k.radius,ka=l[1],Z=l[3],M=[];let K=t;a=(L,R)=>{R*=n;eb(-x,-D,-E+L*P,h);M.push({connectedRowOffset:R,connectedOuterEdgeOffset:1===L?0:2,rowOffset:K,latitudeResolution:6});R=Math.PI/2-2*Math.atan(Math.exp(-(-1===L?ka:Z)/P));const Aa=L*Math.PI/2-R;L=.99*(1===L?1:-1);const da=P+0,{position:aa,uv0:U}=r,{typedBuffer:X,typedBufferStride:va}=r.normalCompressed;for(let w=1;6>=w;++w){var ea=R+w/6*Aa;const B=Math.cos(ea);ea=Math.sin(ea);for(let F=0;F<=p;F++){const N=F/p,z=Ja.cosLonLUT[F]*
B,g=Ja.sinLonLUT[F]*B,ba=ea,H=z*da-x,fa=g*da-D,ca=ba*da-E;eb(H,fa,ca,h);aa.setValues(K,H,fa,ca);jb.encodeUVInBuffer(U,K,N,L);Lb.compressNormal(X,K,z,g,ba,va);++K}}};b&&a(-1,0);d&&a(1,p);return M}function Qb(a){a.tile.intersectsClippingArea&&(Mb(a),pc(a))}function pc(a,b=!1){const {geometry:d,geometryState:e,tile:f,localOrigin:m}=a,{level:l,extent:k,extentInRadians:h,ellipsoid:n}=f,r=n.radius,t=h[0],p=h[2],x=h[1],D=h[3],{samplerData:E}=e,P=k[0],ka=k[2],Z=k[1],M=k[3],K=Rb(a),{boundingBox:L,vertexAttributes:R}=
d,Aa=m[0],da=m[1],aa=m[2];var U=R.position;const X=U.typedBuffer,va=U.typedBufferStride,ea=R.uv0;for(let z=0;4>z;++z){const g=1===z||3===z;U=e.edgeResolutions[z];O.internalAssert(G.isPowerOfTwo(U));const ba=U+1;var w=Jb.neighborTileIfLoadedOrSelf(f,e.edgePeerNeighbors[z]);if(qc(f,w,z)){rc(a,z,w);continue}const H=null!=w;O.internalAssert(!H||w.level===f.level);O.internalAssert(!H||0>=Kb.compareTilesByLij(f,w));var B=w?.renderData?.geometryState;if(O.enableTerrainInternalChecks){var F=f.surface;if(!w&&
F&&!F.updatingRootTiles){var N=O.neighborEdgeIndices[z];const u=f.findNeighborTile(N,I=>I.isLoaded||I.isLeaf||I.level===f.level);u?u.intersectsClippingArea&&(O.internalAssert(!u.isLoaded),O.internalAssert(!u.isLeaf),O.internalAssert(u.level===l)):O.internalAssert(null==F?.rootTiles||!f.shouldHaveNeighbor(N))}}const fa=1===z?k[2]:k[0],ca=(w=w?.extent)&&g?1===z?w[0]:w[2]:fa,qa=0===z?k[3]:k[1],Fa=1===z?1:0,Y=0===z?1:0,ha=1===z?p:t,ra=0===z?D:x,Ga=Math.sin(ha),Na=Math.cos(ha),Ha=Math.sin(ra),S=Math.cos(ra),
c=B?.samplerData;B=(u,I,Q)=>ja.sampleElevation(u,I,E);F=(u,I,Q)=>.5*(ja.sampleElevation(u,I,E)+ja.sampleElevation(Q,I,c));const y=H?F:B;B=d.outerEdgesOffsetAndLength[2*z];const v=b&&3<ba?ba-3:1;F=null!=E&&E.some(u=>null!=u);N=null!=c&&c.some(u=>null!=u);const q=F||N,A=1/U,C=B;O.internalAssert(!w||O.almostEquals(w[2]-w[0],k[2]-k[0]));(()=>{const u=1===z?-1:3===z?1:0,I=0===z?-1:2===z?1:0,Q=(k[2]-k[0])*A,wa=u*Q,xa=I*Q,Ua=p-t,Va=g?u*Ua*A:0,Oa=g?0:I*A,Ba=Y,na=g?ha+Va:ha,Ia=g?Math.sin(na):Ga,Ca=g?Math.cos(na):
Na,la=g?ha-Va:ha,sa=g?Math.sin(la):Ga,V=g?Math.cos(la):Na,T=g?ra:K(Ba+Oa),oa=g?Ha:Math.sin(T),Ka=g?S:Math.cos(T),ya=g?ra:K(Ba-Oa),$a=g?Ha:Math.sin(ya),Ra=g?S:Math.cos(ya);let ab=0,Sa=0,bb=0;const Da=0*A,Wa=g?fa:P*(1-Da)+ka*Da,cb=g?ca:Wa,db=g?Z*(1-Da)+M*Da:qa,Ta=g?ha:t*(1-Da)+p*Da,Xa=g?Ga:Math.sin(Ta),Ya=g?Na:Math.cos(Ta),Pa=g?K(Da):ra,Qa=g?Math.sin(Pa):Ha,La=g?Math.cos(Pa):S,ma=r+y(Wa,db,cb);ab=Ya*La*ma;Sa=Xa*La*ma;bb=Qa*ma;let pa=0,ta=0,ua=0;const W=1*A,za=g?fa:P*(1-W)+ka*W,Ea=g?ca:za,J=g?Z*(1-W)+
M*W:qa,ia=g?ha:t*(1-W)+p*W,Ma=g?Ga:Math.sin(ia),rb=g?Na:Math.cos(ia),hb=g?K(W):ra,fb=g?Math.sin(hb):Ha,nb=g?Math.cos(hb):S,gb=r+y(za,J,Ea);pa=rb*nb*gb;ta=Ma*nb*gb;ua=fb*gb;for(let Za=1;Za<ba-1;Za+=v){let ob=0,kb=0,pb=0;const ib=(Za+1)*A,vb=g?fa:P*(1-ib)+ka*ib,Nb=g?ca:vb,lb=g?Z*(1-ib)+M*ib:qa,qb=g?ha:t*(1-ib)+p*ib,wb=g?Ga:Math.sin(qb),tb=g?Na:Math.cos(qb),sb=g?K(ib):ra,xb=g?Math.sin(sb):Ha,Eb=g?Math.cos(sb):S,Sb=r+y(vb,lb,Nb);ob=tb*Eb*Sb;kb=wb*Eb*Sb;pb=xb*Sb;const sc=ob,tc=kb,uc=pb,Tb=pa,Ub=ta,Vb=
ua;pa=sc;ta=tc;ua=uc;const vc=C+Za,Wb=vc*va,wc=Tb-Aa,xc=Ub-da,yc=Vb-aa;X[Wb]=wc;X[Wb+1]=xc;X[Wb+2]=yc;eb(wc,xc,yc,L);const zc=Za*A;jb.encodeUVInBuffer(ea,vc,g?Fa:zc,g?zc:Y);const cd=ab,dd=Sa,ed=bb;ab=Tb;Sa=Ub;bb=Vb;const Fb=Tb,Gb=Ub,yb=Vb,Ob=1/Math.sqrt(Fb*Fb+Gb*Gb+yb*yb),Ac=yb*Ob;let zb=0,Ab=0,Bb=0;if(q&&.999>Ac*Ac){let Xb=0,Yb=0,Zb=0;const $b=0===z?-1:1;Xb=$b*(sc-cd);Yb=$b*(tc-dd);Zb=$b*(uc-ed);const ub=Za*A,Bc=g?fa:P*(1-ub)+ka*ub,fd=g?ca:Bc,Cc=g?Z*(1-ub)+M*ub:qa,Dc=g?ha:t*(1-ub)+p*ub,Ec=g?Ga:Math.sin(Dc),
Fc=g?Na:Math.cos(Dc),Gc=g?K(ub):ra,Hc=g?Math.sin(Gc):Ha,Ic=g?Math.cos(Gc):S;let ac=Fb,bc=Gb,cc=yb;if(H){const dc=r+ja.sampleElevation(fd-wa,Cc-xa,c),gd=g?sa:Ec,hd=g?Hc:$a,Jc=g?Ic:Ra;ac=(g?V:Fc)*Jc*dc;bc=gd*Jc*dc;cc=hd*dc}const ec=r+ja.sampleElevation(Bc+wa,Cc+xa,E),Kc=g?Ic:Ka,Lc=(g?Ca:Fc)*Kc*ec,Mc=(g?Ia:Ec)*Kc*ec,Nc=(g?Hc:oa)*ec;H||(ac=2*Fb-Lc,bc=2*Gb-Mc,cc=2*yb-Nc);const fc=3===z?-1:1,Oc=fc*(ac-Lc),Pc=fc*(bc-Mc),Qc=fc*(cc-Nc);zb=Zb*Pc-Yb*Qc;Ab=Xb*Qc-Zb*Oc;Bb=Yb*Oc-Xb*Pc;const gc=1/Math.sqrt(zb*zb+
Ab*Ab+Bb*Bb);zb*=gc;Ab*=gc;Bb*=gc}else zb=Fb*Ob,Ab=Gb*Ob,Bb=yb*Ob;d.setEdgeNormalFromValues(z,Za,zb,Ab,Bb)}})()}}function Rb(a){({tile:a}=a);if(a.surface.isWebMercator){const d=a.extent,e=a.ellipsoid.radius;return f=>Math.PI/2-2*Math.atan(Math.exp(-(d[1]*(1-f)+d[3]*f)/e))}const b=a.extentInRadians;return d=>b[1]*(1-d)+b[3]*d}function hc(a,b){a.tile.intersectsClippingArea&&(Mb(a),Rc(a,!1))}function Rc(a,b){const {geometry:d,geometryState:e,tile:f,localOrigin:m}=a,{surface:l,extent:k}=f,{clippingArea:h,
samplerData:n}=e,r=null!=h?h:ic,t=k[0],p=k[2],x=k[1],D=k[3],E=[D>r[3],p>r[2],x<r[1],t<r[0]],P=f.horizontalScale,ka=Sc(l.isWebMercatorOnPlateCarree,f.ellipsoid.radius,P),{minu:Z,minv:M,maxu:K,maxv:L,boundingBox:R}=d,Aa=Math.max(t,r[0]),da=Math.min(p,r[2]),aa=Math.max(x,r[1]),U=Math.min(D,r[3]),X=m[0],va=m[1],ea=m[2];for(let w=0;4>w;++w){const B=1===w||3===w,F=e.edgeResolutions[w];O.internalAssert(G.isPowerOfTwo(F));const N=F+1,z=E[w],g=Jb.neighborTileIfLoadedOrSelf(f,e.edgePeerNeighbors[w]);if(!z&&
qc(f,g,w)){rc(a,w,g);continue}const ba=null!=g&&!z,H=g?.renderData?.geometryState;if(O.enableTerrainInternalChecks&&(O.internalAssert(!ba||g.level===f.level),O.internalAssert(!ba||0>=Kb.compareTilesByLij(f,g)),f&&!g&&!l.updatingRootTiles)){const V=O.neighborEdgeIndices[w],T=f.findNeighborTile(V,oa=>oa.isLoaded||oa.isLeaf||oa.level===f.level);l.updatingRootTiles||(T?T.intersectsClippingArea&&(O.internalAssert(!T.isLoaded),O.internalAssert(!T.isLeaf),O.internalAssert(T.level===f.level)):O.internalAssert(null==
l?.rootTiles||!f.shouldHaveNeighbor(V)))}const fa=G.clamp(1===w?p:t,Aa,da),ca=G.clamp(0===w?D:x,aa,U),qa=H?.samplerData,Fa=b&&3<N?N-3:1,Y=G.clamp(1===w?1:0,Z,K),ha=G.clamp(0===w?1:0,M,L),ra=(V,T)=>ja.sampleElevation(V,T,n),Ga=(V,T)=>.5*(ja.sampleElevation(V,T,qa)+ja.sampleElevation(V,T,n)),Na=ba?Ga:ra,Ha=(p-t)/F,S=B?1===w?Ha:-Ha:0,c=B?0:0===w?Ha:-Ha,y=-S,v=-c;let q=0,A=0,C=0;const u=0/F,I=B?fa:G.clamp(t*(1-u)+p*u,Aa,da),Q=B?G.clamp(x*(1-u)+D*u,aa,U):ca,wa=Na(I,Q);q=I*P;A=ka(Q);C=wa;let xa=0,Ua=0,
Va=0;const Oa=1/F,Ba=B?fa:G.clamp(t*(1-Oa)+p*Oa,Aa,da),na=B?G.clamp(x*(1-Oa)+D*Oa,aa,U):ca,Ia=Na(Ba,na),Ca=Ba*P,la=ka(na),sa=Ia;xa=Ca;Ua=la;Va=sa;for(let V=1;V<N-1;V+=Fa){const T=V/F,oa=xa,Ka=Ua,ya=Va,$a=B?Y:G.clamp(T,Z,K),Ra=B?G.clamp(T,M,L):ha,ab=oa-X,Sa=Ka-va,bb=ya-ea;eb(oa,Sa,bb,R);d.setEdgeVertexFromValuesRawPositionUV(w,V,ab,Sa,bb,$a,Ra);const Da=(V+1)/F,Wa=B?fa:G.clamp(t*(1-Da)+p*Da,Aa,da),cb=B?G.clamp(x*(1-Da)+D*Da,aa,U):ca,db=Na(Wa,cb);xa=Wa*P;Ua=ka(cb);Va=db;const Ta=xa,Xa=Ua,Ya=Va,Pa=q,
Qa=A,La=C;q=oa;A=Ka;C=ya;let ma=0,pa=0,ta=0;if(B){const W=Xa-Ka,za=Ya-ya,Ea=Qa-Ka,J=La-ya,ia=G.clamp(x*(1-T)+D*T,aa,U),Ma=fa+y,rb=Ma*P,hb=ja.sampleElevation(Ma,ia,n),fb=rb-oa,nb=hb-ya,gb=3===w?-1:1;ma=gb*(-Ea+W)*nb;pa=gb*fb*(-J+za);ta=-gb*fb*(-Ea+W);if(ba){const Za=fa+S,ob=Za*P,kb=ja.sampleElevation(Za,ia,qa),pb=ob-oa;ma=(-Ea+W)*(nb-(kb-ya));pa=(fb-pb)*(-J+za);ta=-(fb-pb)*(-Ea+W)}}else{const W=Ta-oa,za=Ya-ya,Ea=Pa-oa,J=La-ya,ia=G.clamp(t*(1-T)+p*T,Aa,da),Ma=ca+v,rb=ja.sampleElevation(ia,Ma,n)-ya,
hb=ka(Ma)-Ka,fb=2===w?-1:1;ma=fb*hb*(-J+za);pa=fb*(-Ea+W)*rb;ta=-fb*hb*(-Ea+W);if(ba){const nb=ia,gb=ca+c,Za=ka(gb),ob=ja.sampleElevation(nb,gb,qa)-ya,kb=Za-Ka;ma=(-hb+kb)*(-J+za);pa=(-Ea+W)*(-rb+ob);ta=-(-hb+kb)*(-Ea+W)}}const ua=1/Math.sqrt(ma*ma+pa*pa+ta*ta);d.setEdgeNormalFromValues(w,V,ma*ua,pa*ua,ta*ua)}}}function Sc(a,b,d){return a?e=>(Math.PI/2-2*Math.atan(Math.exp(-e/b)))*b:e=>e*d}function Tc(a,b,d){const {numVerticesPerSide:e,vertexAttributes:f,maxEdgeVertexCount:m}=a,l=e-1;var k=f.count;
const h=2*(e-3)*(e-3);var n=4*(l+m-3);const r=Jb.zeroToFour.reduce((x,D)=>x+(l+a.getEdgeCount(D)-3),0),t=b.reduce((x,D)=>x+l*(2*(D.latitudeResolution-1)+1),0),p=3*(d?2:1);n=(h+n+t)*p;k=65536<=k?new Uint32Array(n):new Uint16Array(n);for(let x=0;x<n;++x)k[x]=0;a.indices=k;a.indexCount=(h+r+t)*p;a.poleIndicesStartIndex=h*p;a.edgeIndicesStartIndex=(h+t)*p;d?(id(a),jd(a,b),Uc(a)):(kd(a),ld(a,b),Vc(a))}function kd(a){const {numVerticesPerSide:b,indices:d,vertexAttributes:e}=a;({position:a}=e);const {typedBuffer:f,
typedBufferStride:m}=a;a=b-2;const l=b-3,k=b-3;let h=0;for(let n=0;n<l;++n){const r=n*a;for(let t=0;t<k;++t){const p=r+t,x=p+1,D=x+a,E=D-1;Wc(p,x,D,E,m,f)?(d[h]=p,d[h+1]=x,d[h+2]=D,d[h+3]=D,d[h+4]=E,d[h+5]=p):(d[h]=p,d[h+1]=x,d[h+2]=E,d[h+3]=E,d[h+4]=x,d[h+5]=D);h+=6}}}function ld(a,b){const {numVerticesPerSide:d,indices:e,poleIndicesStartIndex:f}=a,m=d-1;let l=f;for(const k of b){b=a.getEdgeVertexIndex(k.connectedOuterEdgeOffset,0);let h=1;for(let n=0;n<k.latitudeResolution;++n){const r=0===n?k.rowOffset:
b+d;for(let t=0;t<m;t++){const p=r+t;e[l]=b;e[l+1]=b+1;e[l+2]=p;n<k.latitudeResolution-1?(e[l+3]=b+1,e[l+4]=p+1,e[l+5]=p,l+=6):l+=3;b+=h}b=r;h=1}}}function Vc(a){const {indices:b,numVerticesPerSide:d,edgeIndicesStartIndex:e}=a,f=d-1,m=f-2;let l=e;for(let r=0;4>r;++r){var k=jc[r];let t=0,p=0;const x=a.getEdgeCount(r),D=k.count;O.internalAssert(D===f-1);var h=1===r||2===r;const E=h?1:2;h=h?2:1;const P=a.getEdgeFirstVertexIndex(r),ka=k.vertex0Index;for(k=k.stride;t<x-1||p<D-1;){const Z=ka+p*k,M=P+1*
t;var n=t<x-1;const K=p<D-1,L=n?f*(t+.5)/(x-1):0,R=K?1+m*(p+.5)/(D-1):0;(n=n&&(!K||L<=R))?++t:++p;n=n?M+1:Z+k;b[l]=Z;b[l+E]=M;b[l+h]=n;l+=3}}a.indexCount=l}function id(a){const {indices:b,numVerticesPerSide:d,vertexAttributes:e}=a;({position:a}=e);const {typedBuffer:f,typedBufferStride:m}=a;a=d-2;let l=0;for(let k=0;k<d-3;++k){const h=k*a;for(let n=0;n<d-3;++n){const r=k*a+n,t=r+1,p=t+a,x=p-1,D=h+n,E=D+1,P=E+a;Wc(D,E,P,P-1,m,f)?(Cb(b,l,r,t,p),l+=6,Cb(b,l,p,x,r)):(Cb(b,l,r,t,x),l+=6,Cb(b,l,x,p,t));
l+=6}}}function jd(a,b){const {indices:d,numVerticesPerSide:e,poleIndicesStartIndex:f}=a,m=e-1;let l=f;for(const k of b){b=a.getEdgeVertexIndex(k.connectedOuterEdgeOffset,0);let h=1;for(let n=0;n<k.latitudeResolution;++n){const r=0===n?k.rowOffset:b+e;for(let t=0;t<m;t++)Cb(d,l,b,b+1,r+t),l+=6,n<k.latitudeResolution-1&&(Cb(d,l,b+1,r+t+1,r+t),l+=6),b+=h;b=r;h=1}}}function Uc(a){const {indices:b,numVerticesPerSide:d,edgeIndicesStartIndex:e}=a,f=d-1,m=f-2;let l=e;for(let r=0;4>r;++r){var k=jc[r];let t=
0,p=0;const x=a.getEdgeCount(r),D=k.count;O.internalAssert(D===f-1);var h=1===r||2===r;const E=h?1:3;h=h?3:1;const P=a.getEdgeFirstVertexIndex(r),ka=k.vertex0Index;for(k=k.stride;t<x-1||p<D-1;){const Z=ka+p*k,M=P+1*t;var n=t<x-1;const K=p<D-1,L=n?f*(t+.5)/(x-1):0,R=K?1+m*(p+.5)/(D-1):0;(n=n&&(!K||L<=R))?++t:++p;n=n?M+1:Z+k;b[l]=Z;b[l+E]=M;b[l+E+1]=M;b[l+h]=n;b[l+h+1]=n;b[l+5]=Z;l+=6}}a.indexCount=l}function kc(a){const {geometry:b,geometryState:d}=a;({edgeResolutions:a}=d);const {numVerticesPerSide:e,
edgeVerticesStartIndex:f}=b,m=e-2;let l=f;for(let h=0;4>h;++h){var k=0===h||2===h;k=(k?0:1)*m+(k?1:0);const n=jc[h];n.vertex0Index=(0===h?m-1:0)*m+(1===h?m-1:0);n.stride=k;n.count=m;k=a[h]+1;b.outerEdgesOffsetAndLength[2*h]=l;b.outerEdgesOffsetAndLength[2*h+1]=k;l+=k}}function Xc(a){kc(a);a.geometryState.wireframe?Uc(a.geometry):Vc(a.geometry)}function rc(a,b,d){var e=(b+2)%4;const {geometryState:f,geometry:m,tile:l,localOrigin:k}=a;var h=l.level-d.level;a=1===b||3===b;const n=f.edgeResolutions[b];
O.internalAssert(G.isPowerOfTwo(n));const r=n+1,{boundingBox:t,minu:p,minv:x,maxu:D,maxv:E,vertexAttributes:P}=m,ka=G.clamp(1===b?1:0,p,D),Z=G.clamp(0===b?1:0,x,E);var M=d.renderData,K=M.geometryState,L=M.geometry,R=L.getEdgeCount(e);d=l.getNeighborEdgeStartVertexIndex(b,d)*n;h=n*2**h;O.internalAssert(K.edgeResolutions[e]===h);O.internalAssert(R-1===h);K=M.localOrigin[0]-k[0];R=M.localOrigin[1]-k[1];M=M.localOrigin[2]-k[2];b=m.getEdgeFirstVertexIndex(b);var Aa=P.position;h=Aa.typedBuffer;Aa=Aa.typedBufferStride;
var da=P.normalCompressed;const aa=da.typedBuffer;da=da.typedBufferStride;const U=P.uv0;var X=L.vertexAttributes;e=L.getEdgeFirstVertexIndex(e);L=X.position.typedBuffer;const va=X.position.typedBufferStride,ea=X.normalCompressed.typedBuffer;X=X.normalCompressed.typedBufferStride;for(let N=1;N<r-1;++N){const z=b+N;var w=e+(d+N),B=z*Aa,F=w*va;const g=L[F]+K,ba=L[F+1]+R;F=L[F+2]+M;h[B]=g;h[B+1]=ba;h[B+2]=F;eb(g,ba,F,t);B=z*da;w*=X;aa[B]=ea[w];aa[B+1]=ea[w+1];B=N/n;w=a?ka:G.clamp(B,p,D);B=a?G.clamp(B,
x,E):Z;jb.encodeUVInBuffer(U,z,w,B)}}function Mb(a){const {geometry:b,geometryState:d,localOrigin:e,tile:f}=a,{clippingArea:m,samplerData:l}=d,{minu:k,minv:h,maxu:n,maxv:r,boundingBox:t,vertexAttributes:p}=b,{surface:x,ellipsoid:D,extent:E,extentInRadians:P,horizontalScale:ka}=f,Z="local"===x.view?.viewingMode,M=D.radius;let K=0,L=0,R=0;const Aa=()=>{const c=null!=m&&(E[3]>m[3]||E[2]>m[2]||E[1]<m[1]||E[0]<m[0]),y=Sc(x.isWebMercatorOnPlateCarree,M,ka);return(v,q,A)=>{v=0===v?E[0]:E[2];q=0===q?E[1]:
E[3];v=c?G.clamp(v,m[0],m[2]):v;q=c?G.clamp(q,m[1],m[3]):q;K=v*ka;L=y(q);R=A}},da=(c,y,v)=>{var q=P[0===y?1:3];c=P[0===c?0:2];y=Math.cos(q);q=Math.sin(q);const A=Math.sin(c);v=M+v;K=Math.cos(c)*y*v;L=A*y*v;R=q*v},aa=Z?Aa():da;let U=0,X=0,va=0,ea=0,w=0,B=0,F=0,N=0,z=0;const g=Z&&x.isWebMercatorOnPlateCarree,ba=(c,y,v,q,A)=>{var C=0,u=0;let I=0;Z?(v=g?(Math.PI/2-2*Math.atan(Math.exp(-v/M)))*M:v*ka,C=y*ka-K,u=v-L,I=q-R):(C=Rb(c),c=c.tile,u=c.extent,c=c.extentInRadians,y=(y-u[0])/(u[2]-u[0]),y=c[0]*(1-
y)+c[2]*y,C=C((v-u[1])/(u[3]-u[1])),v=Math.cos(C),c=Math.sin(C),u=Math.sin(y),q=M+q,C=Math.cos(y)*v*q-K,u=u*v*q-L,I=c*q-R);switch(A){case 0:F+=C;N+=u;z+=I;break;case 1:ea-=C;w-=u;B-=I;break;case 2:F-=C;N-=u;z-=I;break;case 3:ea+=C,w+=u,B+=I}},H=m??ic,fa=E[0],ca=E[2],qa=E[1],Fa=E[3],Y=[Fa>H[3],ca>H[2],qa<H[1],fa<H[0]],ha=Math.max(fa,H[0]),ra=Math.min(ca,H[2]),Ga=Math.max(qa,H[1]),Na=Math.min(Fa,H[3]),Ha=c=>{var y=d.cornerNeighborCornerTiles;X=U=0;va=1;z=N=F=B=w=ea=0;var v=Infinity;for(var q=0;4>q;++q)v=
Math.min(v,y[4*c+q]?.level??Infinity);for(q=0;4>q;++q){var A=y[4*c+q];Hb[q]=A?.level===v?A:null}c=1;y=0;for(v=0;4>v;++v)if(q=Hb[v])c=Math.max(c,q?.renderData.geometryState.numVerticesPerSide),y=q.extent[2]-q.extent[0];O.internalAssert(1<c);c=y/c;for(y=0;4>y;++y){A=Hb[(y+3)%4];var C=Hb[y%4];if(A||C){q=0===y?1:1===y?2:2===y?3:0;var u=0===y?2:1===y?3:2===y?0:1;if(A&&C){var I=lc[y][0]*c,Q=lc[y][1]*c,wa=A.extent;v=Math.max(H[0],Math.min(H[2],wa[0===q||1===q?2:0]+I));q=Math.max(H[1],Math.min(H[3],wa[0===
q||3===q?3:1]+Q));wa=C.extent;I=Math.max(H[0],Math.min(H[2],wa[0===u||1===u?2:0]+I));u=Math.max(H[1],Math.min(H[3],wa[0===u||3===u?3:1]+Q));A=A.renderData;Q=C.renderData;C=ja.sampleElevation(v,q,A.geometryState.samplerData);u=ja.sampleElevation(I,u,Q.geometryState.samplerData);ba(A,v,q,.5*(C+u),y)}else v=A??C,A=A?q:u,C=v.extent,u=lc[y],q=Math.max(H[0],Math.min(H[2],C[0===A||1===A?2:0]+u[0]*c)),A=Math.max(H[1],Math.min(H[3],C[0===A||3===A?3:1]+u[1]*c)),v=v.renderData,C=ja.sampleElevation(q,A,v.geometryState.samplerData),
ba(v,q,A,C,y)}}Z||(c=Math.sqrt(K*K+L*L+R*R),U=K/c,X=L/c,va=R/c);if(Z||.999>va*va)c=Math.sqrt(ea*ea+w*w+B*B),ea/=c,w/=c,B/=c,c=Math.sqrt(F*F+N*N+z*z),F/=c,N/=c,z/=c,U=B*N-w*z,X=ea*z-B*F,va=w*F-ea*N,c=1/Math.sqrt(U*U+X*X+va*va),U*=c,X*=c,va*=c},S=d.cornerNeighborCornerTiles;for(let c=0;4>c;++c){const y=c,v=(c+1)%4,q=0===c||1===c?1:0,A=0===c||3===c?1:0,C=G.clamp(q,k,n),u=G.clamp(A,h,r),I=b.getEdgeFirstVertexIndex(y),Q=b.getEdgeCount(y),wa=0===c||3===c?Q-1:0,xa=b.getEdgeFirstVertexIndex(v),Ua=b.getEdgeCount(v),
Va=0===c||1===c?Ua-1:0;let Oa=-1;for(let Ia=0;4>Ia;++Ia){const Ca=S[4*c+Ia],la=S[4*c+Oa];Ca&&(-1===Oa||0<Kb.compareTilesByLij(la,Ca))&&(Oa=Ia)}const Ba=Oa,na=S[4*c+Ba];if(na!==f){const Ia=f.level-na.level,Ca=2**Ia,la=[na.lij[0]+Ia,na.lij[1]*Ca,na.lij[2]*Ca],sa=[la[1]+Ca===f.lij[1],0===c&&(1===Ba||0===Ba&&na!==S[4*c+3])||1===c&&(0===Ba||1===Ba&&na!==S[4*c+2]),la[1]===f.lij[1]+1,2===c&&(3===Ba||2===Ba&&na!==S[4*c+1])||3===c&&(2===Ba||3===Ba&&na!==S[4*c])],V=sa.reduce((J,ia)=>J+(ia?1:0),0);O.internalAssert(1===
V||2===V);let T=-1,oa=-1;const Ka=na.renderData;if(1===V){const J=sa.findIndex(Ma=>Ma);O.internalAssert(0<=J&&3>=J);T=(J+2)%4;const ia=d.edgeResolutions[J];oa=f.getNeighborEdgeStartVertexIndex(J,na)*ia+ia*(0===J&&0===c||1===J&&0===c||2===J&&1===c||3===J&&3===c?1:0)}else{O.internalAssert(sa[1]||sa[3]);T=sa[1]?3:1;const J=Ka.geometryState.edgeResolutions[T];oa=0===c||3===c?0:J}const ya=Ka.geometry,$a=I+wa,Ra=xa+Va,ab=ya.getEdgeFirstVertexIndex(T)+oa,Sa=ya.vertexAttributes,bb=Ka.localOrigin,Da=Sa.position,
Wa=Da.typedBuffer,cb=ab*Da.typedBufferStride,db=Wa[cb]+bb[0]-e[0],Ta=Wa[cb+1]+bb[1]-e[1],Xa=Wa[cb+2]+bb[2]-e[2];eb(db,Ta,Xa,t);const Ya=p.position,Pa=Ya.typedBuffer,Qa=$a*Ya.typedBufferStride;Pa[Qa]=db;Pa[Qa+1]=Ta;Pa[Qa+2]=Xa;const La=Ra*Ya.typedBufferStride;Pa[La]=db;Pa[La+1]=Ta;Pa[La+2]=Xa;const ma=p.uv0;jb.encodeUVInBuffer(ma,$a,C,u);jb.encodeUVInBuffer(ma,Ra,C,u);const pa=Sa.normalCompressed.typedBuffer,ta=ab*Sa.normalCompressed.typedBufferStride,ua=p.normalCompressed,W=ua.typedBuffer,za=$a*ua.typedBufferStride;
W[za]=pa[ta];W[za+1]=pa[ta+1];const Ea=Ra*ua.typedBufferStride;W[Ea]=pa[ta];W[Ea+1]=pa[ta+1]}else{const Ia=Y[v];let Ca=void 0;if(Y[y]||Ia){const T=G.clamp(fa*(1-q)+ca*q,ha,ra),oa=G.clamp(qa*(1-A)+Fa*A,Ga,Na);Ca=ja.sampleElevation(T,oa,l)}else Ca=md(S,c);aa(q,A,Ca);Ha(c);const la=K-e[0],sa=L-e[1],V=R-e[2];eb(la,sa,V,t);b.setEdgeVertexFromValuesRawPositionUVNormal(y,wa,la,sa,V,C,u,U,X,va);b.setEdgeVertexFromValuesRawPositionUVNormal(v,Va,la,sa,V,C,u,U,X,va)}}for(let c=0;4>c;++c)Hb[c]=null}function md(a,
b){const d=4*b;b=Jb.zeroToFour.reduce((l,k)=>Math.min(l,a[d+k]?.level??Infinity),Infinity);O.enableTerrainInternalChecks&&(O.internalAssert(!a[d+0]||!a[d+2]||oc.isCornerNeighbor(a[d+0],a[d+2],nc.NeighborIndex.SOUTH_WEST)),O.internalAssert(!a[d+1]||!a[d+3]||oc.isCornerNeighbor(a[d+1],a[d+3],nc.NeighborIndex.NORTH_WEST)));let e=0,f=0;for(let l=0;4>l;++l){var m=a[d+l];if(m&&m.level===b){const k=m.extent;m=ja.sampleElevation(k[0===l||1===l?0:2],k[0===l||3===l?1:3],m.renderData?.geometryState?.samplerData);
f+=m;e++}}b=e?f/e:0;O.internalAssert(null!=b);return b}function Db(a){const {vao:b,geometry:d}=a,{vertexAttributes:e,edgeVerticesStartIndex:f}=d;a=e.position.typedBuffer;b.vertexBuffers.geometry.setSubData(a,f,f,a.length)}function Yc(a){const {vao:b,geometry:d}=a,{indices:e,indexCount:f,edgeIndicesStartIndex:m}=d;b.indexBuffer.setSubData(e,m,m,f)}function qc(a,b,d){if(!b)return!1;a=Kb.compareTilesByLij(a,b);return 0<a||0===a&&2<=d}function eb(a,b,d,e){a<e[0]?e[0]=a:a>e[3]&&(e[3]=a);b<e[1]?e[1]=b:
b>e[4]&&(e[4]=b);d<e[2]?e[2]=d:d>e[5]&&(e[5]=d)}function Zc(a){const {edgeResolutions:b,numVerticesPerSide:d}=a;a=1+Math.max(...b);return Math.max(d,a)}function Wc(a,b,d,e,f,m){var l=a*f;a=m[l];const k=m[l+1];l=m[l+2];var h=b*f;b=m[h];const n=m[h+1];h=m[h+2];var r=d*f;d=m[r];const t=m[r+1];r=m[r+2];const p=e*f;e=m[p];f=m[p+1];m=m[p+2];return(b-e)*(b-e)+(n-f)*(n-f)+(h-m)*(h-m)>(a-d)*(a-d)+(k-t)*(k-t)+(l-r)*(l-r)}function Cb(a,b,d,e,f){a[b]=d;a[b+1]=e;a[b+2]=e;a[b+3]=f;a[b+4]=f;a[b+5]=d}const lc=[[0,
1],[1,0],[0,-1],[-1,0]],Ja=new ad.PatchGeometryLUT,ic=$c.fromValues(-Infinity,-Infinity,Infinity,Infinity),Hb=[null,null,null,null];class Pb{constructor(){this.vertex0Index=0;this.stride=1;this.count=0}getVertexIndex(a){O.internalAssert(0<=a&&a<this.count);return this.vertex0Index+this.stride*a}}const jc=[new Pb,new Pb,new Pb,new Pb];mb.createPlanarGlobePatch=function(a,b){const {tile:d,geometryState:e,geometry:f}=a,{extent:m,surface:l}=d,{wireframe:k}=e,h=m[0],n=m[1],r=m[2]-h,t=m[3]-n,{numVerticesPerSide:p,
clippingArea:x}=e,D=null!=x?Math.max(0,(x[0]-h)/r):0,E=null!=x?Math.max(0,(x[1]-n)/t):0,P=null!=x?Math.min(1,(x[2]-h)/r):1,ka=null!=x?Math.min(1,(x[3]-n)/t):1,Z=(p-2)**2,M=Zc(e),K=l.renderer.tileGeometryCache.acquire(Z+4*M),{boundingBox:L}=f;mc.empty(L);f.numVerticesPerSide=p;f.vertexAttributes=K;f.maxEdgeVertexCount=M;f.minu=D;f.minv=E;f.maxu=P;f.maxv=ka;{const {tile:Ca}=a;if(Ca.intersectsClippingArea){var {geometry:R,geometryState:Aa,localOrigin:da}=a,{samplerData:aa,clippingArea:U,numVerticesPerSide:X}=
Aa,{surface:va,extent:ea,ellipsoid:w}=Ca,{isWebMercatorOnPlateCarree:B}=va,F=null!=U?U:ic,N=ea[0],z=ea[1],g=ea[2],ba=ea[3],H=Math.max(N,F[0]),fa=Math.min(g,F[2]),ca=Math.max(z,F[1]),qa=Math.min(ba,F[3]),Fa=w.radius,b=Ca.horizontalScale,Y=X-1,ha=X-2,{minu:ra,minv:Ga,maxu:Na,maxv:Ha,boundingBox:S,vertexAttributes:c}=R,y=c.position,v=c.uv0,{typedBuffer:q,typedBufferStride:A}=c.normalCompressed,C=da[0],u=da[1],I=da[2],Q=y.typedBuffer,wa=y.typedBufferStride,xa=0,Ua=G.clamp(z,ca,qa),Va=B?(Math.PI/2-2*Math.atan(Math.exp(-Ua/
Fa)))*Fa:Ua*b,Oa=1/Y,Ba=G.clamp(z*(1-Oa)+ba*Oa,ca,qa),na=Va,Ia=B?(Math.PI/2-2*Math.atan(Math.exp(-Ba/Fa)))*Fa:Ba*b;for(let la=1;la<=ha;la++){const sa=la/Y,V=G.clamp(z*(1-sa)+ba*sa,ca,qa),T=G.clamp(sa,Ga,Ha),oa=Ia,Ka=(la-1)/Y,ya=G.clamp(z*(1-Ka)+ba*Ka,ca,qa),$a=na,Ra=(la+1)/Y,ab=G.clamp(z*(1-Ra)+ba*Ra,ca,qa),Sa=B?(Math.PI/2-2*Math.atan(Math.exp(-ab/Fa)))*Fa:ab*b,bb=G.clamp(Ra,Ga,Ha);na=Ia;Ia=Sa;const Da=G.clamp(N,H,fa);let Wa=Da*b,cb=ja.sampleElevation(Da,V,aa);const db=1/Y,Ta=G.clamp(db,ra,Na),Xa=
G.clamp(N*(1-Ta)+g*Ta,H,fa);let Ya=Ta,Pa=Xa,Qa=Xa*b,La=ja.sampleElevation(Xa,V,aa);if(1===la){const ma=Qa-C,pa=na-u,ta=La-I,ua=0*wa;Q[ua]=ma;Q[ua+1]=pa;Q[ua+2]=ta;eb(ma,pa,ta,S);const W=G.clamp(db,ra,Na);jb.encodeUVInBuffer(v,xa,W,T)}for(let ma=1;ma<=ha;ma++){const pa=Qa,ta=La,ua=(ma+1)/Y,W=G.clamp(ua,ra,Na),za=G.clamp(N*(1-ua)+g*ua,H,fa),Ea=Pa;Pa=za;const J=xa+1,ia=J*wa;if(1===la||ma===ha){const lb=ja.sampleElevation(za,V,aa),qb=za*b,wb=oa,tb=lb;if(1===la&&ma<ha){const sb=qb-C,xb=wb-u,Eb=tb-I;Q[ia]=
sb;Q[ia+1]=xb;Q[ia+2]=Eb;eb(sb,xb,Eb,S);jb.encodeUVInBuffer(v,J,W,T)}Qa=qb;La=tb}else Qa=Q[ia]+C,La=Q[ia+2]+I;const Ma=Qa,rb=La,hb=Wa,fb=cb;Wa=pa;cb=ta;const nb=(xa-ha)*wa,gb=1===la?ja.sampleElevation(Ea,ya,aa):Q[nb+2]+I,Za=ja.sampleElevation(Ea,ab,aa);if(la<ha){const lb=xa+ha,qb=lb*wa,wb=pa-C,tb=Sa-u,sb=Za-I;Q[qb]=wb;Q[qb+1]=tb;Q[qb+2]=sb;eb(wb,tb,sb,S);const xb=Ya;Ya=W;jb.encodeUVInBuffer(v,lb,xb,bb)}const ob=Ma-hb,kb=$a-Sa,pb=kb*(rb-fb),ib=ob*(gb-Za),vb=-kb*ob,Nb=pb*pb+ib*ib+vb*vb;if(0===Nb)Lb.compressNormal(q,
xa,0,0,1,A);else{const lb=1/Math.sqrt(Nb);Lb.compressNormal(q,xa,pb*lb,ib*lb,vb*lb,A)}++xa}}}}f.edgeVerticesStartIndex=Z;kc(a);hc(a);Tc(f,[],k);a.intersectionData=null};mb.createSphericalGlobePatch=function(a,b){const {tile:d,geometry:e,geometryState:f}=a,{extentInRadians:m,surface:l}=d,{isWebMercator:k,renderer:h}=l,{numVerticesPerSide:n,wireframe:r}=f,t=n-1,p=(n-2)**2,x=k&&(b===Ib.PatchType.HAS_SOUTH_POLE||b===Ib.PatchType.HAS_BOTH_POLES),D=k&&(b===Ib.PatchType.HAS_NORTH_POLE||b===Ib.PatchType.HAS_BOTH_POLES),
E=6*((x?1:0)+(D?1:0))*n,P=Zc(f),ka=h.tileGeometryCache.acquire(p+E+4*P);e.numVerticesPerSide=n;e.vertexAttributes=ka;e.maxEdgeVertexCount=P;const {boundingBox:Z}=e;mc.empty(Z);const M=Rb(a);Ja.update(t,m,M);{const {tile:Ha}=a;if(Ha.intersectsClippingArea){var {geometry:K,geometryState:L,localOrigin:R}=a,{numVerticesPerSide:Aa,samplerData:da}=L,aa=Aa-2,U=Aa-1,{vertexAttributes:X,boundingBox:va}=K,ea=X.position,w=X.uv0,{typedBuffer:B,typedBufferStride:F}=X.normalCompressed,{extent:N}=Ha,z=N[0],g=N[2],
ba=N[1],H=N[3],fa=Ha.ellipsoid.radius,ca=R[0],qa=R[1],Fa=R[2],Y=ea.typedBuffer,ha=ea.typedBufferStride,ra=1/U,Ga=0;if(1<=aa){const S=ba*(1-ra)+H*ra,c=Ja.sinLatLUT[1],y=Ja.cosLatLUT[1];for(let v=1;v<=aa;v++){const q=v*ra,A=Ja.sinLonLUT[v],C=Ja.cosLonLUT[v],u=fa+ja.sampleElevation(z*(1-q)+g*q,S,da),I=-ca+u*C*y,Q=-qa+u*A*y,wa=-Fa+u*c;eb(I,Q,wa,va);const xa=(v-1)*ha;Y[xa]=I;Y[xa+1]=Q;Y[xa+2]=wa;jb.encodeUVInBuffer(w,v-1,q,ra)}}for(let S=1;S<=aa;S++){const c=S*ra,y=ba*(1-c)+H*c,v=Ja.sinLatLUT[S],q=Ja.cosLatLUT[S],
A=S+1,C=A*ra,u=ba*(1-C)+H*C,I=Ja.sinLatLUT[A],Q=Ja.cosLatLUT[A],wa=Ja.sinLonLUT[0],xa=Ja.cosLonLUT[0],Ua=fa+ja.sampleElevation(z,y,da);let Va=xa*q*Ua-ca,Oa=wa*q*Ua-qa,Ba=v*Ua-Fa;const na=Ga*ha;let Ia=Y[na],Ca=Y[na+1],la=Y[na+2];for(let sa=1;sa<=aa;sa++){const V=sa*ra,T=z*(1-V)+g*V,oa=Ja.sinLonLUT[sa],Ka=Ja.cosLonLUT[sa];let ya=0,$a=0,Ra=0;if(sa<aa){const J=(Ga+1)*ha;ya=Y[J];$a=Y[J+1];Ra=Y[J+2]}else{const J=Ja.sinLonLUT[U],ia=Ja.cosLonLUT[U],Ma=fa+ja.sampleElevation(g,y,da);ya=ia*q*Ma-ca;$a=J*q*Ma-
qa;Ra=v*Ma-Fa}const ab=Va,Sa=Oa,bb=Ba;Va=Ia;Oa=Ca;Ba=la;Ia=ya;Ca=$a;la=Ra;const Da=ya-ab,Wa=$a-Sa,cb=Ra-bb;let db=0,Ta=0,Xa=0;if(1<S){const J=(Ga-aa)*ha;db=Y[J];Ta=Y[J+1];Xa=Y[J+2]}else{const J=Ja.sinLatLUT[0],ia=Ja.cosLatLUT[0],Ma=fa+ja.sampleElevation(T,ba,da);db=Ka*ia*Ma-ca;Ta=oa*ia*Ma-qa;Xa=J*Ma-Fa}const Ya=fa+ja.sampleElevation(T,u,da),Pa=Ka*Q*Ya-ca,Qa=oa*Q*Ya-qa,La=I*Ya-Fa;if(S<aa){const J=Ga+aa,ia=J*ha;Y[ia]=Pa;Y[ia+1]=Qa;Y[ia+2]=La;eb(Pa,Qa,La,va);jb.encodeUVInBuffer(w,J,V,C)}const ma=db-
Pa,pa=Ta-Qa,ta=Xa-La;let ua=Ka*q,W=oa*q,za=v;.999>za*za&&(ua=cb*pa-Wa*ta,W=Da*ta-cb*ma,za=Wa*ma-Da*pa);const Ea=1/Math.sqrt(ua*ua+W*W+za*za);Lb.compressNormal(B,Ga,ua*Ea,W*Ea,za*Ea,F);++Ga}}}}e.poleVerticesStartIndex=p;const Na=bd(a,x,D);e.edgeVerticesStartIndex=p+E;kc(a);Qb(a);Tc(e,Na,r);a.intersectionData=null};mb.updateCornerSpherical=function(a){a.tile.intersectsClippingArea&&(Mb(a),pc(a,!0),Db(a),a.intersectionData=null)};mb.updateCornersPlanar=function(a,b){a.tile.intersectsClippingArea&&(Mb(a),
Rc(a,!0),Db(a),a.intersectionData=null)};mb.updateEdgeElevationsAndResolutionsPlanar=function(a,b){a.tile.intersectsClippingArea&&(Xc(a),hc(a),Db(a),Yc(a),a.intersectionData=null)};mb.updateEdgeElevationsAndResolutionsSpherical=function(a){a.tile.intersectsClippingArea&&(Xc(a),Qb(a),Db(a),Yc(a),a.intersectionData=null)};mb.updateEdgesAndCornersPlanar=function(a,b){a.tile.intersectsClippingArea&&(hc(a),Db(a),a.intersectionData=null)};mb.updateEdgesAndCornersSpherical=function(a){a.tile.intersectsClippingArea&&
(Qb(a),Db(a),a.intersectionData=null)};Object.defineProperty(mb,Symbol.toStringTag,{value:"Module"})});