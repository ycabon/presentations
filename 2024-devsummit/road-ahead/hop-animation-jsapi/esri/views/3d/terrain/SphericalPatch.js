// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../chunks/vec32 ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../geometry/projection/lonLatToSphericalPCPF ../../../geometry/support/DoubleArray ../../../geometry/support/frustum ../../../chunks/sphere ./interfaces ./ITile ./PatchGeometryFactory ./terrainUtils ./Tile ./tileUtils".split(" "),function(ba,ca,g,n,pa,qa,Z,S,P,T,V,A,N,ra){function da(c,a,d,e,b,f){c=e-c;a=b-a;d=f-d;return c*c+a*a+d*d}class sa extends N.Tile{constructor(c,a,d,e,b){super();
this._convexHull=Array(24);this._boundingSphere=S.create();this._baseUsedMemory=1816;this.init(c,a,d,e,b)}init(c,a,d,e,b){super.init(c,a,d,e,b);a=this.ellipsoid.radius;d=this.extentInRadians[0];e=this.extentInRadians[1];b=this.extentInRadians[2];const f=this.extentInRadians[3],y=ca.lerp(e,f,.5),h=ca.lerp(d,b,.5);this._edgeLen=(b-d)*Math.cos(0===c?0:Math.min(Math.abs(e),Math.abs(f)))*a;this._edgeLen2=this._edgeLen*this._edgeLen;this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4);pa.lonLatToSphericalPCPF(this.centerAtSeaLevel,
h,y,this.ellipsoid.radius);g.normalize(this.up,this.centerAtSeaLevel);this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const c=this._center;if(0===this.lij[0])g.set(S.getCenter(c[N.CenterPosition.MIDDLE]),0,0,0),g.set(c[N.CenterPosition.TOP],0,0,0),g.set(c[N.CenterPosition.BOTTOM],0,0,0),c[N.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const y=c[N.CenterPosition.MIDDLE],h=this.convexHull;var a=0;for(let r=0;8>r;++r){var d=
Math,e=d.max;var b=S.getCenter(y);var f=3*r;b=da(b[0],b[1],b[2],h[f],h[f+1],h[f+2]);a=e.call(d,a,b)}c[N.CenterPosition.MIDDLE][3]=Math.sqrt(a)}}_calculateFrustumVisibilityStatus(c){if(!Z.intersectsSphere(c,this._boundingSphere))return T.TileFrustumVisibility.OUTSIDE;if(10>this.lij[0])return T.TileFrustumVisibility.INTERSECTS;const a=this.convexHull,d=this.surface.view.state.camera.near;let e=!0;for(let f=0;f<Z.numPlanes;f++){var b=c[f];const y=b[0],h=b[1],r=b[2];b=b[3]-(f===Z.PlaneIndex.NEAR?d:0);
let E=!1;for(let H=0;8>H;++H){const z=3*H;if(0>y*a[z]+h*a[z+1]+r*a[z+2]+b){if(E=!0,!e)break}else e=!1}if(!E)return T.TileFrustumVisibility.OUTSIDE}return e?T.TileFrustumVisibility.INSIDE:T.TileFrustumVisibility.INTERSECTS}computeElevationBounds(){super.computeElevationBounds();this._updateBoundingVolumes()}createGeometry(){V.createSphericalGlobePatch(this.renderData,this._getPatchType());this._updateBoundingVolumes();this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull();this._updateBoundingSphere();
A.enableTerrainInternalChecks&&this._checkBVs()}_updateBoundingSphere(){const c=this._boundingSphere,a=S.getCenter(c);var d=this.elevationBounds,e=this.ellipsoid.radius,b=d[1];if(0===this.level)g.set(a,0,0,0),c[3]=e+b;else{b=this.extentInRadians;var f=.5*(b[0]+b[2]),y=b[3];K(ea,f,b[1],e);K(fa,f,y,e);g.add(a,ea,fa);g.scale(a,a,(e+.5*(d[0]+d[1]))/g.len(a));d=this.convexHull;e=0;for(b=0;8>b;++b){f=a[0]-d[3*b];y=a[1]-d[3*b+1];const h=a[2]-d[3*b+2];e=Math.max(e,Math.sqrt(f*f+y*y+h*h))}c[3]=e+2}}_updateConvexHull(){var c=
this.extentInRadians,a=this.ellipsoid.radius;if(0!==this.level){var d=this.elevationBounds,e=this._getPatchType(),b=this.surface.isWebMercator,f=b&&e===P.PatchType.HAS_NORTH_POLE,y=(e=b&&e===P.PatchType.HAS_SOUTH_POLE)||f;b=Math.PI/2;var h=c[0],r=c[2];e=e?-b:c[1];var E=f?b:c[3],H=.5*(h+r);c=d[0];var z=a+(y?Math.min(0,c-1):c);c=n.create();f=n.create();b=n.create();var I=n.create();K(c,h,e,z);K(f,h,E,z);K(b,r,E,z);K(I,r,e,z);h=(D,u)=>{for(let F=0;3>F;++F)this._convexHull[3*u+F]=D[F]};h(c,0);h(f,1);
h(b,2);h(I,3);d=d[1];var W=a+(y?Math.max(0,d+1):d),k=n.create();a=n.create();d=n.create();K(a,H,E,z);K(d,H,e,z);g.add(k,a,d);g.normalize(k,k);var v=n.create(),B=n.create();e=(D,u)=>{g.sub(B,D,u);g.normalize(B,B);u=-g.dot(D,v)/g.dot(B,v);A.internalAssert(0<=u);g.scale(B,B,u);g.add(D,D,B)};2**this.lij[0]>2*this.lij[1]?(a=n.create(),g.cross(a,ha,d),g.normalize(a,a),g.cross(v,d,a),g.normalize(v,v),A.internalAssert(A.almostEquals(g.dot(v,d)/g.len(d),0)),e(c,f),e(I,b),h(c,0),h(I,3)):2**this.lij[0]!==2*
this.lij[1]&&(d=n.create(),g.cross(d,ha,a),g.normalize(d,d),g.cross(v,d,a),g.normalize(v,v),e(f,c),e(b,I),h(f,1),h(b,2));a=(D,u)=>{const F=W/g.dot(u,k);for(let L=0;3>L;++L)this._convexHull[3*D+L]=u[L]*F};a(4,c);a(5,f);a(6,b);a(7,I)}}_getPatchType(){const c=this.lij[1],a=c===(1<<this.level)-1;return 0===c?a?P.PatchType.HAS_BOTH_POLES:P.PatchType.HAS_NORTH_POLE:a?P.PatchType.HAS_SOUTH_POLE:P.PatchType.REGULAR}intersectsRay(c,a,d,e){var b=this._boundingSphere;d=b[3]+d;var f=b[0]-c[0];e=b[1]-c[1];c=b[2]-
c[2];b=(f*a[0]+e*a[1]+c*a[2])/(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);f=a[0]*b-f;e=a[1]*b-e;a=a[2]*b-c;return f*f+e*e+a*a<d*d}getDefaultVerticesPerSide(){return this.level<ia.length?ia[this.level]+1:2}updateCornerElevations(){V.updateCornerSpherical(this.renderData);this._updateBoundingVolumes()}updateEdgeElevations(){V.updateEdgesAndCornersSpherical(this.renderData);this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){V.updateEdgeElevationsAndResolutionsSpherical(this.renderData);this._updateBoundingVolumes()}_checkBVs(){if(A.enableTerrainInternalChecks&&
!(2>=this.level)){var c=this._boundingSphere,a=c[3],d=S.getCenter(c);c=n.create();var e=this.ellipsoid.radius,b=this.elevationBounds;b[1]-b[0];var f=e+b[0],y=this._center[N.CenterPosition.MIDDLE][3],h=this.convexHull,r=(m,w)=>{for(let p=0;3>p;++p)m[p]=h[3*w+p]},E=n.create(),H=n.create(),z=n.create(),I=n.create(),W=n.create(),k=(m,w,p,G)=>{r(H,m);r(z,w);r(I,p);g.sub(H,H,z);g.sub(I,I,z);g.cross(E,H,I);g.normalize(E,E);var Q=g.dot(E,z);r(W,G);const X=g.dot(E,W);Q=Math.abs(X-Q);A.internalAssert(A.almostEquals(Q,
0),`Non coplanar ${m},${w},${p},${G} diff = ${Q}`)};k(0,1,2,3);k(4,5,6,7);k(0,1,4,5);k(1,2,5,6);k(2,3,6,7);k(3,0,7,4);var v=qa.newDoubleArray(24),B=n.create(),D=n.create(),u=n.create(),F=n.create();k=(m,w,p,G)=>{r(B,w);r(D,p);r(u,G);g.sub(B,B,D);g.normalize(B,B);g.sub(u,u,D);g.normalize(u,u);g.cross(F,B,u);g.normalize(F,F);w=g.dot(F,D);m*=4;for(p=0;3>p;++p)v[m+p]=F[p];v[m+3]=w};k(0,0,1,2);k(1,1,0,4);k(2,1,5,2);k(3,3,2,6);k(4,4,0,3);k(5,4,6,5);var L=(m,w,p,G)=>{m*=4;return v[m]*w+v[m+1]*p+v[m+2]*G-
v[m+3]},t=(m,w,p,G)=>-1<=L(m,w,p,G),O=2**this.lij[0]>2*this.lij[1];k=(m,w,p)=>Math.sqrt(da(m,w,p,d[0],d[1],d[2]))<a;var l=this.extentInRadians,q=.5*(l[0]+l[2]),C=l[1],x=l[3];l=n.create();var J=n.create();K(l,q,x,f);K(J,q,C,f);f=O?"Upper":"Lower";O=!0;for(q=0;6>q;++q){for(C=0;8>C;++C)x=3*C,x=-1<=L(q,h[x],h[x+1],h[x+2]),O&&=x,A.internalAssert(x,`Tile[${this.lij}] Convex hull point ${C} outside of plane ${q}`);A.internalAssert(t(q,J[0],J[1],J[2]),`Tile[${this.lij}] (${f}) bottom mid outside of plane ${q}`);
A.internalAssert(t(q,l[0],l[1],l[2]),`Tile[${this.lij}] (${f}) top mid outside of plane ${q}`)}A.internalAssert(O,"Not all convex hull points are inside  convex hull polyhedron");A.internalAssert(k(J[0],J[1],J[2]),`Tile[${this.lij}] (${f}) bottom mid outside of bounding sphere`);A.internalAssert(k(l[0],l[1],l[2]),`Tile[${this.lij}] (${f}) top mid outside of bounding sphere`);for(t=0;8>t;++t)l=3*t,l=k(h[l],h[l+1],h[l+2]),A.internalAssert(l,`Tile[${this.lij}] Convex hull point ${t} outside of bounding sphere`);
for(k=0;6>k;++k)for(t=0;8>t;++t)l=3*t,-1<=L(k,h[l],h[l+1],h[l+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${k}`);({extentInRadians:k}=this);k=Math.round(Math.max(k[2]-k[0],k[3]-k[1])*e);({renderData:t}=this);if(t){var {geometry:aa,geometryState:ja,localOrigin:ta}=t;if(t=aa.vertexAttributes?.position){l=n.create();J=aa.numVerticesPerSide-2;var {indices:ka,indexCount:ua,edgeVerticesStartIndex:la,poleVerticesStartIndex:va}=aa;if(ka)for(f=new Set,O=0;O<ua;++O){const m=
ka[O];if(f.has(m))continue;f.add(m);const w=m<va,p=m>=la;let G=!1;q=-1;if(p)for(C=la,x=0;4>x;++x){var U=ja.edgeResolutions[x];if(m===C||m===C+U-1){G=!0;break}C+=U;if(m<C){q=x;break}}q=p?ja.edgePeerNeighbors[q]:null;const Q=p&&q&&0<ra.compareTilesByLij(this,q);t.getVec(m,c);g.add(l,c,ta);q=g.len(l)-e;C=0;x=!1;U=b[0]-q;const X=q-b[1],ma=1<U,na=1<X;var M=ma||na;const oa=()=>{const Y=p&&!G;return`Tile[${this.lij}].vertex[${m}]:${w?"internal":Y?"edge":G?"corner":"pole"}`+(ma?"(below)":na?"(above)":"")+
(Q?"(Neighbor)":"")};var R=g.dist(l,d);R>=a+0&&(R-=a,M||(console.error(`${oa()} is out of the bounding sphere by ${R.toFixed(0)} / ${a.toFixed(0)}`+"[tol\x3d0]"+` h=${q.toFixed(0)} / [${b[0].toFixed(0)}..${b[1].toFixed(0)}] (${(R/a).toFixed(0)})`),x=!0));for(M=0;6>M;++M)if(!(-1<=L(M,l[0],l[1],l[2]))){R=L(M,l[0],l[1],l[2]);const Y=m%J,wa=(m-Y)/J;0===M&&U||5===M&&X||(console.error(`${oa()} (${Y},${wa})|${J}] is out of the bounding trapezoid plane ${M}`+` h=${Math.round(q)} / [${Math.round(b[0])}..${Math.round(b[1])}] dist=${Math.round(R)}`+
` radii = ${Math.round(a)}/${Math.round(y)}} : maxL = ${k}`),++C)}if(x||0<C)break}}}}}get convexHull(){return this._convexHull}}const ia=[128,64,64,32,16,8,8,4],K=(c,a,d,e)=>{const b=Math.sin(a),f=Math.cos(d);d=Math.sin(d);c[0]=e*f*Math.cos(a);c[1]=e*f*b;c[2]=e*d},ha=[0,0,1],ea=n.create(),fa=n.create();ba.SphericalPatch=sa;Object.defineProperty(ba,Symbol.toStringTag,{value:"Module"})});