// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/Error","../../../../../core/Logger","../shaderTechnique/BindType","../../lib/Util"],function(k,x,y,p,t){const u=()=>y.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class q{constructor(){this._includedModules=new Map}include(a,c){if(this._includedModules.has(a)){const b=this._includedModules.get(a);if(b!==c){u().error("Shader module included multiple times with different configuration.");c=new Set;for(const d of Object.keys(b))b[d]!==
a[d]&&c.add(d);for(const d of Object.keys(a))b[d]!==a[d]&&c.add(d);c.forEach(d=>console.error(`  ${d}: current ${b[d]} new ${a[d]}`))}}else this._includedModules.set(a,c),a(this.builder,c)}}class z extends q{constructor(){super(...arguments);this.vertex=new r;this.fragment=new r;this.attributes=new A;this.varyings=new B;this.extensions=new l;this.constants=new e;this.outputs=new m}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(a){const c=this.extensions.generateSource(a),
b=this.attributes.generateSource(a),d=this.varyings.generateSource(a);var f="vertex"===a?this.vertex:this.fragment;const g=f.uniforms.generateSource(),h=f.code.generateSource(),n="vertex"===a?"precision highp float;\nprecision highp sampler2D;":"#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif";f=this.constants.generateSource().concat(f.constants.generateSource());a=this.outputs.generateSource(a);
return`#version 300 es\n${c.join("\n")}\n\n${n}\n\n${f.join("\n")}\n\n${g.join("\n")}\n\n${b.join("\n")}\n\n${d.join("\n")}\n\n${a.join("\n")}\n\n${h.join("\n")}`}generateBindPass(a){const c=new Map;this.vertex.uniforms.entries.forEach(f=>{const g=f.bind[p.BindType.Pass];g&&c.set(f.name,g)});this.fragment.uniforms.entries.forEach(f=>{const g=f.bind[p.BindType.Pass];g&&c.set(f.name,g)});const b=Array.from(c.values()),d=b.length;return(f,g)=>{for(let h=0;h<d;++h)b[h](a,f,g)}}generateBindDraw(a){const c=
new Map;this.vertex.uniforms.entries.forEach(f=>{const g=f.bind[p.BindType.Draw];g&&c.set(f.name,g)});this.fragment.uniforms.entries.forEach(f=>{const g=f.bind[p.BindType.Draw];g&&c.set(f.name,g)});const b=Array.from(c.values()),d=b.length;return(f,g,h)=>{for(let n=0;n<d;++n)b[n](a,f,g,h)}}}class v{constructor(){this._entries=new Map}add(...a){for(const c of a)this._add(c)}get(a){return this._entries.get(a)}_add(a){if(null==a)u().error(`Trying to add null Uniform from ${Error().stack}.`);else{if(this._entries.has(a.name)&&
!this._entries.get(a.name).equals(a))throw new x(`Duplicate uniform name ${a.name} for different uniform type`);this._entries.set(a.name,a)}}generateSource(){return Array.from(this._entries.values()).map(a=>null!=a.arraySize?`uniform ${a.type} ${a.name}[${a.arraySize}];`:`uniform ${a.type} ${a.name};`)}get entries(){return Array.from(this._entries.values())}}class w{constructor(){this._entries=[]}add(a){this._entries.push(a)}generateSource(){return this._entries}}class r extends q{constructor(){super(...arguments);
this.uniforms=new v;this.code=new w;this.constants=new e}get builder(){return this}}class A{constructor(){this._entries=[]}add(a,c){this._entries.push([a,c])}generateSource(a){return"fragment"===a?[]:this._entries.map(c=>`in ${c[1]} ${c[0]};`)}}class B{constructor(){this._entries=new Map}add(a,c){this._entries.has(a)&&t.assert(this._entries.get(a)===c);this._entries.set(a,c)}generateSource(a){const c=[];this._entries.forEach((b,d)=>c.push("vertex"===a?`out ${b} ${d};`:`in ${b} ${d};`));return c}}
class l{constructor(){this._entries=new Set}add(a){this._entries.add(a)}generateSource(a){const c="vertex"===a?l.ALLOWLIST_VERTEX:l.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter(b=>c.includes(b)).map(b=>`#extension ${b} : enable`)}}l.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"];l.ALLOWLIST_VERTEX=[];class m{constructor(){this._entries=new Map}add(a,c,b=0){const d=this._entries.get(b);d?t.assert(d.name===a&&d.type===c,`Fragment shader output location ${b} occupied`):
this._entries.set(b,{name:a,type:c})}generateSource(a){if("vertex"===a)return[];0===this._entries.size&&this._entries.set(0,{name:m.DEFAULT_NAME,type:m.DEFAULT_TYPE});const c=[];this._entries.forEach((b,d)=>c.push(`layout(location = ${d}) out ${b.type} ${b.name};`));return c}}m.DEFAULT_TYPE="vec4";m.DEFAULT_NAME="fragColor";class e{constructor(){this._entries=new Set}add(a,c,b){let d="ERROR_CONSTRUCTOR_STRING";switch(c){case "float":d=e._numberToFloatStr(b);break;case "int":d=e._numberToIntStr(b);
break;case "bool":d=b.toString();break;case "vec2":d=`vec2(${e._numberToFloatStr(b[0])},                            ${e._numberToFloatStr(b[1])})`;break;case "vec3":d=`vec3(${e._numberToFloatStr(b[0])},                            ${e._numberToFloatStr(b[1])},                            ${e._numberToFloatStr(b[2])})`;break;case "vec4":d=`vec4(${e._numberToFloatStr(b[0])},                            ${e._numberToFloatStr(b[1])},                            ${e._numberToFloatStr(b[2])},                            ${e._numberToFloatStr(b[3])})`;
break;case "ivec2":d=`ivec2(${e._numberToIntStr(b[0])},                             ${e._numberToIntStr(b[1])})`;break;case "ivec3":d=`ivec3(${e._numberToIntStr(b[0])},                             ${e._numberToIntStr(b[1])},                             ${e._numberToIntStr(b[2])})`;break;case "ivec4":d=`ivec4(${e._numberToIntStr(b[0])},                             ${e._numberToIntStr(b[1])},                             ${e._numberToIntStr(b[2])},                             ${e._numberToIntStr(b[3])})`;
break;case "mat2":case "mat3":case "mat4":d=`${c}(${Array.prototype.map.call(b,f=>e._numberToFloatStr(f)).join(", ")})`}this._entries.add(`const ${c} ${a} = ${d};`);return this}static _numberToIntStr(a){return a.toFixed(0)}static _numberToFloatStr(a){return Number.isInteger(a)?a.toFixed(1):a.toString()}generateSource(){return Array.from(this._entries)}}k.Code=w;k.Includes=q;k.ShaderBuilder=z;k.Stage=r;k.Uniforms=v;Object.defineProperty(k,Symbol.toStringTag,{value:"Module"})});