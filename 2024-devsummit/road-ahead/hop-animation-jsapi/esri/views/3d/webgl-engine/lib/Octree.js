// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../../../core/ObjectPool ../../../../core/PooledArray ../../../../chunks/vec32 ../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../geometry/support/frustum ../../../../geometry/support/ray ../../../../chunks/sphere ./Util".split(" "),function(Y,D,w,m,H,R,g,S){function I(a,b,c){c[0]=a[0]+b;c[1]=a[1]+b;c[2]=a[2]+b}function T(a,b,c,d){if(1===b)a=c(a[0]),g.copy(a,d);else{r[0]=Infinity;r[1]=Infinity;r[2]=Infinity;t[0]=-Infinity;t[1]=-Infinity;t[2]=-Infinity;for(let h=0;h<b;h++){var f=
c(a[h]);if(E(f[3])){var e=r,k=f;e[0]=Math.min(e[0],k[0]-k[3]);e[1]=Math.min(e[1],k[1]-k[3]);e[2]=Math.min(e[2],k[2]-k[3]);e=t;e[0]=Math.max(e[0],f[0]+f[3]);e[1]=Math.max(e[1],f[1]+f[3]);e[2]=Math.max(e[2],f[2]+f[3])}}w.lerp(g.getCenter(d),r,t,.5);d[3]=Math.max(t[0]-r[0],t[1]-r[1],t[2]-r[2])/2}}function Z(a,b,c){if(!B.length)for(var d=0;8>d;++d)B.push({index:0,distance:0});for(d=0;8>d;++d){const f=U[d];B.data[d].index=d;B.data[d].distance=z(a,b,f)}B.sort((f,e)=>f.distance-e.distance);for(a=0;8>a;++a)c[a]=
B.data[a].index}function M(a,b){let c=Infinity,d;for(let f=0;8>f;++f){const e=z(a,b,V[f]);e<c&&(c=e,d=V[f])}return d}function z(a,b,c){return b*(a[0]*c[0]+a[1]*c[1]+a[2]*c[2])}function E(a){return!isNaN(a)&&-Infinity!==a&&Infinity!==a&&0<a}class F{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(a,
b){this.objectToBoundingSphere=a;this._maximumObjectsPerNode=10;this._maximumDepth=20;this._degenerateObjects=new Set;this._root=new l;this._objectCount=0;b&&(void 0!==b.maximumObjectsPerNode&&(this._maximumObjectsPerNode=b.maximumObjectsPerNode),void 0!==b.maximumDepth&&(this._maximumDepth=b.maximumDepth))}destroy(){this._degenerateObjects.clear();l.clearPool();N[0]=null;C.prune();B.prune()}add(a,b=a.length){this._objectCount+=b;this._grow(a,b);const c=l.acquire();for(let d=0;d<b;d++){const f=a[d];
this._isDegenerate(f)?this._degenerateObjects.add(f):(c.init(this._root),this._add(f,c))}l.release(c)}remove(a,b=null){this._objectCount-=a.length;const c=l.acquire();for(const d of a)a=b??g.copy(this.objectToBoundingSphere(d),aa),E(a[3])?(c.init(this._root),this._remove(d,a,c)):this._degenerateObjects.delete(d);l.release(c);this._shrink()}update(a,b){if(E(b[3])||!this._isDegenerate(a))N[0]=a,a=N,this.remove(a,b),this.add(a)}forEachAlongRay(a,b,c){const d=R.wrap(a,b);this._forEachNode(this._root,
f=>{if(!this._intersectsNode(d,f))return!1;f=f.node;f.terminals.forAll(e=>{this._intersectsObject(d,e)&&c(e)});null!==f.residents&&f.residents.forAll(e=>{this._intersectsObject(d,e)&&c(e)});return!0})}forEachAlongRayWithVerticalOffset(a,b,c,d){const f=R.wrap(a,b);this._forEachNode(this._root,e=>{if(!this._intersectsNodeWithOffset(f,e,d))return!1;e=e.node;e.terminals.forAll(k=>{this._intersectsObjectWithOffset(f,k,d)&&c(k)});null!==e.residents&&e.residents.forAll(k=>{this._intersectsObjectWithOffset(f,
k,d)&&c(k)});return!0})}forEach(a){this._forEachNode(this._root,b=>{b=b.node;b.terminals.forAll(a);null!==b.residents&&b.residents.forAll(a);return!0});this._degenerateObjects.forEach(a)}forEachDegenerateObject(a){this._degenerateObjects.forEach(a)}findClosest(a,b,c,d=()=>!0,f=Infinity){let e=Infinity,k=Infinity,h=null;const p=M(a,b),x=q=>{--f;if(d(q)){var u=this.objectToBoundingSphere(q);if(H.intersectsSphere(c,u)){var J=z(a,b,g.getCenter(u)),G=J-u[3];u=J+u[3];G<e&&(e=G,k=u,h=q)}}};this._forEachNodeDepthOrdered(this._root,
q=>{if(0>=f||!H.intersectsSphere(c,q.bounds))return!1;w.scale(v,p,q.halfSize);w.add(v,v,g.getCenter(q.bounds));if(z(a,b,v)>k)return!1;q=q.node;q.terminals.forAll(u=>x(u));null!==q.residents&&q.residents.forAll(u=>x(u));return!0},a,b);return h}forEachInDepthRange(a,b,c,d,f,e,k){let h=-Infinity,p=Infinity;const x={setRange:n=>{c===F.DepthOrder.FRONT_TO_BACK?(h=Math.max(h,n.near),p=Math.min(p,n.far)):(h=Math.max(h,-n.far),p=Math.min(p,-n.near))}};x.setRange(d);const q=z(b,c,a),u=M(b,c),J=M(b,-c),G=n=>
{if(k(n)){var A=this.objectToBoundingSphere(n),K=g.getCenter(A);K=z(b,c,K)-q;var ba=K+A[3];K-A[3]>p||ba<h||!H.intersectsSphere(e,A)||f(n,x)}};this._forEachNodeDepthOrdered(this._root,n=>{if(!H.intersectsSphere(e,n.bounds))return!1;w.scale(v,u,n.halfSize);w.add(v,v,g.getCenter(n.bounds));if(z(b,c,v)-q>p)return!1;w.scale(v,J,n.halfSize);w.add(v,v,g.getCenter(n.bounds));if(z(b,c,v)-q<h)return!1;n=n.node;n.terminals.forAll(A=>G(A));null!==n.residents&&n.residents.forAll(A=>G(A));return!0},b,c)}forEachNode(a){this._forEachNode(this._root,
b=>a(b.node,b.bounds,b.halfSize,b.depth))}forEachNeighbor(a,b){const c=g.getRadius(b),d=g.getCenter(b),f=h=>{const p=this.objectToBoundingSphere(h);var x=g.getRadius(p);x=c+x;return 0>=w.squaredDistance(g.getCenter(p),d)-x*x?a(h):!0};let e=!0;const k=h=>{e&&=f(h)};this._forEachNode(this._root,h=>{var p=g.getRadius(h.bounds);p=c+p;if(0<w.squaredDistance(g.getCenter(h.bounds),d)-p*p)return!1;h=h.node;h.terminals.forAll(k);e&&null!==h.residents&&h.residents.forAll(k);return e});e&&this.forEachDegenerateObject(k)}_intersectsNode(a,
b){I(g.getCenter(b.bounds),2*-b.halfSize,r);I(g.getCenter(b.bounds),2*b.halfSize,t);return S.rayBoxTest(a.origin,a.direction,r,t)}_intersectsNodeWithOffset(a,b,c){I(g.getCenter(b.bounds),2*-b.halfSize,r);I(g.getCenter(b.bounds),2*b.halfSize,t);c.applyToMinMax(r,t);return S.rayBoxTest(a.origin,a.direction,r,t)}_intersectsObject(a,b){b=this.objectToBoundingSphere(b);return 0<b[3]?g.intersectsRay(b,a):!0}_intersectsObjectWithOffset(a,b,c){b=this.objectToBoundingSphere(b);return 0<b[3]?g.intersectsRay(c.applyToBoundingSphere(b),
a):!0}_forEachNode(a,b){a=l.acquire().init(a);const c=[a];for(;0!==c.length;){a=c.pop();if(b(a)&&!a.isLeaf())for(let d=0;d<a.node.children.length;d++)a.node.children[d]&&c.push(l.acquire().init(a).advance(d));l.release(a)}}_forEachNodeDepthOrdered(a,b,c,d=F.DepthOrder.FRONT_TO_BACK){a=l.acquire().init(a);const f=[a];for(Z(c,d,W);0!==f.length;){a=f.pop();if(b(a)&&!a.isLeaf())for(c=7;0<=c;--c)d=W[c],a.node.children[d]&&f.push(l.acquire().init(a).advance(d));l.release(a)}}_remove(a,b,c){C.clear();b=
c.advanceTo(b,(d,f)=>{C.push(d.node);C.push(f)})?c.node.terminals:c.node.residents;b.removeUnordered(a);if(0===b.length)for(a=C.length-2;0<=a&&this._purge(C.data[a],C.data[a+1]);a-=2);}_nodeIsEmpty(a){if(0!==a.terminals.length)return!1;if(null!==a.residents)return 0===a.residents.length;for(let b=0;b<a.children.length;b++)if(a.children[b])return!1;return!0}_purge(a,b){0<=b&&(a.children[b]=null);return this._nodeIsEmpty(a)?(null===a.residents&&(a.residents=new D({shrink:!0})),!0):!1}_add(a,b){b.advanceTo(this.objectToBoundingSphere(a))?
b.node.terminals.push(a):(b.node.residents.push(a),b.node.residents.length>this._maximumObjectsPerNode&&b.depth<this._maximumDepth&&this._split(b))}_split(a){const b=a.node.residents;a.node.residents=null;for(let c=0;c<b.length;c++){const d=l.acquire().init(a);this._add(b.at(c),d);l.release(d)}}_grow(a,b){0!==b&&(T(a,b,c=>this.objectToBoundingSphere(c),y),E(y[3])&&!this._fitsInsideTree(y)&&(this._nodeIsEmpty(this._root.node)?(g.copy(y,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],
this._root.updateBoundsRadiusFromHalfSize()):(a=this._rootBoundsForRootAsSubNode(y),this._placingRootViolatesMaxDepth(a)?this._rebuildTree(y,a):this._growRootAsSubNode(a),l.release(a))))}_rebuildTree(a,b){w.copy(g.getCenter(O),g.getCenter(b.bounds));O[3]=b.halfSize;T([a,O],2,c=>c,P);a=l.acquire().init(this._root);this._root.initFrom(null,P,P[3]);this._root.increaseHalfSize(1.25);this._forEachNode(a,c=>{this.add(c.node.terminals.data,c.node.terminals.length);null!==c.node.residents&&this.add(c.node.residents.data,
c.node.residents.length);return!0});l.release(a)}_placingRootViolatesMaxDepth(a){const b=Math.log(a.halfSize/this._root.halfSize)*Math.LOG2E;let c=0;this._forEachNode(this._root,d=>{c=Math.max(c,d.depth);return c+b<=this._maximumDepth});return c+b>this._maximumDepth}_rootBoundsForRootAsSubNode(a){var b=a[3],c=-Infinity;const d=this._root.bounds,f=this._root.halfSize;for(var e=0;3>e;e++){var k=Math.max(0,Math.ceil((d[e]-f-(a[e]-b))/(2*f)));const h=Math.max(0,Math.ceil((a[e]+b-(d[e]+f))/(2*f)))+1;c=
Math.max(c,2**Math.ceil(Math.log(k+h)*Math.LOG2E));L[e].min=k;L[e].max=h}for(a=0;3>a;a++)b=L[a].min,e=L[a].max,k=(c-(b+e))/2,b+=Math.ceil(k),e+=Math.floor(k),Q[a]=d[a]-f-b*f*2+(e+b)*f;c*=f;Q[3]=c*X;return l.acquire().initFrom(null,Q,c,0)}_growRootAsSubNode(a){const b=this._root.node;w.copy(g.getCenter(y),g.getCenter(this._root.bounds));y[3]=this._root.halfSize;this._root.init(a);a.advanceTo(y,null,!0);a.node.children=b.children;a.node.residents=b.residents;a.node.terminals=b.terminals}_shrink(){for(;;){const a=
this._findShrinkIndex();if(-1===a)break;this._root.advance(a);this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let a=null;const b=this._root.node.children;let c=0,d=0;for(;d<b.length&&null==a;)c=d++,a=b[c];for(;d<b.length;)if(b[d++])return-1;return c}_isDegenerate(a){a=this.objectToBoundingSphere(a)[3];return!E(a)}_fitsInsideTree(a){const b=this._root.bounds,c=this._root.halfSize;return a[3]<=c&&a[0]>=b[0]-c&&a[0]<=b[0]+c&&a[1]>=b[1]-c&&
a[1]<=b[1]+c&&a[2]>=b[2]-c&&a[2]<=b[2]+c}toJSON(){const {maximumDepth:a,maximumObjectsPerNode:b,_objectCount:c}=this,d=this._nodeToJSON(this._root.node);return{maximumDepth:a,maximumObjectsPerNode:b,objectCount:c,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:d}}}_nodeToJSON(a){const b=a.children.map(d=>d?this._nodeToJSON(d):null),c=a.residents?.map(d=>this.objectToBoundingSphere(d));a=a.terminals?.map(d=>this.objectToBoundingSphere(d));return{children:b,residents:c,
terminals:a}}static fromJSON(a){const b=new F(c=>c,{maximumDepth:a.maximumDepth,maximumObjectsPerNode:a.maximumObjectsPerNode});b._objectCount=a.objectCount;b._root.initFrom(a.root.node,a.root.bounds,a.root.halfSize,a.root.depth);return b}}class l{constructor(){this.bounds=g.create();this.halfSize=0;this.initFrom(null,null,0,0)}init(a){return this.initFrom(a.node,a.bounds,a.halfSize,a.depth)}initFrom(a,b,c,d=this.depth){this.node=null!=a?a:l.createEmptyNode();b&&g.copy(b,this.bounds);this.halfSize=
c;this.depth=d;return this}increaseHalfSize(a){this.halfSize*=a;this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*X}advance(a){let b=this.node.children[a];b||(b=l.createEmptyNode(),this.node.children[a]=b);this.node=b;this.halfSize/=2;this.depth++;a=U[a];this.bounds[0]+=a[0]*this.halfSize;this.bounds[1]+=a[1]*this.halfSize;this.bounds[2]+=a[2]*this.halfSize;this.updateBoundsRadiusFromHalfSize();return this}advanceTo(a,b,c=!1){for(;;){if(this.isTerminalFor(a))return b&&
b(this,-1),!0;if(this.isLeaf()){if(!c)return b&&b(this,-1),!1;this.node.residents=null}const d=this._childIndex(a);b&&b(this,d);this.advance(d)}}isLeaf(){return null!=this.node.residents}isTerminalFor(a){return a[3]>this.halfSize/2}_childIndex(a){const b=this.bounds;return(b[0]<a[0]?1:0)+(b[1]<a[1]?2:0)+(b[2]<a[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new D({shrink:!0}),residents:new D({shrink:!0})}}static acquire(){return l._pool.acquire()}static release(a){l._pool.release(a)}static clearPool(){l._pool.prune()}}
l._pool=new Y(l);(function(a){a=a.DepthOrder||(a.DepthOrder={});a[a.FRONT_TO_BACK=1]="FRONT_TO_BACK";a[a.BACK_TO_FRONT=-1]="BACK_TO_FRONT"})(F||={});const U=[m.fromValues(-1,-1,-1),m.fromValues(1,-1,-1),m.fromValues(-1,1,-1),m.fromValues(1,1,-1),m.fromValues(-1,-1,1),m.fromValues(1,-1,1),m.fromValues(-1,1,1),m.fromValues(1,1,1)],V=[m.fromValues(-1,-1,-1),m.fromValues(-1,-1,1),m.fromValues(-1,1,-1),m.fromValues(-1,1,1),m.fromValues(1,-1,-1),m.fromValues(1,-1,1),m.fromValues(1,1,-1),m.fromValues(1,
1,1)],X=Math.sqrt(3),N=[null],Q=g.create(),v=m.create(),r=m.create(),t=m.create(),C=new D,aa=g.create(),y=g.create(),O=g.create(),P=g.create(),L=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],B=new D,W=[0,0,0,0,0,0,0,0];return F});