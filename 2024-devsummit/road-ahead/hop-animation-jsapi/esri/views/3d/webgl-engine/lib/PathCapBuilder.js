// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64"],function(p,m,v){class r{rebuildConnectingProfileGeometry(a,b,c){for(let e=0;e<b.vertices.length;++e)c(a.frame,b.vertices[e],b.normals[e],0,0)}}class x extends r{constructor(){super();this.numIndices=this.numVertices=0}rebuildCapGeometry(){}buildTopology(){}}class y extends r{constructor(a,b=0,c=!1){super();this.profile=a;this.profilePlaneOffset=b;this.flip=c}get numVertices(){return this.profile.vertices.length}get numIndices(){return 3*
this.profile.numSegments}rebuildConnectingProfileGeometry(a,b,c){const e=this.profilePlaneOffset;for(let d=0;d<b.vertices.length;++d)c(a.frame,b.vertices[d],b.normals[d],e,0)}rebuildCapGeometry(a,b){const c=this.profile,e=this.flip?1:-1,d=this.profilePlaneOffset,g=w;m.set(g,0,0);for(let f=0;f<c.vertices.length;++f)b(a.frame,c.vertices[f],g,d,e)}buildTopology(a,b){a=this.profile;const c=this.vertexBufferStart+a.indices[0];for(let e=1;e<a.numSegments;++e){const d=this.vertexBufferStart+a.indices[2*
e],g=this.vertexBufferStart+a.indices[2*e+1];this.flip?b(g,d,c):b(c,d,g)}}}class z extends r{constructor(a){super();this.flip=!1;this.sign=0;this.breakNormals=!1;this.numSegments=3;this.profile=a.profile;this.sign=(this.flip=a.flip)?1:-1;this.breakNormals=a.breakNormals;this.numSegments=a.subdivisions}get numVertices(){let a=this.profile.vertices.length*(this.numSegments-1)+this.profile.poles.length;this.breakNormals&&(a+=this.profile.vertices.length);return a}get numIndices(){let a;const b=this.profile;
a=2*b.numSegments*(this.numSegments-1);for(let c=0;c<b.numSegments;++c)a=b.poleIndices[b.indices[2*c]]===b.poleIndices[b.indices[2*c+1]]?a+1:a+2;return 3*a}rebuildCapGeometry(a,b){const c=this.profile;a=a.frame;const e=.5*this.sign,d=A,g=w;m.set(g,0,0);for(var f of c.poles)f.normal?b(a,f.position,f.normal,e,0):b(a,f.position,g,e,this.sign);if(this.breakNormals)for(f=0;f<c.vertices.length;++f)b(a,c.vertices[f],c.normals[f],0,0);for(f=0;f<this.numSegments-1;++f){var k=(1-(f+1)/this.numSegments)*Math.PI*
.5;const n=Math.sin(k);k=Math.cos(k);for(let l=0;l<c.vertices.length;++l){const h=c.poles[c.poleIndices[l]];m.subtract(d,c.vertices[l],h.position);m.scale(d,d,n);h.normal?(m.add(d,d,h.position),b(a,d,h.normal,e*k,0)):(m.normalize(g,d),m.scale(g,g,n),m.add(d,d,h.position),b(a,d,g,e*k,this.sign*k))}}}buildTopology(a,b){a=this.profile;const c=this.breakNormals?this.vertexBufferStart+a.poles.length:this.firstProfileVertexIndex,e=this.breakNormals?this.vertexBufferStart+a.poles.length+a.vertices.length:
this.vertexBufferStart+a.poles.length;for(let d=0;d<a.numSegments;++d){const g=a.indices[2*d],f=a.indices[2*d+1],k=this.vertexBufferStart+a.poleIndices[g],n=this.vertexBufferStart+a.poleIndices[f];let l=c+g,h=c+f;for(let t=0;t<this.numSegments-1;++t){const q=e+t*a.vertices.length+g,u=e+t*a.vertices.length+f;this.flip?(b(q,h,l),b(h,q,u)):(b(l,h,q),b(u,q,h));l=q;h=u}this.flip?(b(k,h,l),k!==n&&b(k,n,h)):(b(l,h,k),k!==n&&b(h,n,k))}}}const A=v.create(),w=v.create();p.NoCapBuilder=x;p.PathCapBuilder=r;
p.RoundCapBuilder=z;p.TriangulationCapBuilder=y;Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});