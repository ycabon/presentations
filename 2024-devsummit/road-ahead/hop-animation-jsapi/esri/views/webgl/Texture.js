// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../core/Error ../../core/has ./checkWebGLError ./enums ./GLObjectType ./TextureDescriptor ./ValidatedTextureDescriptor".split(" "),function(z,n,A,v,g,G,H,I){function B(e){(null!=e.width&&0>e.width||null!=e.height&&0>e.height||null!=e.depth&&0>e.depth)&&console.error("Negative dimension parameters are not allowed!")}function C(e,a){let b=a.samplingMode,c=a.samplingMode;if(b===g.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||b===g.TextureSamplingMode.LINEAR_MIPMAP_LINEAR)b=g.TextureSamplingMode.LINEAR,
a.hasMipmap||(c=g.TextureSamplingMode.LINEAR);else if(b===g.TextureSamplingMode.NEAREST_MIPMAP_NEAREST||b===g.TextureSamplingMode.NEAREST_MIPMAP_LINEAR)b=g.TextureSamplingMode.NEAREST,a.hasMipmap||(c=g.TextureSamplingMode.NEAREST);e.texParameteri(a.target,e.TEXTURE_MAG_FILTER,b);e.texParameteri(a.target,e.TEXTURE_MIN_FILTER,c)}function D(e,a){"number"===typeof a.wrapMode?(e.texParameteri(a.target,e.TEXTURE_WRAP_S,a.wrapMode),e.texParameteri(a.target,e.TEXTURE_WRAP_T,a.wrapMode)):(e.texParameteri(a.target,
e.TEXTURE_WRAP_S,a.wrapMode.s),e.texParameteri(a.target,e.TEXTURE_WRAP_T,a.wrapMode.t))}function J(e,a){const b=e.capabilities.textureFilterAnisotropic;b&&e.gl.texParameterf(a.target,b.TEXTURE_MAX_ANISOTROPY,a.maxAnisotropy??1)}function y(e){return null!=e&&"type"in e&&"compressed"===e.type}function E(e){return null!=e&&!y(e)&&!(null!=e&&"byteLength"in e)}function w(e){return e===g.TextureType.TEXTURE_3D||e===g.TextureType.TEXTURE_2D_ARRAY}function F(e,a,b,c=1){a=Math.max(a,b);e===g.TextureType.TEXTURE_3D&&
(a=Math.max(a,c));return Math.round(Math.log(a)/Math.LN2)+1}A=class e{constructor(a,b=null,c=null){this.type=G.GLObjectType.Texture;this._glName=null;this._wasImmutablyAllocated=this._wrapModeDirty=this._samplingModeDirty=!1;if("context"in a)this._descriptor=a,c=b;else{a=I.ValidatedTextureDescriptor.validate(a,b);if(!a)throw new n("Texture descriptor invalid");this._descriptor=a}this._descriptor.target===g.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(c):this.setData(c)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return H.estimateMemory(this._descriptor)}get isDirty(){return this._samplingModeDirty||
this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(g.ResourceType.Texture,this);this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(a,b){const c=this._descriptor;if(c.width!==a||c.height!==b){if(this._wasImmutablyAllocated)throw new n("Immutable textures can't be resized!");c.width=a;c.height=b;this._descriptor.target===
g.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(a=null){for(let b=g.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;b<=g.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;b++)this._setData(a,b)}setData(a){this._setData(a)}_setData(a,b){if(this._descriptor.context?.gl){var c=this._descriptor.context.gl;v.checkWebGLError(c);this._glName||(this._glName=c.createTexture())&&this._descriptor.context.instanceCounter.increment(g.ResourceType.Texture,this);void 0===a&&(a=null);
var d=this._descriptor,h=b??d.target,m=w(h);null===a&&(d.width=d.width||4,d.height=d.height||4,m&&(d.depth=d.depth??1));b=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES);B(d);this._configurePixelStorage();v.checkWebGLError(c);var k=this._deriveInternalFormat();if(E(a)){let f="width"in a?a.width:a.codedWidth,l="height"in a?a.height:a.codedHeight;a instanceof HTMLVideoElement&&(f=a.videoWidth,l=a.videoHeight);
d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,k,d.hasMipmap,f,l,1);this._texImage(h,0,k,f,l,1,a);v.checkWebGLError(c);d.hasMipmap&&this.generateMipmap();d.width||(d.width=f);d.height||(d.height=l);m&&!d.depth&&(d.depth=1)}else{const {width:f,height:l,depth:q}=d;if(null==f||null==l)throw new n("Width and height must be specified!");if(m&&null==q)throw new n("Depth must be specified!");d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,k,d.hasMipmap,f,l,q);if(y(a)){const p=
a.levels;a=F(h,f,l,q);a=Math.min(a-1,p.length-1);c.texParameteri(d.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,a);if(!(k in g.CompressedTextureFormat))throw new n("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((r,t,x,u)=>{this._compressedTexImage(h,r,k,t,x,u,p[Math.min(r,p.length-1)])},a)}else this._texImage(h,0,k,f,l,q,a),v.checkWebGLError(c),d.hasMipmap&&this.generateMipmap()}C(c,this._descriptor);D(c,this._descriptor);J(this._descriptor.context,
this._descriptor);v.checkWebGLError(c);this._descriptor.context.bindTexture(b,e.TEXTURE_UNIT_FOR_UPDATES)}}updateData(a,b,c,d,h,m,k=0){m||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");var f=this._descriptor;const l=this._deriveInternalFormat(),{context:q,pixelFormat:p,dataType:r,target:t,isImmutable:x}=f;if(x&&!this._wasImmutablyAllocated)throw new n("Cannot update immutable texture before allocation!");const u=q.bindTexture(this,
e.TEXTURE_UNIT_FOR_UPDATES,!0);(0>b||0>c||d>f.width||h>f.height||b+d>f.width||c+h>f.height)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();({gl:f}=q);k&&f.pixelStorei(f.UNPACK_SKIP_ROWS,k);E(m)?f.texSubImage2D(t,a,b,c,d,h,p,r,m):y(m)?f.compressedTexSubImage2D(t,a,b,c,d,h,l,m.levels[a]):f.texSubImage2D(t,a,b,c,d,h,p,r,m);k&&f.pixelStorei(f.UNPACK_SKIP_ROWS,0);q.bindTexture(u,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(a,b,c,d,h,m,k,f){f||console.error("An attempt to use uninitialized data!");
this._glName||console.error("An attempt to update uninitialized texture!");var l=this._descriptor;const q=this._deriveInternalFormat(),{context:p,pixelFormat:r,dataType:t,isImmutable:x,target:u}=l;if(x&&!this._wasImmutablyAllocated)throw new n("Cannot update immutable texture before allocation!");w(u)||console.warn("Attempting to set 3D texture data on a non-3D texture");const K=p.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);p.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES);(0>b||0>c||0>d||h>l.width||
m>l.height||k>l.depth||b+h>l.width||c+m>l.height||d+k>l.depth)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();({gl:l}=p);y(f)?(f=f.levels[a],l.compressedTexSubImage3D(u,a,b,c,d,h,m,k,q,f)):l.texSubImage3D(u,a,b,c,d,h,m,k,r,t,f);p.bindTexture(K,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const a=this._descriptor;if(!a.hasMipmap){if(this._wasImmutablyAllocated)throw new n("Cannot add mipmaps to immutable texture after allocation");this._samplingModeDirty=
a.hasMipmap=!0;B(a)}a.samplingMode===g.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,a.samplingMode=g.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):a.samplingMode===g.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,a.samplingMode=g.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const b=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.gl.generateMipmap(a.target);this._descriptor.context.bindTexture(b,
e.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(a){a!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=a,this._samplingModeDirty=!0)}setWrapMode(a){a!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=a,B(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const a=this._descriptor,b=a.context.gl;this._samplingModeDirty&&(C(b,a),this._samplingModeDirty=!1);this._wrapModeDirty&&(D(b,a),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===
g.PixelFormat.DEPTH_STENCIL&&(this._descriptor.internalFormat=g.PixelFormat.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case g.PixelType.FLOAT:switch(this._descriptor.pixelFormat){case g.PixelFormat.RGBA:return this._descriptor.internalFormat=g.SizedPixelFormat.RGBA32F;case g.PixelFormat.RGB:return this._descriptor.internalFormat=g.SizedPixelFormat.RGB32F;default:throw new n("Unable to derive format");}case g.PixelType.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case g.PixelFormat.RGBA:return this._descriptor.internalFormat=
g.SizedPixelFormat.RGBA8;case g.PixelFormat.RGB:return this._descriptor.internalFormat=g.SizedPixelFormat.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===g.PixelFormat.DEPTH_STENCIL?g.PixelFormat.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const a=this._descriptor.context.gl,{unpackAlignment:b,flipped:c,preMultiplyAlpha:d}=this._descriptor;a.pixelStorei(a.UNPACK_ALIGNMENT,b);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,c?1:0);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
d?1:0)}_texStorage(a,b,c,d,h,m){const {gl:k}=this._descriptor.context;if(!(b in g.SizedPixelFormat))throw new n("Immutable textures must have a sized internal format");if(this._descriptor.isImmutable){c=c?F(a,d,h,m):1;if(w(a)){if(null==m)throw new n("Missing depth dimension for 3D texture upload");k.texStorage3D(a,c,b,d,h,m)}else k.texStorage2D(a,c,b,d,h);this._wasImmutablyAllocated=!0}}_texImage(a,b,c,d,h,m,k){const f=this._descriptor.context.gl,l=w(a),{isImmutable:q,pixelFormat:p,dataType:r}=this._descriptor;
if(q){if(null!=k)if(l){if(null==m)throw new n("Missing depth dimension for 3D texture upload");f.texSubImage3D(a,b,0,0,0,d,h,m,p,r,k)}else f.texSubImage2D(a,b,0,0,d,h,p,r,k)}else if(l){if(null==m)throw new n("Missing depth dimension for 3D texture upload");f.texImage3D(a,b,c,d,h,m,0,p,r,k)}else f.texImage2D(a,b,c,d,h,0,p,r,k)}_compressedTexImage(a,b,c,d,h,m,k){const f=this._descriptor.context.gl,l=w(a);if(this._descriptor.isImmutable){if(null!=k)if(l){if(null==m)throw new n("Missing depth dimension for 3D texture upload");
f.compressedTexSubImage3D(a,b,0,0,0,d,h,m,c,k)}else f.compressedTexSubImage2D(a,b,0,0,d,h,c,k)}else if(l){if(null==m)throw new n("Missing depth dimension for 3D texture upload");f.compressedTexImage3D(a,b,c,d,h,m,0,k)}else f.compressedTexImage2D(a,b,c,d,h,0,k)}_forEachMipmapLevel(a,b=Infinity){let {width:c,height:d,depth:h,hasMipmap:m,target:k}=this._descriptor;const f=k===g.TextureType.TEXTURE_3D;if(null==c||null==d||f&&null==h)throw new n("Missing texture dimensions for mipmap calculation");for(let l=
0;;++l){a(l,c,d,h);if(!m||1===c&&1===d&&(!f||1===h)||l>=b)break;c=Math.max(1,c>>1);d=Math.max(1,d>>1);f&&(h=Math.max(1,h>>1))}}};A.TEXTURE_UNIT_FOR_UPDATES=0;z.Texture=A;z.tracer=null;Object.defineProperty(z,Symbol.toStringTag,{value:"Module"})});