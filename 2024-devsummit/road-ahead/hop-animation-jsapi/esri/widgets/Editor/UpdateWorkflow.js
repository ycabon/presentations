// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../Graphic ../../core/Error ../../core/handleUtils ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/Queue ../../core/reactiveUtils ../../core/SetUtils ../../core/accessorSupport/decorators/property ../../core/has ../../core/RandomLCG ../../core/accessorSupport/decorators/subclass ../../layers/support/editableLayers ../../layers/support/layerUtils ../../views/draw/support/HighlightHelper ./CreateFeaturesWorkflow ./UpdateFeatureWorkflow ./UpdateRecordWorkflow ./UpdateWorkflowData ./Workflow ./workflowUtils ../Feature/support/featureUtils ../support/templateUtils".split(" "),
function(h,B,l,w,C,D,t,x,m,y,k,g,Q,E,z,u,F,G,H,I,J,K,A,L,M){var v;g=v=class extends K{constructor(a){super(a);this._workflowStack=new x(y.last);this._sketchStack=new x(y.last);this.type="update"}get activeEditableItem(){return this.activeWorkflow?.data.editableItem??void 0}get activeFeatureFormViewModel(){return this.activeWorkflow?.featureFormViewModel}get activeSketchViewModel(){return this._sketchStack.peek()?.viewModel}get activeWorkflow(){return this._workflowStack.last()}get nestedWorkflowCount(){return this._workflowStack.length}get shouldShowAttachments(){return!!this.activeEditableItem?.attachmentsOnUpdateEnabled}get shouldAllowAttachmentEditing(){return!!this.activeEditableItem?.supports.includes("update")}get hasPendingEdits(){return Array.from(this._workflowStack).some(a=>
a.hasPendingEdits)}get helpMessage(){return this.activeWorkflow?.helpMessage?this.activeWorkflow.helpMessage:"awaiting-feature-to-update"===this.stepId?"select":void 0}get reliesOnOwnerAdminPrivileges(){return this.activeWorkflow?.reliesOnOwnerAdminPrivileges??!1}get hasInvalidFormTemplate(){return!!this.activeEditableItem?.hasInvalidFormTemplate}get hasUnsupportedFields(){return!!this.activeEditableItem?.hasUnsupportedFields}async back(a=()=>Promise.resolve(!0)){const {activeWorkflow:b}=this;if(null!=
b?.featureFormViewModel.relationshipId)b.featureFormViewModel.relationshipId=null;else if(b){if(!b.hasPendingEdits||await a())b.hasPreviousStep?await b.previous({cancelCurrentStep:!0}):await this.cancelActiveWorkflow({force:!0})}else this.hasPreviousStep?await this.previous({cancelCurrentStep:!0}):await this.cancel({force:!0})}async cancelActiveWorkflow(a){await this.activeWorkflow?.cancel(a);await this._popWorkflow()}async commit(){await this._drainWorkflowStack(a=>a.commit());await super.commit()}static create(a){const {viewModel:b,
startAt:c,addAttachmentsCallback:d,applyEditsCallback:e}=a;a=new v({data:new J({addAttachmentsCallback:d,applyEditsCallback:e,viewModel:b}),onCommit:async()=>{}});a._set("steps",this._createWorkflowSteps(a,c));return a}async save(){1<this.nestedWorkflowCount?(await this.activeWorkflow?.commit(),await this._popWorkflow()):await this.commit()}async startCreatingRelatedRecord(a){try{const b=await this._createNestedCreateFeaturesWorkflow(a);await this._pushWorkflow(b)}catch(b){throw new l("editor:unable-to-start-creating",
"Could not begin updating the provided feature or table record.",{error:b});}}async startUpdating(a){try{const b=await this._createNestedUpdateWorkflow(a);await this._pushWorkflow(b)}catch(b){throw new l("editor:unable-to-start-updating","Could not begin updating the provided feature or table record.",{error:b});}}async deleteActiveFeature(){const {activeWorkflow:a}=this;if(!a)throw new l("editor:nothing-to-delete","There is no feature to delete");a&&/update-/.test(a.type)?await a.deleteAndCommit():
await a.cancel();1===this.nestedWorkflowCount?await this.reset():await this._popWorkflow()}async cancelAll(){await this._drainWorkflowStack(a=>a.cancel({force:!0}))}async _createNestedCreateFeaturesWorkflow(a){const {relatedLayer:b}=a,{addAttachmentsCallback:c,applyEditsCallback:d,viewModel:e}=this.data;if(!z.isEditableLayer(b))throw new l("editor:unsupported-layer","Editing is not supported on the provided layer");a=this._getCreationInfoForNestedCreateFeaturesWorkflow(a);return G.create({addAttachmentsCallback:c,
applyEditsCallback:d,creationInfo:a,isNested:!0,parent:"create-features"!==this.activeWorkflow?.type?this.activeWorkflow:void 0,startAt:a.template||a.initialFeature?"creating-features":"awaiting-feature-creation-info",viewModel:e})}_getCreationInfoForNestedCreateFeaturesWorkflow(a){const {relatedLayer:b}=a;if(!z.isEditableLayer(b)||u.isSubtypeGroupLayer(b))throw new l("editor:unsupported-layer","Editing is not supported on the provided layer");const c={layer:b,maxFeatures:1};a=this._makeRelatedRecordAttributes(a);
const d=M.getAllTemplatesForLayer(b);0<d?.length?(c.attributeOverrides=a,1===d.length&&(c.template=d[0])):c.initialFeature=new B({sourceLayer:b,attributes:a});return c}async _createNestedUpdateWorkflow(a){const b=u.isTable(a.sourceLayer)?I.UpdateRecordWorkflow:H.UpdateFeatureWorkflow,{applyEditsCallback:c,viewModel:d}=this.data,e=await b.create({feature:a,parent:"create-features"!==this.activeWorkflow?.type?this.activeWorkflow:void 0,viewModel:d,applyEdits:c,relatedRecordCallbacks:{addRelatedRecord:async f=>
await this.startCreatingRelatedRecord(f),editRelatedRecord:async({relatedFeature:f})=>await this.startUpdating(f)}});await m.whenOnce(()=>!e.updating);return e}async _drainWorkflowStack(a){const b=this._workflowStack,c=[];for(;0<b.length;){const d=b.pop();this._sketchStack.pop();const e=a(d).then(()=>d.destroy());this._updatingHandles.addPromise(e);c.push(e)}await Promise.all(c)}_makeRelatedRecordAttributes(a){const {parentFeature:b,relatedLayer:c,relationshipId:d}=a;if(L.isGraphicForRelatableFeatureSupportedLayer(b))if(a=
c.relationships?.find(f=>f.id===d))if("origin"===a.role)n("unsupported-role","Creating new related records in the 'origin' table of a relationship is not yet supported");else{var e=b.sourceLayer;a.relatedTableId!==e.layerId&&n("invalid-argument-combination","The given parent feature does not belong to the relationship designated by the given relationship ID.");if(e=e.relationships?.find(f=>f.id===d))return(e=b.getAttribute(e.keyField))||n("no-key-on-origin-feature","The given parent feature does not have a value for the relationship's origin primary key field."),
{[a.keyField]:e};n("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the origin layer.")}else n("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the destination layer.")}async _popWorkflow(){this._workflowStack.pop()?.destroy();this._sketchStack.pop();const a=await this._reconcileWorkflowStack();if(0<a.failureCount)throw new l("editor:next-workflow-failed",
"Popped the top workflow, but the next workflow in the stack failed to activate",a);}async _pushWorkflow(a){var b=this._workflowRequiresSketchViewModel(a);this.activeWorkflow?.exit({removeSketchHandles:b});b=this._sketchStack;const c=await a?.start(),d=b.peek();c?(d?.exit(),b.push(c)):b.push(this._cloneSketchController(d));this._workflowStack.push(a);a=await this._reconcileWorkflowStack();if(0<a.failureCount)throw new l("editor:failed-to-start-updating-feature","Failed to enter the provided workflow.",
a);}async _reconcileWorkflowStack(){const a=this._workflowStack,b=this._sketchStack;try{const c=a.peek();await c?.enter();await b.peek()?.enter();return{activeWorkflow:c,failureCount:0}}catch(c){a.pop().destroy();b.pop();const {activeWorkflow:d,failureCount:e}=await this._reconcileWorkflowStack();return{activeWorkflow:d,failureCount:e+1}}}_cloneSketchController(a){return{enter:a?.enter??(async()=>{}),exit:a?.exit??(async()=>{}),viewModel:a?.viewModel}}_workflowRequiresSketchViewModel(a){const {type:b}=
a;return"update-feature"===b||"create-features"===b&&!u.isTable(a.data.creationInfo?.layer)}static _createWorkflowSteps(a,b="awaiting-feature-to-update"){const {data:c}=a;return A.createWorkflowSteps(["awaiting-feature-to-update","awaiting-update-feature-candidate","editing-existing-feature","adding-attachment","editing-attachment"],b,{"awaiting-feature-to-update":()=>({id:"awaiting-feature-to-update",async setUp(){const {spinnerViewModel:d}=c.viewModel,e=c.viewModel.view;let f=null;a.addHandles(w.makeHandle(()=>
{f=D.abortMaybe(f)}),this.id);c.rootFeature=null;c.candidates=[];const r=e.on("immediate-click",async p=>{p.stopPropagation();d.location=p.mapPoint;d.visible=!0;f?.abort();const {editableItems:N}=c.viewModel;f=new AbortController;const P=await new Promise((q,O)=>{t.onAbort(f?.signal,()=>O(t.createAbortError()));q(A.fetchCandidates(N,e,p,f?.signal))});t.throwIfAborted(f);c.candidates=P.filter(q=>"fulfilled"===q.status).flatMap(q=>q.value);d.visible=1===c.candidates.length;0!==c.candidates.length&&
(1===c.candidates.length?(c.rootFeature=c.candidates[0],a.go("editing-existing-feature").catch(()=>{}).then(()=>d.visible=!1)):a.next())});e.focus();a.addHandles(r,this.id)},async tearDown(){0===c.candidates.length&&(c.viewModel.spinnerViewModel.visible=!1);a.removeHandles(this.id)}}),"awaiting-update-feature-candidate":()=>({id:"awaiting-update-feature-candidate",async setUp(){c.rootFeature=null;const {view:d}=c.viewModel;if(d){var e=new F({view:d});a.addHandles([m.watch(()=>c.rootFeature,(f,r)=>
{e.remove(r);e.add(f)},m.sync),w.makeHandle(()=>e.removeAll())],this.id)}},async tearDown(){a.removeHandles(this.id)}}),"editing-existing-feature":()=>({id:"editing-existing-feature",async setUp(){const {rootFeature:d,viewModel:e}=a.data;if(!d)throw new l("editor:no-feature-specified","Cannot setup the 'updating-existing-feature' step until the root feature is defined");await a.startUpdating(d);e.spinnerViewModel.visible=!1;const f=t.debounce(async()=>{await m.whenOnce(()=>!a.updating);a.previous()});
a.addHandles([m.watch(()=>a.nestedWorkflowCount,(r,p)=>{0===r&&0!==p&&f()},m.sync)],this.id)},async tearDown(){await a.cancelAll();a.removeHandles(this.id)}}),"adding-attachment":()=>({id:"adding-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){c.viewModel.attachmentsViewModel.mode="view"}}),"editing-attachment":()=>({id:"editing-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){c.viewModel.attachmentsViewModel.mode="view"}})})}};h.__decorate([k.property()],
g.prototype,"activeEditableItem",null);h.__decorate([k.property()],g.prototype,"activeFeatureFormViewModel",null);h.__decorate([k.property()],g.prototype,"activeSketchViewModel",null);h.__decorate([k.property()],g.prototype,"activeWorkflow",null);h.__decorate([k.property()],g.prototype,"nestedWorkflowCount",null);h.__decorate([k.property()],g.prototype,"shouldShowAttachments",null);h.__decorate([k.property()],g.prototype,"shouldAllowAttachmentEditing",null);h.__decorate([k.property()],g.prototype,
"hasPendingEdits",null);h.__decorate([k.property()],g.prototype,"helpMessage",null);h.__decorate([k.property()],g.prototype,"reliesOnOwnerAdminPrivileges",null);h.__decorate([k.property()],g.prototype,"hasInvalidFormTemplate",null);h.__decorate([k.property()],g.prototype,"hasUnsupportedFields",null);g=v=h.__decorate([E.subclass("esri.widgets.Editor.UpdateWorkflow")],g);const n=(a,b)=>C.getLogger("esri.widgets.Editor.UpdateWorkflow").warn(`editor:${a}`,b,"The create operation will be allowed to proceed, but the resulting feature may not be related to the given parent feature.");
return g});