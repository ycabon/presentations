// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.29/esri/copyright.txt for details.
//>>built
define("exports ../../../core/arrayUtils ../../../core/mathUtils ../../../core/promiseUtils ../../../geometry/Multipoint ../../../geometry/support/coordsUtils ../../../geometry/support/spatialReferenceUtils ../../../views/support/QueueProcessor ../../../views/support/Scheduler ./constants ./geometryUtils ./ProfileGenerationError ./statisticsUtils ../../support/traversalUtils".split(" "),function(u,E,F,t,G,H,I,J,K,x,y,r,L,M){function*A(a,b){var {densificationResult:d}=a;a={...a,abortOptions:b,densificationResult:d};
b=M.breadthFirstBinaryPartitioning(0,a.result.samples.length);d=b.slice(0,a.provider.numSamplesForPreview);yield B(a,d,!0);b=E.splitIntoChunks(b,a.provider.numSamplesPerChunk);for(const h of b)yield B(a,h,!1)}async function B({densificationResult:a,result:b,provider:d,queue:h,abortOptions:g,cache:l},k,f){const {densifiedPath:e,pathLength:m}=a;a=b.spatialReference;const {samples:n}=b,p=[];for(let c=0;c<k.length;c++)p[c]=n[k[c]].coordinate;try{return await h.push({geometry:new G({spatialReference:a,
points:p,hasZ:e.hasZ}),provider:d,indices:k,preview:f,result:b,queryOptions:{...x.getConfig().defaultQueryOptions(),minDemResolution:f?Math.round(m/d.numSamplesForPreview):Math.round(m/n.length),cache:l}},g),{...b}}catch(c){return t.isAbortError(c)?null:x.errorResult}}async function N({geometry:a,provider:b,indices:d,preview:h,result:g,queryOptions:l}){if(0!==d.length){a=(await O(b,a,l)).geometry;var {hasZ:k,points:f}=a;l=l.noDataValue;({samples:a}=g);for(b=0;b<d.length;b++){const e=a[d[b]];if(e.isHole)continue;
const m=k?f[b][2]:null;null===m||m===l?e.sampledZ=null:(g.hasZ=!0,e.sampledZ=m);e.sampled=!0}C(a);g.progress=h?0:g.progress+d.length/a.length;g.statistics=L.getStatistics(g.samples,g.spatialReference)}}function C(a){const b=a.length-1;var d=0;for(let e=1;e<=b;e++)if(a[e].sampled||e===b){a:{var h=a,g=d;d=e;if(1===d-g)break a;var l=h[g],k=l.sampledZ,f=h[d];const m=f.sampledZ;if(null==k||null==m)for(k=g+1;k<d;k++)h[k].sampledZ=null;else for(l=l.distance,f=f.distance-l,g+=1;g<d;g++){const n=h[g];n.sampledZ=
F.lerp(k,m,(n.distance-l)/f)}}d=e}}function P({densifiedPath:a,distances:b}){const d=a.spatialReference,h=I.getInfo(d);a=a.paths;const g=a.length,l=[];let k=null,f=0;for(let p=0;p<g;p++){const c=a[p],q=c.length,Q=b[p];for(let v=0;v<q;v++){const w=c[v],z=Q[v];h&&(w[0]=H.unnormalizedCoordinate(w[0],h.valid[0],h.valid[1]));if(k&&0===v){var e=l,m=w,n=z;e.push(D(k,f));e.push(D(m,n))}l.push({coordinate:w,distance:z,sampledZ:null,sampled:!1,isHole:!1});k=w;f=z}}return{progress:0,samples:l,hasZ:!1,statistics:null,
spatialReference:d}}function D(a,b){return{coordinate:a,distance:b,sampledZ:null,sampled:!0,isHole:!0}}async function O(a,b,d){try{return await a.queryElevation(b,d)}catch(h){throw new r.ProfileGenerationError(r.ProfileGenerationErrorCause.ElevationQueryError);}}u.createProfileQueue=function(a){return new J.QueueProcessor({priority:K.TaskPriority.ELEVATION_PROFILE,concurrency:1,scheduler:a,process:async b=>{t.throwIfAborted(b.queryOptions);try{await N(b)}catch(d){t.throwIfNotAbortError(d)}}})};u.generateProfile=
A;u.generateProfiles=async function*(a,b){const {view:d,geometry:h,elevationInfo:g,providers:l,options:k}=a;var f=d.spatialReference;if(!f||null==h||!y.isValidInputPath(h))throw new r.ProfileGenerationError(r.ProfileGenerationErrorCause.InvalidGeometry);const e=l.length;if(0===e)return null;var m=Math.round(k.maxTotalSamples/e);if(y.countPoints(h)>m)throw new r.ProfileGenerationError(r.ProfileGenerationErrorCause.TooComplex);var n=await y.densifyPath(h,g,d,f,k,m,b),p=0;f=Array(e);m=Array(e);for(let c=
0;c<e;c++){const q=P(n);f[c]=q;p+=q.samples.length;m[c]=A({...a,provider:l[c],result:q,densificationResult:n},b)[Symbol.iterator]()}if(p>k.maxTotalSamples)throw new r.ProfileGenerationError(r.ProfileGenerationErrorCause.TooComplex);n=await Promise.all(m.map(c=>{c=c.next();return!0===c.done?Promise.resolve(null):c.value}));t.throwIfAborted(b);for(p=0;p<e;p++)f[p]=n[p];yield f;await t.after(a.delayAfterPreview??x.getConfig().delayAfterPreviewMillis,null,b.signal);a=[];try{let c;do for(c=!1,n=0;n<e;n++){const q=
m[n].next();!1===q.done&&(a.push({resultPromise:q.value,index:n}),c=!0)}while(c)}finally{m.forEach(c=>c.return?.())}for(const {resultPromise:c,index:q}of a)f[q]=await c,t.throwIfAborted(b),yield f;for(const c of f)null!=c&&(c.progress=1);yield f};u.interpolateElevations=C;Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});